/**
 * I don’t care how long this code is or whether it’s efficient — it was all generated by AI anyway. Even this line generated by AI too, lol.
*/
// ========== DOM CACHE ==========
const DOM_ELEMENTS = {
  topOfPage: document.getElementById('top'),
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  blueSet: document.getElementById("blueSet"),
  blueSetLabel: document.getElementById("blueSetLabel"),
  vesperSet: document.getElementById("vesperSet"),
  vesperSetLabel: document.getElementById("vesperSetLabel"),
  whiteSet: document.getElementById("whiteSet"),
  whiteSetLabel: document.getElementById("whiteSetLabel"),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  attack: document.getElementById('attack'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmgStack: document.getElementById('dmgStack'),
  dmgStackTips: document.getElementById('dmgStackTips'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeEnhLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  testSpear: document.getElementById('testSpear'),
  testReaper: document.getElementById('testReaper'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog"),
  stickyStart: document.getElementById("stickyStart")
};

// ========== DATA CONSTANTS ==========
const VESPER_SET = {
  0: 8,
  1: 16,
  2: 24,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64,
  8: 72,
  9: 80
};
const BLUE_SET = {
  3: {
    30: 5,
    40: 7.5,
    50: 10,
    60: 12.5,
    70: 15,
    80: 17.5,
    90: 20,
    100: 22.5,
    110: 25,
    120: 27.5,
    130: 30,
    140: 32.5,
    150: 35
  /**
   * 
  },
  8: {
    30: 5,
    40: 10,
    50: 15,
    60: 20,
    70: 25,
    80: 30,
    90: 35,
    100: 40,
    110: 45,
    120: 50,
    130: 55,
    140: 60,
    150: 65
   */
  }
};
const WHITE_SET = {
  "Tier 0": 30,
  "Tier 1": 36,
  "Tier 2": 42,
  "Tier 3": 48,
  "Tier 4": 54
};
const ELEMENT_COUNTER_TABLE = {
  Neutral: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 1,
    Shadow: 1,
    Ghost: 0.70,
    Undead: 1
  },
  Fire: {
    Neutral: 1,
    Fire: 0.25,
    Water: 1,
    Earth: 1.25,
    Wind: 1,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1.125
  },
  Water: {
    Neutral: 1,
    Fire: 1.25,
    Water: 0.25,
    Earth: 1,
    Wind: 0.90,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Earth: {
    Neutral: 1,
    Fire: 0.90,
    Water: 1,
    Earth: 0.25,
    Wind: 1.25,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Wind: {
    Neutral: 1,
    Fire: 1,
    Water: 1.375,
    Earth: 0.90,
    Wind: 0.25,
    Poison: 1,
    Holy: 0.70,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Poison: {
    Neutral: 1,
    Fire: 1.125,
    Water: 1,
    Earth: 1.125,
    Wind: 1.125,
    Poison: 0,
    Holy: 0.75,
    Shadow: 0.50,
    Ghost: 1,
    Undead: -0.25
  },
  Holy: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 0,
    Shadow: 1.375,
    Ghost: 1,
    Undead: 1.375
  },
  Shadow: {
    Neutral: 1.125,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 0.50,
    Holy: 1.375,
    Shadow: 0,
    Ghost: 1,
    Undead: -0.25
  },
  Ghost: {
    Neutral: 0.90,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 0.75,
    Shadow: 0.75,
    Ghost: 1.375,
    Undead: 1
  },
  Undead: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 0.50,
    Holy: 1.375,
    Shadow: 0,
    Ghost: 1.25,
    Undead: 0
  }
};
const WEAPON_SIZE_MODIFIER_TABLE = {
  "Empty Handed": {
    Large: 0.5,
    Medium: 0.5,
    Small: 0.5
  },
  "One-Handed Sword": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Two-Handed Sword": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Two-Handed Spear": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Dagger": {
    Large: 0.75,
    Medium: 0.75,
    Small: 1
  },
  "Katar": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Light Knuckle": {
    Large: 0.75,
    Medium: 0.75,
    Small: 1
  },
  "Heavy Knuckle": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "GS": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Ninja Sword": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Huuma Shuriken": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Tome": {
    Large: 0.75,
    Medium: 1,
    Small: 1
  },
  "Book": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Two-Handed Staff": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "One-Handed Staff": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Mace": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "One-Handed Axe": {
    Large: 0.75,
    Medium: 0.75,
    Small: 0.75
  },
  "Two-Handed Axe": {
    Large: 0.5,
    Medium: 0.75,
    Small: 0.75
  },
  "Bow": {
    Large: 0.75,
    Medium: 1,
    Small: 1
  },
  "Instrument": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Whip": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  }
};
const RACE_TYPES = [
  "Angel", 
  "Demon", 
  "Formless", 
  "Insect", 
  "Fish", 
  "Demi-Human", 
  "Undead", 
  "Dragon", 
  "Plant", 
  "Brute"
];
// Defense Stats From Nila
const DEFENSE_TABLE = {
  "DUMMY Lvl.0 (0 DEF)": {
    def: 0,
    dmgred: 0
  },
  "Avg. MVP Lvl.130": {
    def: 182.27,
    dmgred: 148.10
  },
  "Avg. MINI Lvl.130": {
    def: 206.45,
    dmgred: 165.52
  },
  "Avg. MVP MINI Lvl.130": {
    def: 194.36,
    dmgred: 156.81
  },
  "Avg. MVP Lvl.140": {
    def: 155.32,
    dmgred: 191.35
  },
  "Avg. MINI Lvl.140": {
    def: 161.41,
    dmgred: 233.48
  },
  "Avg. MVP MINI Lvl.140": {
    def: 158.37,
    dmgred: 212.41
  },
  "Avg. MVP Lvl.150": {
    def: 191.03,
    dmgred: 283.92
  },
  "Avg. MINI Lvl.150": {
    def: 198.53,
    dmgred: 324.23
  },
  "Avg. MVP MINI Lvl.150": {
    def: 194.78,
    dmgred: 304.08
  },
  "Avg. Small MVP Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small"
  },
  "Avg. Medium MVP Lv.140": {
    def: 199.62,
    dmgred: 195.88,
    sizeMob: "Medium"
  },
  "Avg. Large MVP Lv.140": {
    def: 143.05,
    dmgred: 184.84,
    sizeMob: "Large"
  },
  "Avg. Small MINI Lv.140": {
    def: 161.12,
    dmgred: 225.97,
    sizeMob: "Small"
  },
  "Avg. Medium MINI Lv.140": {
    def: 148.23,
    dmgred: 212.13,
    sizeMob: "Medium"
  },
  "Avg. Large MINI Lv.140": {
    def: 178.61,
    dmgred: 267.37,
    sizeMob: "Large"
  },
  "Avg. Small MVP Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small"
  },
  "Avg. Medium MVP Lv.150": {
    def: 240.07,
    dmgred: 273.72,
    sizeMob: "Medium"
  },
  "Avg. Large MVP Lv.150": {
    def: 177.51,
    dmgred: 282.29,
    sizeMob: "Large"
  },
  "Avg. Small MINI Lv.150": {
    def: 198.01,
    dmgred: 312.15,
    sizeMob: "Small"
  },
  "Avg. Medium MINI Lv.150": {
    def: 182.88,
    dmgred: 304.72,
    sizeMob: "Medium"
  },
  "Avg. Large MINI Lv.150": {
    def: 219.08,
    dmgred: 359.67,
    sizeMob: "Large"
  },
  "Phreeoni Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mistress Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eddga Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Kraken Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Maya Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Orc Hero Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Pharaoh Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Shadow"
  },
  "Orc Lord Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Doppelganger Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Amon Ra Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Morroc Lv.140": {
    def: 131.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Time Holder Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Tao Gunka Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Lost Dragon Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Fallen Bishop Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Lord of the Dead Lv.140": {
    def: 131.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Arc Angeling Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Gioia Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Wind"
  },
  "RSX-0806 Lv.140": {
    def: 238.66,
    dmgred: 202.00,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Neutral"
  },
  "Nidhoggr's Shadow Lv.140": {
    def: 181.21,
    dmgred: 134.00,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Gloom Under Night Lv.140": {
    def: 306.00,
    dmgred: 300.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Ghost"
  },
  "Retribution Lv.140": {
    def: 256.50,
    dmgred: 300.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Shadow"
  },
  "Dragon Fly Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eclipse Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mastering Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Plant",
    attributeMob: "Water"
  },
  "Ghostring Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Toad Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Small",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "King Dramoh Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Angeling Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Deviling Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Dark Priest Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Undead"
  },
  "Vagabond Wolf Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Brute",
    attributeMob: "Earth"
  },
  "Chimera Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Mysteltainn Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Ogretooth Lv.140": {
    def: 212.68,
    dmgred: 306.35,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Necromancer Lv.140": {
    def: 131.97,
    dmgred: 150.75,
    sizeMob: "Medium",
    raceMob: "Undead",
    attributeMob: "Undead"
  },
  "Coelacanth Lv.140": {
    def: 139.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Naght Sieger Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Observation Lv.140": {
    def: 146.68,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Neutral"
  },
  "Skeggiold Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Small",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Queen Scaraba Lv.140": {
    def: 212.30,
    dmgred: 268.70,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Faceworm Queen Lv.140": {
    def: 245.30,
    dmgred: 268.70,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Poison"
  },
  "Ktullanux Lv.140": {
    def: 256.50,
    dmgred: 542.27,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Water"
  },
  "Shelter Lv.140": {
    def: 251.18,
    dmgred: 258.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Phreeoni Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mistress Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eddga Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Kraken Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Maya Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Orc Hero Lv.150": {
    def: 110.67,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Pharaoh Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Shadow"
  },
  "Orc Lord Lv.150": {
    def: 110.67,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Doppelganger Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Amon Ra Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Morroc Lv.150": {
    def: 169.17,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Time Holder Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Tao Gunka Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Lost Dragon Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Fallen Bishop Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Lord of the Dead Lv.150": {
    def: 169.17,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Arc Angeling Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Gioia Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Wind"
  },
  "RSX-0806 Lv.150": {
    def: 293.16,
    dmgred: 317.00,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Neutral"
  },
  "Nidhoggr's Shadow Lv.150": {
    def: 228.13,
    dmgred: 266.00,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Gloom Under Night Lv.150": {
    def: 357.57,
    dmgred: 367.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Ghost"
  },
  "Retribution Lv.150": {
    def: 299.07,
    dmgred: 367.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Shadow"
  },
  "Dragon Fly Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eclipse Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mastering Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Plant",
    attributeMob: "Water"
  },
  "Ghostring Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Toad Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Small",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "King Dramoh Lv.150": {
    def: 110.67,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Angeling Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Deviling Lv.150": {
    def: 110.66,
    dmgred: 261.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Dark Priest Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Undead"
  },
  "Vagabond Wolf Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Brute",
    attributeMob: "Earth"
  },
  "Chimera Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Mysteltainn Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Ogretooth Lv.150": {
    def: 259.48,
    dmgred: 385.89,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Necromancer Lv.150": {
    def: 169.17,
    dmgred: 272.00,
    sizeMob: "Medium",
    raceMob: "Undead",
    attributeMob: "Undead"
  },
  "Coelacanth Lv.150": {
    def: 175.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Naght Sieger Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Observation Lv.150": {
    def: 181.48,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Neutral"
  },
  "Skeggiold Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Small",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Queen Scaraba Lv.150": {
    def: 258.55,
    dmgred: 351.40,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Faceworm Queen Lv.150": {
    def: 297.55,
    dmgred: 351.40,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Poison"
  },
  "Ktullanux Lv.150": {
    def: 299.07,
    dmgred: 575.77,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Water"
  },
  "Shelter Lv.150": {
    def: 293.16,
    dmgred: 317.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  }
};
const cache = (() => {
  const stores = {
    weaponSize: new Map(),
    elementCounter: new Map(),
    defenseData: new Map()
  };

  const warm = () => {
    Object.entries(WEAPON_SIZE_MODIFIER_TABLE).forEach(([w, sizes]) =>
      Object.entries(sizes).forEach(([s, v]) => stores.weaponSize.set(`${w}:${s}`, v)));
    Object.entries(ELEMENT_COUNTER_TABLE).forEach(([w, targets]) =>
      Object.entries(targets).forEach(([t, v]) => stores.elementCounter.set(`${w}:${t}`, v)));
    Object.entries(DEFENSE_TABLE).forEach(([k, v]) => stores.defenseData.set(k, v));
  };

  warm();
  return {
    get: (type, key) => stores[type]?.get(key),
    clear: (type) => type ? stores[type]?.clear() : Object.values(stores).forEach(s => s.clear()),
    rewarm: warm
  };
})();

// ========== CENTRALIZED STATE ==========
const AppState = (() => {
  const state = {
    isResultShown: false,
    isTestReaperActive: false,
    isTestSpearActive: false,
    isFlashActive: false,
    keyboardListenersAdded: false,
    currentAnimatingWeapon: null
  };
  const listeners = new Set();
  let cleanupInterval = null;

  const toggleCleanup = (start) => {
    if (start && !cleanupInterval) {
      cleanupInterval = setInterval(() => listeners.size === 0 && (clearInterval(cleanupInterval), cleanupInterval = null), 60000);
    } else if (!start && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  return {
    get: (key) => state[key],
    set: (key, value) => {
      if (state[key] === value) return false;
      const old = state[key];
      state[key] = value;
      listeners.forEach(fn => {
        try {
          fn(key, value, old);
        } catch {
          listeners.delete(fn);
        }
      });
      return true;
    },
    reset: () => Object.keys(state).forEach(k => state[k] = typeof state[k] === 'boolean' ? false : null),
    subscribe: (fn) => {
      if (typeof fn !== 'function') return () => {};
      listeners.add(fn);
      listeners.size === 1 && toggleCleanup(true);
      return () => (listeners.delete(fn), listeners.size === 0 && toggleCleanup(false));
    },
    clearListeners: () => (listeners.clear(), toggleCleanup(false)),
    getListenerCount: () => listeners.size
  };
})();

// ========== EVENT MANAGER ==========
const EventManager = (() => {
  const listenersByElement = new WeakMap();
  const listenersById = new Map();
  const namespaces = new Map();
  let id = 0,
    cleanupInterval = null;

  const toggleCleanup = (start) => {
    if (start && !cleanupInterval) {
      cleanupInterval = setInterval(() => {
        Array.from(listenersById.entries())
          .filter(([, l]) => !l?.el || !(l.el instanceof Node) || !document.contains(l.el))
          .forEach(([listenerId]) => remove(listenerId));
      }, 30000);
    } else if (!start && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  const add = (el, evt, handler, opts = false) => {
    if (!el?.addEventListener) return null;
    const listenerId = ++id;
    el.addEventListener(evt, handler, opts);
    listenersById.set(listenerId, {
      el,
      evt,
      handler,
      opts
    });

    if (!listenersByElement.has(el)) listenersByElement.set(el, new Set());
    listenersByElement.get(el).add(listenerId);
    listenersById.size === 1 && toggleCleanup(true);
    return listenerId;
  };

  const remove = (listenerId) => {
    const listener = listenersById.get(listenerId);
    if (!listener) return false;

    const {
      el,
      evt,
      handler,
      opts
    } = listener;
    try {
      el?.removeEventListener?.(evt, handler, opts);
    } catch {}
    listenersById.delete(listenerId);

    try {
      const elementListeners = listenersByElement.get(el);
      elementListeners?.delete(listenerId);
      elementListeners?.size === 0 && listenersByElement.delete(el);
    } catch {}

    listenersById.size === 0 && toggleCleanup(false);
    return true;
  };

  const removeFromElement = (el) => {
    if (!el) return 0;
    try {
      const elementListeners = listenersByElement.get(el);
      if (!elementListeners) return 0;
      return Array.from(elementListeners).reduce((count, id) => count + (remove(id) ? 1 : 0), 0);
    } catch {
      return 0;
    }
  };

  const addNS = (namespace, el, evt, handler, opts = false) => {
    const listenerId = add(el, evt, handler, opts);
    if (!listenerId) return null;
    if (!namespaces.has(namespace)) namespaces.set(namespace, new Set());
    namespaces.get(namespace).add(listenerId);
    return listenerId;
  };

  const removeNS = (namespace) => {
    const nsListeners = namespaces.get(namespace);
    if (!nsListeners) return 0;
    const count = Array.from(nsListeners).reduce((c, id) => c + (remove(id) ? 1 : 0), 0);
    namespaces.delete(namespace);
    return count;
  };

  const removeAll = () => {
    toggleCleanup(false);
    listenersById.forEach(({
      el,
      evt,
      handler,
      opts
    }) => {
      try {
        el?.removeEventListener?.(evt, handler, opts);
      } catch {}
    });
    listenersById.clear();
    namespaces.clear();
  };

  const forceCleanup = () => {
    const toRemove = Array.from(listenersById.entries())
      .filter(([, l]) => !l?.el || !(l.el instanceof Node) || !document.contains(l.el))
      .map(([id]) => id);
    toRemove.forEach(remove);
    return toRemove.length;
  };

  return {
    add,
    remove,
    removeFromElement,
    addNS,
    removeNS,
    removeAll,
    forceCleanup
  };
})();

// ========== CALCULATION CORE ==========
const getWeaponSizeModifier = (weapon, size) => weapon === 'all' || !weapon ? WEAPON_SIZE_MODIFIER_TABLE : cache.get('weaponSize', `${weapon}:${size}`) ?? 1.0;
const getElementCounter = (weaponElem, targetElem) => weaponElem === 'all' || !weaponElem ? ELEMENT_COUNTER_TABLE : cache.get('elementCounter', `${weaponElem}:${targetElem || 'Neutral'}`) ?? 1.0;
const getTargetDefenseData = (key) => !key ? DEFENSE_TABLE : cache.get('defenseData', key) || DEFENSE_TABLE["DUMMY Lvl.0 (0 DEF)"];
function getCurrentCalculationState() {
  const safeNum = (el) => el ? (Number(el.value) || 0) : 0;
  const safeStr = (el) => el?.value || '';

  // Attack Type & Weapon (DOM row 1, cols 1-3)
  const atkType = safeStr(DOM_ELEMENTS.atkType);
  const weapon = safeStr(DOM_ELEMENTS.weapon);
  const wElem = safeStr(DOM_ELEMENTS.wElem);

  // Target Properties (DOM row 1, cols 4-7)
  const tDefKey = safeStr(DOM_ELEMENTS.tDef);
  const tSize = safeStr(DOM_ELEMENTS.tSize);
  const tRace = safeStr(DOM_ELEMENTS.tRace);
  const tAttr = safeStr(DOM_ELEMENTS.tAttr);

  // Equipment Sets (DOM row 1, cols 8-10)
  const vesper = safeNum(DOM_ELEMENTS.vesperSet);
  const vesperTier = vesper ? ((vesper - 8) / 8) : -1;

  // Extract blue set values
  let blue3 = 0,
    blue8 = 0;
  const blueSet = DOM_ELEMENTS.blueSet;
  if (blueSet?.selectedIndex >= 0) {
    const selectedOption = blueSet.options[blueSet.selectedIndex];
    if (selectedOption) {
      const blueValue = safeNum(blueSet);
      const optionText = selectedOption.textContent;
      if (optionText.includes('*3')) {
        blue3 = blueValue;
      } else if (optionText.includes('*8')) {
        blue8 = blueValue;
      }
    }
  }

  const white = safeNum(DOM_ELEMENTS.whiteSet);

  // Stats (DOM row 2, follows field order)
  const baseAttack = safeNum(DOM_ELEMENTS.attack);
  const pen = safeNum(DOM_ELEMENTS.pen);
  const crit = safeNum(DOM_ELEMENTS.crit);
  const dmg = safeNum(DOM_ELEMENTS.dmg);
  const elemEnh = safeNum(DOM_ELEMENTS.elemEnh);
  const sizeEnh = safeNum(DOM_ELEMENTS.sizeEnh);
  const race = safeNum(DOM_ELEMENTS.race);
  const attr = safeNum(DOM_ELEMENTS.attr);
  const dmgStack = safeNum(DOM_ELEMENTS.dmgStack);

  // Test equipment bonuses
  const isReaperActive = AppState.get('isTestReaperActive');
  const reaperValue = isReaperActive ? ((wElem === tAttr) || (wElem === "Neutral" && !tAttr) ? 84 : 28) : 0;

  const isSpearActive = AppState.get('isTestSpearActive');
  const spearValue = isSpearActive ? 84 : 0;

  const state = {
    baseAttack,
    atkType,
    pen,
    crit,
    dmg,
    sizeEnh,
    elemEnh,
    race,
    attr,
    weapon,
    tSize,
    wElem,
    tAttr,
    tRace,
    tDefKey,
    vesper,
    white,
    dmgStack,
    blue3,
    blue8,
    reaperValue,
    spearValue
  };

  const result = calculateMultiplier({
    ...state,
    extras: {
      vesper: state.vesper,
      white: state.white,
      dmgStack: state.dmgStack,
      blue3: state.blue3,
      blue8: state.blue8,
      reaperValue: state.reaperValue,
      spearValue: state.spearValue
    }
  });

  return {
    ...state,
    ...result
  };
};
function calculateMultiplier(params={}) {
  const { baseAttack,
    atkType,
    pen,
    crit,
    dmg,
    sizeEnh,
    elemEnh,
    race,
    attr,
    weapon,
    tSize,
    wElem,
    tAttr,
    tRace,
    tDefKey,
    extras = {}
  } = params;

  
  const EXTRA_LABELS = {
    vesper: 'Vesper',
    blue3: 'BlueGroup3',
    white: 'White',
    dmgStack: 'Final DMG Bonus',
    reaperValue: 'Reaper',
    blue8: 'BlueGroup8',
    spearValue: 'Spear'
  };


  const {
    def,
    dmgred
  } = getTargetDefenseData(tDefKey);

  // Calculate attack factor (PEN or CRIT mode)
  let atkF = 0;
  if (atkType === 'crit') {
    atkF = (crit || 0) / 100;
  } else if (atkType === 'pen') {
    const rawPen = (pen || 0) - (def || 0);
    if (rawPen > 0) {
      atkF = (rawPen >= 150 ? (rawPen * 2 - 150) : rawPen) / 100;
    }
  }

  const effDmgVal = dmg - dmgred;
  const sizeMod = getWeaponSizeModifier(weapon, tSize);
  const elemCtr = getElementCounter(wElem, tAttr);

  // Base multiplier calculation
  const baseMult = (baseAttack || 1) *
    (1 + atkF) *
    (1 + effDmgVal / 100) *
    (sizeMod + sizeEnh / 100) *
    (elemCtr + elemEnh / 100) *
    (1 + (tAttr ? attr / 100 : 0)) *
    (1 + (tRace ? race / 100 : 0));

  // Process extra modifiers (two separate groups)
  const processExtras = (keys, type) => {
    const items = [];
    const rawValues = [];

    keys.forEach(key => {
      const value = extras[key] || 0;
      if (value > 0) {
        const normalized = value / 100;
        items.push({
          key: EXTRA_LABELS[key],
          type,
          value: normalized
        });
        rawValues.push(normalized);
      }
    });

    const sum = rawValues.reduce((acc, val) => acc + val, 0);
    return {
      items,
      sum,
      factor: 1 + sum
    };
  };

  const extra1 = processExtras(['vesper', 'blue3', 'white', 'dmgStack', 'reaperValue'], 'extra1');
  const extra2 = processExtras(['blue8', 'spearValue'], 'extra2');
  const mult = baseMult * extra1.factor * extra2.factor; 
  // ===== COMPARISON CALCULATIONS =====
  const spearVal = (extras.spearValue || 0) / 100;
  const reaperVal = (extras.reaperValue || 0) / 100;

  const extra1FactorNoReaper = 1 + (extra1.sum - reaperVal);
  const extra2FactorNoSpear = 1 + (extra2.sum - spearVal);

  const multNoSpear = baseMult * extra1.factor * extra2FactorNoSpear;
  const multNoReaper = baseMult * extra1FactorNoReaper * extra2.factor;
  const multNoReaperSpear = baseMult * extra1FactorNoReaper * extra2FactorNoSpear;

  const pctSpear = multNoSpear > 0 ? ((mult - multNoSpear) / multNoSpear * 100) : 0;
  const pctReaper = multNoReaper > 0 ? ((mult - multNoReaper) / multNoReaper * 100) : 0;
  const pctReaperSpear = multNoReaperSpear > 0 ? ((mult - multNoReaperSpear) / multNoReaperSpear * 100) : 0;
  // ===== END COMPARISON CALCULATIONS =====

  // Build result groups for breakdown
  const resultGroups = [...extra1.items];
  extra1.sum > 0 && resultGroups.push({
    type: 'extra1',
    sum: extra1.sum,
    factor: extra1.factor
  });
  resultGroups.push(...extra2.items);
  extra2.sum > 0 && resultGroups.push({
    type: 'extra2',
    sum: extra2.sum,
    factor: extra2.factor
  });

  const isPenMode = atkType === 'pen';
  const includeRace = !!(tRace && race > 0);
  const includeAttr = !!(tAttr && attr > 0);
  const includeExtra = extra1.sum > 0;
  const includeExtraTwo = extra2.sum > 0;

  // Build factor list (order matches calculation flow)
  const factorList = [{
      key: 'baseAtk',
      label: 'Attack',
      val: baseAttack,
      mult: baseAttack || 1
    },
    {
      key: 'main',
      label: isPenMode ? 'Type (PEN)' : 'Type (CRIT)',
      val: isPenMode ? pen : crit,
      mult: 1 + atkF
    },
    {
      key: 'dmg',
      label: 'Final P/M DMG BNS',
      val: dmg,
      mult: 1 + effDmgVal / 100
    },
    {
      key: 'elem',
      label: 'Element',
      val: elemEnh,
      mult: elemCtr + elemEnh / 100,
      extra: `counter ${elemCtr}`
    },
    {
      key: 'size',
      label: 'Size',
      val: sizeEnh,
      mult: sizeMod + sizeEnh / 100,
      extra: `mod ${sizeMod}`
    },
    {
      key: 'race',
      label: 'Race',
      val: race,
      mult: 1 + race / 100,
      show: includeRace
    },
    {
      key: 'attr',
      label: 'Attribute',
      val: attr,
      mult: 1 + attr / 100,
      show: includeAttr
    },
    {
      key: 'extra',
      label: 'Extra#1',
      val: extra1.sum,
      mult: extra1.factor,
      show: includeExtra
    },
    {
      key: 'extraTwo',
      label: 'Extra#2',
      val: extra2.sum,
      mult: extra2.factor,
      show: includeExtraTwo
    },
    {
      key: 'contribution',
      label: 'Flash Contribution',
      show: pctSpear > 0 || pctReaper > 0
    }
  ];

  return {
    mult,
    pctSpear,
    pctReaper,
    pctReaperSpear,
    def,
    dmgred,
    effDmgVal,
    atkF,
    sizeModifier: sizeMod,
    elementCounter: elemCtr,
    breakdownData: {
      factorList,
      isPenMode,
      includeRace,
      includeAttr,
      includeExtra,
      includeExtraTwo
    },
    parts: {
      baseMult,
      extraGroups: resultGroups,
      extra1Factor: extra1.factor,
      extra2Factor: extra2.factor,
      extra1Sum: extra1.sum,
      extra2Sum: extra2.sum
    }
  };
};
const processMainCalculation = (() => {
  let timeoutId = null;
  let calculationRAF = null;
  let isProcessing = false;
  let executionId = 0;

  const resetUI = () => {
    DOM_ELEMENTS.submit.disabled = false;
    DOM_ELEMENTS.submit.textContent = "Calculate";
  };

  const setCalculatingUI = () => {
    DOM_ELEMENTS.submit.disabled = true;
    DOM_ELEMENTS.submit.textContent = "Calculating...";
  };

  const cleanup = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
    if (calculationRAF !== null) {
      cancelAnimationFrame(calculationRAF);
      calculationRAF = null;
    }
  };

  const enableResultButtons = () => {
    [DOM_ELEMENTS.testReaper, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.resetRek, DOM_ELEMENTS.resetAll]
    .forEach(btn => {
      if (btn) btn.disabled = false;
    });
  };

  const performCalculation = (calculationState) => {
    AppState.set('isResultShown', true);
    lockAllInputs();
    bindInputLockGuard();
    renderMultiplierBreakdown(calculationState);
    generateRecommendationTable(calculationState);
    enableResultButtons();
  };

  const handleCalculationError = (error) => {
    console.error('Calculation error:', error);
    resetUI();

    if (typeof showSnackbar === 'function') {
      showSnackbar('Calculation failed. Please check your inputs.');
    }
  };

  return () => {
    if (isProcessing) return;

    cleanup();

    if (!validateRequiredFields()) {
      resetUI();
      return;
    }

    isProcessing = true;
    executionId++;
    const currentId = executionId;

    setCalculatingUI();

    timeoutId = setTimeout(() => {
      timeoutId = null;

      if (currentId !== executionId) return;

      calculationRAF = requestAnimationFrame(() => {
        calculationRAF = null;

        if (currentId !== executionId) return;

        try {
          const calculationState = getCurrentCalculationState();

          if (!validateStatsVsTarget(calculationState)) {
            resetUI();
            return;
          }

          performCalculation(calculationState);

          DOM_ELEMENTS.submit.disabled = true;
          DOM_ELEMENTS.submit.textContent = "Calculate";

        } catch (error) {
          handleCalculationError(error);
        } finally {
          if (currentId === executionId) {
            isProcessing = false;
          }
        }
      });
    }, 300);
  };
})();

// ======== BREAKDOWN ========
const NumberFormatter = {
  format(n, showFullPrecision) {
    const num = Number(n) || 0;
    const absNum = Math.abs(num);
    const isInteger = num % 1 === 0;
    
    if (showFullPrecision) {
      if (absNum >= 99999 || isInteger) return isInteger ? num.toString() : Math.floor(num).toString();
      
      const str = num.toFixed(6).replace(/(\.\d*?)0+$/, '$1');
      const parts = str.split('.');
      
      return str.endsWith('.') || (parts[1]?.length === 1) ? num.toFixed(2) : str;
    }
    
    if (absNum > 99999) {
      const divisor = absNum >= 1e6 ? 1e6 : 1e3;
      return `${Math.floor(num / divisor)}${divisor === 1e6 ? 'M' : 'K'}`;
    }
    
    return isInteger ? num.toString() : num.toFixed(2);
  }
};
const PrecisionToggle = {
  create(resultContainer, onToggleCallback) {
    const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";
    
    const btn = document.createElement('button');
    btn.className = 'toggle-precision job-sim';
    btn.type = 'button';
    btn.textContent = showFullPrecision ? "hide" : "shown";
    
    const listenerId = EventManager.add(btn, 'click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (!resultContainer?.dataset) return;
      
      const newState = resultContainer.dataset.showFullPrecision === "1" ? "0" : "1";
      const isPrecise = newState === "1";
      
      resultContainer.dataset.showFullPrecision = newState;
      btn.textContent = isPrecise ? "hide" : "shown";
      
      onToggleCallback(isPrecise);
      
      typeof showSnackbar === 'function' &&
        showSnackbar(`${isPrecise ? "Precise" : "Rounded"} numbers displayed`);
    });
    
    btn.dataset.listenerId = listenerId;
    return btn;
  },
  
  refreshNumbers(resultContainer, showFullPrecision) {
    resultContainer.querySelectorAll('[data-raw-value]').forEach(el => {
      el.textContent = NumberFormatter.format(parseFloat(el.dataset.rawValue), showFullPrecision);
    });
    
    resultContainer.querySelectorAll('code[data-raw-mult]').forEach(el => {
      el.textContent = `\u00D7${NumberFormatter.format(parseFloat(el.dataset.rawMult), showFullPrecision)}`;
    });
  }
};
function renderMultiplierBreakdown(calculationState) {
  if (!AppState.get('isResultShown')) return;

  const resultContainer = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";

  // Format helpers
  const fmt = (n) => NumberFormatter.format(n, showFullPrecision);
  const fmtWithData = (n) => `<span data-raw-value="${n}">${fmt(n)}</span>`;

  // Destructure state
  const {
    mult,
    def,
    dmgred,
    pen,
    crit,
    dmg,
    wElem,
    tAttr,
    tSize,
    weapon,
    atkType,
    tRace,
    vesper,
    blue3,
    blue8,
    white,
    tDefKey,
    elementCounter,
    sizeModifier,
    parts = {},
    breakdownData = {}
  } = calculationState;

  const {
    extraGroups = [], extra1Factor = 1, extra2Factor = 1
  } = parts;
  const {
    factorList = [], isPenMode = false
  } = breakdownData;

  const LABELS = {
    'Vesper': 'Vesper SET',
    'BlueGroup3': 'Blue SET (Ferocity)',
    'BlueGroup8': 'Blue SET',
    'White': 'White SET (110*3)',
    'Reaper': 'Reaper Scythe',
    'Spear': 'Divinity#1 Flash: Spear of Eternity'
  };

  // Group extras by type
  const extras = {
    extra1: {
      items: [],
      factor: extra1Factor
    },
    extra2: {
      items: [],
      factor: extra2Factor
    }
  };

  extraGroups.forEach(group => {
    const type = group.type;
    if ('sum' in group && 'factor' in group) {
      extras[type].factor = group.factor;
    } else if ('key' in group && 'value' in group) {
      extras[type].items.push(group);
    }
  });

  // Check if line is a note
  const isNote = (text) =>
    text.includes('Tools assume') || text.includes('uptime') ||
    text.includes('Elements') || text.includes('This bonus');

  // Build HTML list items
  const buildLines = (lines) =>
    lines.map(line => `<li${isNote(line) ? ' class="note"' : ''}>${line}</li>`).join('');

  // Build extra bonus section (Extra#1 or Extra#2)
  function buildExtraSection(extraType, title, state) {
    const extraData = extras[extraType];
    const lines = [];
    const values = [];

    extraData.items.forEach(item => {
      const label = LABELS[item.key] || item.key;
      const valPercent = fmtWithData(item.value * 100);

      if (item.key === 'Reaper') {
        lines.push(
          `${label}: ${state.wElem} vs ${state.tAttr || 'Neutral'} <button type="button" id="reaperTips" class="tooltip-button"></button>`,
          `${valPercent} / 100`
        );
      } else if (item.key === 'Spear') {
        lines.push(
          `${LABELS[item.key]} <button type="button" id="spearTips" class="tooltip-button"></button>`,
          `${valPercent} / 100`
        );
      } else {
        let display = `${label}: ${valPercent}`;

        switch (item.key) {
          case 'Vesper':
            if (state.vesper) display = `${label}: Tier ${(state.vesper-8)/8}`;
            break;
          case 'BlueGroup3':
            if (state.blue3) display = `${label}: Level ${4*state.blue3+10}*3`;
            break;
          case 'White':
            if (state.white) display = `${label}: Tier ${(state.white-30)/6}`;
            break;
          case 'BlueGroup8':
            if (state.blue8) display = `${label}: ${state.blue8}%`;
            break;
        }

        lines.push(display, `${valPercent} / 100`);
      }
      values.push(fmtWithData(item.value));
    });

    const valuesDisplay = values.join(' + ');
    lines.push(`1 + ${valuesDisplay} \u2192 <code data-raw-mult="${extraData.factor}">\u00D7${fmt(extraData.factor)}</code>`);

    return {
      title,
      lines
    };
  }

  // Build individual factor breakdown
  function buildFactor(factor, state) {
    if (factor.show === false && factor.key !== 'contribution') {
      return {
        html: `<li>${factor.label}: \u00D71.00 (no stat)</li>`,
        mult: `1.00 (no ${factor.label.toLowerCase()})`
      };
    }

    let factorData = null;

    switch (factor.key) {
      case 'baseAtk':
        return {
          html: '', mult: fmt(factor.mult)
        };
      case 'main':
        if (!state.isPenMode) {
          factorData = {
            title: `Attack Type: CRIT vs ${state.tDefKey}`,
            lines: [
              `Crit DMG: ${fmtWithData(state.crit)}`,
              `1.00 + ( ${fmtWithData(state.crit)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
            ]
          };
        } else {
          const lines = [
            `Raw PEN + Final PEN: ${fmtWithData(state.pen)}`,
            `Target DEF: ${fmtWithData(state.def)}`
          ];

          const rawBasePen = state.pen - state.def;
          if (rawBasePen >= 150) {
            lines.push(
              `1.00 + ((( ${fmtWithData(state.pen)} - ${fmtWithData(state.def)} ) \u00D7 2 ) - 150 ) / 100`,
              `1.00 + ( ${fmtWithData((rawBasePen * 2) - 150)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
            );
          } else {
            lines.push(`1.00 + (( ${fmtWithData(state.pen)} - ${fmtWithData(state.def)} ) / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`);
          }

          factorData = {
            title: `Attack Type: PEN vs ${state.tDefKey}`,
            lines
          };
        }
        break;

      case 'dmg':
        factorData = {
          title: 'Final P/M Damage Bonus',
          lines: [
            `P/M BO: ${fmtWithData(state.dmg)}`,
            `Target Reduction: ${fmtWithData(state.dmgred)}`,
            `1.00 + (( ${fmtWithData(state.dmg)} - ${fmtWithData(state.dmgred)} ) / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'elem':
        factorData = {
          title: `Element: ${state.wElem} vs ${state.tAttr || "Neutral<button type='button' id='elemCtrTips' class='tooltip-button'></button>"}`,
          lines: [
            `Counter: ${fmtWithData(state.elementCounter)}`,
            `${state.wElem} Enhance: ${fmtWithData(factor.val)}`,
            `${fmtWithData(state.elementCounter)} + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'size':
        factorData = {
          title: `Size: ${state.weapon} vs ${state.tSize}`,
          lines: [
            `Modifier: ${fmtWithData(state.sizeModifier)}`,
            `${state.tSize} Enhance: ${fmtWithData(factor.val)}`,
            `${fmtWithData(state.sizeModifier)} + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'race':
        factorData = {
          title: `Race: ${state.tRace}`,
          lines: [
            `DMG to ${state.tRace}: ${fmtWithData(factor.val)}`,
            `1.00 + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'attr':
        factorData = {
          title: `Attribute: ${state.tAttr}`,
          lines: [
            `DMG to ${state.tAttr} Attribute: ${fmtWithData(factor.val)}`,
            `1.00 + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'extra':
        factorData = buildExtraSection('extra1', 'Extra#1: Final DMG Bonus', state);
        break;

      case 'extraTwo':
        factorData = buildExtraSection('extra2', 'Extra#2: Bonus DMG to MVP/MINI', state);
        break;

      case 'contribution':
        const hasSpear = state.pctSpear > 0;
        const hasReaper = state.pctReaper > 0;

        if (!hasSpear && !hasReaper) {
          return {
            html: '',
            mult: ''
          };
        }

        const formatBoost = (value) => `<code>\u2248${Math.trunc(value/2)}%</code>`;
        const createLine = (label, value) => `${label}: ${formatBoost(value)}`;

        const lines = [];
        if (hasSpear && hasReaper) {
          lines.push(
            createLine('Spear Flash', state.pctSpear) + ' damage boost.',
            createLine('Reaper Flash', state.pctReaper) + ' damage boost.',
            `Both flashes gives you ${formatBoost(state.pctReaperSpear)} total damage increase.`
          );
        } else if (hasSpear) {
          lines.push(`Spear Flash boost: ${formatBoost(state.pctSpear)}`);
        } else {
          lines.push(`Reaper Flash boost: ${formatBoost(state.pctReaper)}`);
        }

        factorData = {
          title: "How Much Flash Boosts Your Damage<button type='button' id='flashTips' class='tooltip-button'></button>",
          lines
        };
        break;

      default:
        return {
          html: `<li>${factor.label}: ${fmtWithData(factor.val)} \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code></li>`,
            mult: fmt(factor.mult)
        };
    }

    const html = `<li>${factorData.title}<ul>${buildLines(factorData.lines)}</ul></li>`;
    return {
      html,
      mult: fmt(factor.mult)
    };
  }

  // Process all factors
  const factorHTML = [];
  const multiplierParts = [];
  const stateContext = {
    ...calculationState,
    extras,
    LABELS,
    isPenMode
  };

  factorList.forEach((factor, i) => {
    const result = buildFactor(factor, stateContext);

    factorHTML.push(result.html);
    if (factor.key === 'contribution') return;

    multiplierParts.push((i === 0 ? '' : '\u00D7 ') + result.mult);
  });

  // Prepare UI components
  const targetInfo = [tSize, tRace, tAttr].filter(Boolean).join(" + ");
  const bq1Text = `By default, every factor starts at \u00D71.00<button type='button' id='breakdownTips' class='tooltip-button'></button>\nNumbers`;
  const bq1Suffix = document.createTextNode(" how it changes with your stats.");

  const precisionBtn = PrecisionToggle.create(
    resultContainer,
    (showFullPrecision) => {
      PrecisionToggle.refreshNumbers(resultContainer, showFullPrecision);
    }
  );

  const swapSelect = dropdownManager.createSwapSelect(calculationState, isPenMode);

  // Cleanup old event listeners
  resultContainer.querySelectorAll('[data-listener-id]').forEach(el => {
    const id = el.dataset.listenerId;
    id && EventManager.remove(parseInt(id));
  });

  // Render HTML
  resultContainer.innerHTML = `
    <div class="multiplier-breakdown" id="multiplier-breakdown">
      <blockquote class="noted">${bq1Text.replace(/\n/g, '<br>')}</blockquote>
      <ul class="factor-breakdown">${factorHTML.join('')}</ul>
      <hr class="separ">
      <div class="breakdown-swap-wrapper" id="swap-wrapper"></div>
      <p class="sum-head">Your base multiplier to <i>${targetInfo} (${tDefKey})</i></p>
      <div class="last-calc">${multiplierParts.join(" ")}<br>\u2248<code data-raw-mult="${mult}">\u00D7${fmt(mult)}</code><button type="button" id="attackTips" class="tooltip-button"></button></div>
      <blockquote class="noted">Only base multipliers! Real output depends on class, skills, buffs (vesper, blue, or white stack), and more. More accurate? Just use <a class="job-sim" target="_blank" href="//discord.com/channels/784407151342256148/909016309218541568/1407521807459811328">job sim!</a></blockquote>
    </div>`;

  // Attach components to DOM
  const bq1 = resultContainer.querySelector('.noted');
  bq1.appendChild(precisionBtn);
  bq1.appendChild(bq1Suffix);
  resultContainer.querySelector('#swap-wrapper').appendChild(swapSelect);
};

// ========== RECOMMENDATION ==========
const RandomGenerator = (() => {
  const SIZE = 500;
  let cache = new Float64Array(SIZE),
    idx = 0;
  const refill = () => {
    for (let i = 0; i < SIZE; i++) cache[i] = Math.random();
    idx = 0;
  };
  refill();
  return {
    get: () => (idx >= SIZE && refill(), cache[idx++]),
    reset: refill
  };
})();
const RECOMMENDATION_CONFIG = {
  randomMode: 'clamp',
  maxAttempts: 500,
  centerScale: 0.25,
  jitter: 0.12,
  jitterStep: 0.025,
  jitterStepEvery: 35,
  jitterMax: 0.50,
  clampMaxFraction: 3.5,
  clampMaxAbsolute: 0.20,
  upDownThreshold: 3,
  raceAttrCap: 310,
  raceAttrSoloCap: 250,
  raceAttrTol: 6,
  smallThreshold: 115,
  smallMin: 85,
  smallExp: 0.75,
  ratioMin: 0.32,
  ratioMax: 0.64,
  ratioNoise: 0.12,
  bias: {
    main: 1.0,
    dmg: 0.95,
    elem: 0.90,
    size: 0.90,
    race: 0.72,
    attr: 0.72
  },
  cats: [{
      label: '6-12%',
      min: 1.06,
      max: 1.12
    },
    {
      label: '18-24%',
      min: 1.18,
      max: 1.24
    },
    {
      label: '32-48%',
      min: 1.32,
      max: 1.48
    },
    {
      label: '64-128%',
      min: 1.64,
      max: 2.28
    }
  ],
  forSmallCats: [{
      label: '84-168%',
      min: 1.84,
      max: 2.68
    },
    {
      label: '180-270%',
      min: 2.80,
      max: 3.70
    },
    {
      label: '320-480%',
      min: 4.32,
      max: 5.80
    },
    {
      label: '510-720%',
      min: 6.10,
      max: 8.20
    }
  ]
}
const calculateRecommendationWeights = (params) => {
  if (!AppState.get('isResultShown')) return;

  const {
    includeRace,
    includeAttr,
    baseMain,
    baseDmg,
    baseElem,
    baseSize,
    baseRace,
    baseAttr
  } = params;
  const {
    bias,
    smallExp,
    smallMin,
    raceAttrCap
  } = RECOMMENDATION_CONFIG;

  // Calculate weighted values for core stats
  const weights = [
    baseMain * bias.main,
    baseDmg * bias.dmg,
    baseElem * bias.elem,
    baseSize * bias.size
  ];

  const maxWeight = Math.max(...weights, 1);
  const coreSum = Math.max(weights.reduce((sum, w) => sum + w / maxWeight, 0), 0.0001);

  // Allocate weight share between core and additional stats
  const hasAdditional = includeRace || includeAttr;
  const coreShare = hasAdditional ? 0.75 : 1.0;

  const finalWeights = {
    main: (weights[0] / maxWeight / coreSum) * coreShare,
    dmg: (weights[1] / maxWeight / coreSum) * coreShare,
    elem: (weights[2] / maxWeight / coreSum) * coreShare,
    size: (weights[3] / maxWeight / coreSum) * coreShare,
    race: 0,
    attr: 0
  };

  // If no additional stats, normalize and return
  if (!hasAdditional) {
    const totalSum = Object.values(finalWeights).reduce((a, b) => a + b, 0);
    Object.keys(finalWeights).forEach(k => finalWeights[k] /= totalSum);
    return finalWeights;
  }

  // Handle race/attr weight distribution - optimized
  const additionalShare = 1 - coreShare;
  const effectiveRace = includeRace ? Math.max(Math.pow(baseRace, smallExp), smallMin) : 0;
  const effectiveAttr = includeAttr ? Math.max(Math.pow(baseAttr, smallExp), smallMin) : 0;
  const raceAvailable = includeRace && effectiveRace > 0 && effectiveRace < raceAttrCap;
  const attrAvailable = includeAttr && effectiveAttr > 0 && effectiveAttr < raceAttrCap;

  if (raceAvailable && attrAvailable) {
    const combinedSum = effectiveRace + effectiveAttr;
    finalWeights.race = (effectiveRace / combinedSum) * additionalShare;
    finalWeights.attr = (effectiveAttr / combinedSum) * additionalShare;
  } else if (raceAvailable) {
    finalWeights.race = additionalShare;
  } else if (attrAvailable) {
    finalWeights.attr = additionalShare;
  } else {
    // Redistribute to core stats if no additional stats qualify
    const redistribution = additionalShare * 0.25;
    ['main', 'dmg', 'elem', 'size'].forEach(k => finalWeights[k] += redistribution);
  }

  // Final normalization
  const totalSum = Object.values(finalWeights).reduce((a, b) => a + b, 0);
  Object.keys(finalWeights).forEach(k => finalWeights[k] /= totalSum);

  return finalWeights;
};
function generateRecommendationTable(gameState) {
  if (!AppState.get('isResultShown')) return;

  // Random value generator with jitter
  const generateRandomValue = (baseValue, jitter = RECOMMENDATION_CONFIG.jitter) => {
    const {
      randomMode,
      clampMaxFraction,
      clampMaxAbsolute
    } = RECOMMENDATION_CONFIG;

    if (randomMode === 'clamp') {
      const delta = (RandomGenerator.get() * 2 - 1) * jitter;
      const maxClamp = Math.min(clampMaxFraction * jitter, clampMaxAbsolute);
      const clampedDelta = Math.max(Math.min(delta, maxClamp), -maxClamp);
      return Math.max(0, baseValue * (1 + clampedDelta));
    }

    if (randomMode === 'normal') {
      let u1 = 0,
        u2 = 0;
      while (u1 === 0) u1 = RandomGenerator.get();
      while (u2 === 0) u2 = RandomGenerator.get();
      const normalValue = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return Math.max(0, baseValue * (1 + normalValue * jitter * 0.5));
    }

    return Math.max(0, baseValue * (1 + (RandomGenerator.get() * 2 - 1) * jitter));
  };

  // Adjust small combined race/attr values
  const applySmallValueAdjustment = (value, raceValue, attrValue) => {
    const {
      smallThreshold,
      smallExp,
      smallMin
    } = RECOMMENDATION_CONFIG;
    const combinedTotal = raceValue + attrValue;
    return (combinedTotal > 0 && combinedTotal < smallThreshold) ?
      Math.max(Math.pow(value, smallExp), smallMin) :
      value;
  };

  // Get max allowed value with tolerance
  const getMaxAllowedValue = (userValue, capLimit, tolerance, isSmall) =>
    userValue >= capLimit ? (isSmall ? capLimit + tolerance : userValue + tolerance) : capLimit;

  // Avoid hitting exact cap limit
  const avoidCapLimit = (value, capLimit) =>
    value < capLimit ? value : capLimit - (capLimit * (0.01 + RandomGenerator.get() * 0.02));

  // Avoid round multiples of 10
  const avoidRoundTen = (value) => {
    const rounded = Math.round(value);
    return rounded % 10 === 0 ? rounded + 1 : rounded;
  };

  // Get cell CSS class based on comparison
  const getCellClass = (currentValue, baseValue) => {
    const diff = Math.round(+currentValue || 0) - Math.round(+baseValue || 0);
    const threshold = RECOMMENDATION_CONFIG.upDownThreshold;
    return diff >= threshold ? 'up' : diff <= -threshold ? 'down' : 'neutral';
  };

  const isPenetrationMode = gameState.atkType === 'pen';
  const tRace = gameState.tRace,
    tAttr = gameState.tAttr;
  const raceVal = +gameState.race || 0,
    attrVal = +gameState.attr || 0;
  const shouldIncludeRace = !!tRace && raceVal > 0;
  const shouldIncludeAttr = !!tAttr && attrVal > 0;
  const originalMultiplier = +gameState.mult || 1;
  const baseAttackValue = +gameState.baseAttack || 1;

  // User's current stats - cache all conversions
  const userStats = {
    main: isPenetrationMode ? (+gameState.pen || 0) : (+gameState.crit || 0),
    dmg: +gameState.dmg || 0,
    size: +gameState.sizeEnh || 0,
    elem: +gameState.elemEnh || 0,
    attr: shouldIncludeAttr ? attrVal : 0,
    race: shouldIncludeRace ? raceVal : 0
  };

  // Calculate stat weights for recommendation algorithm
  const statWeights = calculateRecommendationWeights({
    includeRace: shouldIncludeRace,
    includeAttr: shouldIncludeAttr,
    baseMain: userStats.main,
    baseDmg: userStats.dmg,
    baseElem: userStats.elem,
    baseSize: userStats.size,
    baseRace: userStats.race,
    baseAttr: userStats.attr
  });

  const {
    centerScale,
    raceAttrCap,
    smallThreshold,
    raceAttrSoloCap,
    raceAttrTol,
    ratioMin,
    ratioMax,
    maxAttempts,
    jitter,
    jitterStep,
    jitterStepEvery,
    jitterMax
  } = RECOMMENDATION_CONFIG;

  // Center values around weighted means
  const centeredValues = {
    main: userStats.main * (1 + statWeights.main * centerScale),
    dmg: userStats.dmg * (1 + statWeights.dmg * centerScale),
    elem: userStats.elem * (1 + statWeights.elem * centerScale),
    size: userStats.size * (1 + statWeights.size * centerScale)
  };

  // Adjust race/attr for small combined totals - consolidated
  const raceAttrSum = userStats.race + userStats.attr;
  const adjustedRace = shouldIncludeRace ? applySmallValueAdjustment(userStats.race, userStats.race, userStats.attr) : 0;
  const adjustedAttr = shouldIncludeAttr ? applySmallValueAdjustment(userStats.attr, userStats.race, userStats.attr) : 0;

  const raceAttrValues = {
    race: shouldIncludeRace ? Math.min(adjustedRace * (1 + statWeights.race * centerScale), raceAttrCap) : 0,
    attr: shouldIncludeAttr ? Math.min(adjustedAttr * (1 + statWeights.attr * centerScale), raceAttrCap) : 0,
    adjustedRace,
    adjustedAttr
  };

  // Base extras (equipment bonuses) - cache object
  const baseExtras = {
    blue3: +gameState.blue3 || 0,
    blue8: +gameState.blue8 || 0,
    vesper: +gameState.vesper || 0,
    white: +gameState.white || 0,
    dmgStack: +gameState.dmgStack || 0,
    reaperValue: +gameState.reaperValue || 0,
    spearValue: +gameState.spearValue || 0
  };

  // Select appropriate categories based on race/attr totals
  const hasSmallCombined = shouldIncludeRace && shouldIncludeAttr && raceAttrSum > 0 && raceAttrSum < smallThreshold;
  const categories = hasSmallCombined ? RECOMMENDATION_CONFIG.forSmallCats : RECOMMENDATION_CONFIG.cats;

  // Build column headers (follows DOM field order) - optimized with conditional push
  const mainStatLabel = isPenetrationMode ? 'PEN' : 'CRIT';
  const columnHeaders = ['STAT', mainStatLabel, 'P/M BO', 'Element', 'Size'];
  shouldIncludeRace && columnHeaders.push('Race');
  shouldIncludeAttr && columnHeaders.push('Attribute');
  columnHeaders.push('Multiplier', '\u2206');

  const tablesHTML = [];
  const headerRow = columnHeaders.map(h => `<th>${h}</th>`).join('');

  // Pre-calculate common values for race/attr generation
  const userTotal = userStats.race + userStats.attr;
  const boostedTotal = raceAttrValues.adjustedRace + raceAttrValues.adjustedAttr;
  const isSmallTotal = userTotal > 0 && userTotal < smallThreshold;
  const maxTotal = shouldIncludeRace && shouldIncludeAttr ? getMaxAllowedValue(userTotal, raceAttrCap, raceAttrTol, isSmallTotal) : 0;

  // Cache single stat values
  const userSingle = shouldIncludeRace ? userStats.race : userStats.attr;
  const boostedSingle = shouldIncludeRace ? raceAttrValues.adjustedRace : raceAttrValues.adjustedAttr;
  const isSmallSingle = userSingle > 0 && userSingle < smallThreshold;
  const maxSingle = (shouldIncludeRace || shouldIncludeAttr) && !(shouldIncludeRace && shouldIncludeAttr) ?
    getMaxAllowedValue(userSingle, raceAttrSoloCap, raceAttrTol, isSmallSingle) :
    0;

  // Cache gameState properties used in calculateMultiplier
  const calcParams = {
    baseAttack: baseAttackValue,
    atkType: isPenetrationMode ? 'pen' : 'crit',
    weapon: gameState.weapon || '',
    tSize: gameState.tSize || '',
    wElem: gameState.wElem || '',
    tAttr: tAttr || '',
    tRace: tRace || '',
    tDefKey: gameState.tDefKey || '',
    extras: baseExtras
  };

  // Generate recommendation tables for each category
  for (let catIdx = 0, catLen = categories.length; catIdx < catLen; catIdx++) {
    const category = categories[catIdx];
    const uniqueKeys = new Set();
    const uniqueDeltas = new Set();
    const uniqueComposites = new Set();
    const acceptedRows = [];
    let attempts = 0,
      currentJitter = jitter;

    // Generate unique recommendations with adaptive jitter
    while (acceptedRows.length < 5 && attempts < maxAttempts) {
      attempts++;

      // Generate random stat values - reuse object
      const statValues = {
        pen: +gameState.pen || 0,
        crit: +gameState.crit || 0,
        dmg: generateRandomValue(centeredValues.dmg, currentJitter),
        elem: generateRandomValue(centeredValues.elem, currentJitter),
        size: generateRandomValue(centeredValues.size, currentJitter)
      };

      statValues[isPenetrationMode ? 'pen' : 'crit'] = generateRandomValue(centeredValues.main, currentJitter);

      let raceValue = 0,
        attrValue = 0;

      // Handle race/attr allocation - optimized branching
      if (shouldIncludeAttr && shouldIncludeRace) {
        const randomTotal = avoidCapLimit(Math.min(generateRandomValue(boostedTotal, currentJitter), maxTotal), maxTotal);
        const ratio = ratioMin + RandomGenerator.get() * (ratioMax - ratioMin);
        raceValue = randomTotal * ratio;
        attrValue = randomTotal * (1 - ratio);

        // Scale down if exceeds max total
        const actualSum = raceValue + attrValue;
        if (actualSum > maxTotal) {
          const scale = avoidCapLimit(maxTotal, maxTotal) / actualSum;
          raceValue *= scale;
          attrValue *= scale;
        }
      } else if (shouldIncludeRace || shouldIncludeAttr) {
        const generatedValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingle, currentJitter), maxSingle), maxSingle);
        shouldIncludeRace ? (raceValue = generatedValue) : (attrValue = generatedValue);
      }

      // Calculate new multiplier with generated stats
      const {
        mult: calculatedMultiplier
      } = calculateMultiplier({
        ...calcParams,
        pen: +statValues.pen || 0,
        crit: +statValues.crit || 0,
        dmg: +statValues.dmg || 0,
        sizeEnh: +statValues.size || 0,
        elemEnh: +statValues.elem || 0,
        race: +raceValue || 0,
        attr: +attrValue || 0
      });

      // Combined filters with early exit
      const ratio = calculatedMultiplier / originalMultiplier;
      if (calculatedMultiplier <= originalMultiplier || ratio < category.min || ratio > category.max) continue;

      // Round and avoid multiples of 10
      const mainVal = avoidRoundTen(isPenetrationMode ? statValues.pen : statValues.crit);
      const dmgVal = avoidRoundTen(statValues.dmg);
      const elemVal = avoidRoundTen(statValues.elem);
      const sizeVal = avoidRoundTen(statValues.size);
      const rVal = shouldIncludeRace ? avoidRoundTen(raceValue) : null;
      const aVal = shouldIncludeAttr ? avoidRoundTen(attrValue) : null;

      // Uniqueness checks - optimized string building
      const rStr = rVal || '-',
        aStr = aVal || '-';
      const rowKey = `${mainVal}|${dmgVal}|${elemVal}|${sizeVal}|${rStr}|${aStr}`;
      const compositeKey = `${mainVal}|${dmgVal}|${elemVal}|${sizeVal}|${rVal}|${aVal}`;

      if (uniqueKeys.has(rowKey) || uniqueComposites.has(compositeKey)) continue;

      const deltaPercent = ((calculatedMultiplier - originalMultiplier) / originalMultiplier) * 100;
      const roundedDelta = Number(deltaPercent.toFixed(1));
      if (uniqueDeltas.has(roundedDelta)) continue;

      // Filter: at least one stat must be lower - optimized conditional
      if (mainVal > userStats.main && dmgVal > userStats.dmg && elemVal > userStats.elem && sizeVal > userStats.size &&
        (!shouldIncludeRace || rVal > userStats.race) && (!shouldIncludeAttr || aVal > userStats.attr)) continue;

      // Accept this recommendation
      uniqueKeys.add(rowKey);
      uniqueDeltas.add(roundedDelta);
      uniqueComposites.add(compositeKey);

      acceptedRows.push({
        main: mainVal,
        dmg: dmgVal,
        elem: elemVal,
        size: sizeVal,
        attr: aVal,
        race: rVal,
        newMultiplier: calculatedMultiplier,
        deltaPercent
      });

      // Increase jitter adaptively if struggling to find recommendations
      if (acceptedRows.length < 5 && attempts % jitterStepEvery === 0) {
        currentJitter = Math.min(currentJitter + jitterStep, jitterMax);
      }
    }

    if (acceptedRows.length === 0) continue;

    // Sort by improvement percentage, then multiplier, then main stat
    acceptedRows.sort((a, b) =>
      b.deltaPercent - a.deltaPercent || b.newMultiplier - a.newMultiplier || b.main - a.main
    );

    // Build table rows - optimized array building
    const tableRows = acceptedRows.map((row, i) => {
      const cells = [
        `<td class="build">BUILD#${i + 1}</td>`,
        `<td><span class="${getCellClass(row.main, userStats.main)}">${row.main}</span></td>`,
        `<td><span class="${getCellClass(row.dmg, userStats.dmg)}">${row.dmg}</span></td>`,
        `<td><span class="${getCellClass(row.elem, userStats.elem)}">${row.elem}</span></td>`,
        `<td><span class="${getCellClass(row.size, userStats.size)}">${row.size}</span></td>`
      ];

      shouldIncludeRace && cells.push(`<td><span class="${getCellClass(row.race, userStats.race)}">${row.race}</span></td>`);
      shouldIncludeAttr && cells.push(`<td><span class="${getCellClass(row.attr, userStats.attr)}">${row.attr}</span></td>`);

      cells.push(
        `<td class="mult">\u00D7${row.newMultiplier.toFixed(2)}</td>`,
        `<td class="delta">+${row.deltaPercent.toFixed(1)}%</td>`
      );

      return `<tr>${cells.join('')}</tr>`;
    }).join('');

    // Build "your stats" row - optimized with same pattern
    const yourStatsCells = [
      '<td class="yours-label">YOURS</td>',
      `<td><span>${userStats.main}</span></td>`,
      `<td><span>${userStats.dmg}</span></td>`,
      `<td><span>${userStats.elem}</span></td>`,
      `<td><span>${userStats.size}</span></td>`
    ];

    shouldIncludeRace && yourStatsCells.push(`<td><span>${userStats.race}</span></td>`);
    shouldIncludeAttr && yourStatsCells.push(`<td><span>${userStats.attr}</span></td>`);

    yourStatsCells.push(
      `<td class="mult current-mult">\u00D7${gameState.mult.toFixed(2)}</td>`,
      `<td id="table-help" class="delta current-delta"><button type='button' id='tableTips' class='tooltip-button'></button></td>`
    );

    const yourStatsRow = `<tr class="your-stats-values">${yourStatsCells.join('')}</tr>`;

    tablesHTML.push(
      `<div class="table-wrapper"><table class="recommend-table"><caption>Increase ${category.label}</caption><tr>${headerRow}</tr><tbody>${tableRows}${yourStatsRow}</tbody></table></div>`
    );
  }

  DOM_ELEMENTS.rec.innerHTML = tablesHTML.join('');
};
const regenerateRecommendations = () => {
  AppState.get('isResultShown') && (generateRecommendationTable(getCurrentCalculationState()), showSnackbar?.("Table Refreshed!"));
};

// ========== DROPDOWN MANAGER ==========
class DropdownManager {
  constructor() {
    this.constants = {
      formKeys: ['vesperSet', 'whiteSet', 'blueSet', 'tRace', 'tAttr', 'atkType', 'wElem', 'tSize', 'tDef', 'weapon', 'pen', 'crit'],
      mobMapping: {
        'sizeMob': 'tSize',
        'raceMob': 'tRace',
        'attributeMob': 'tAttr'
      },
      disableButtons: ['resetAll', 'resetRek', 'testSpear', 'testReaper'],
      relatedFields: {
        'tSize': 'sizeEnh',
        'tRace': 'race',
        'tAttr': 'attr'
      },
      calcFields: ['dmg', 'dmgStack', 'sizeEnh', 'race', 'attr', 'elemEnh'],
      setKeys: ['blueSet', 'vesperSet', 'whiteSet']
    };

    this.config = this.buildConfig();
    this.state = {
      selectionOrder: [],
      lockStates: new Map(),
      isSwapping: false,
      updateTimer: null
    };
    this.namespace = 'dropdown-manager';
    this.isInitialized = false;
    this.init();
  }

  buildConfig() {
    return {
      ...this.constants,
      labels: {
        static: {
          blueSetLabel: "Blue SET",
          vesperSetLabel: "Vesper SET",
          whiteSetLabel: "White SET (110*3)",
          atkTypeLabel: "Attack Type",
          weaponLabel: "Weapon",
          wElemLabel: "Weapon Element",
          tSizeLabel: "Target Size",
          tRaceLabel: "Target Race",
          tAttrLabel: "Target Attribute",
          tDefLabel: "MVP/MINI",
          penLabel: "P/M PEN %",
          critLabel: "Critical DMG Bonus %",
          elemEnhLabel: "Element Enhance %",
          sizeLabel: "DMG to Size %",
          raceLabel: "Race",
          attrLabel: "Attribute",
          dmgLabel: "Final P/M Damage Bonus %",
          dmgStackLabel: "Extra: Final Damage Stack %"
        },
        dynamic: {
          vesper: {
            "48": "BRO?!",
            "56": "REALLY?!",
            "64": "Wake UP!",
            "72": "STOP Dreaming!",
            "80": "F2P DETECTED!"
          },
          white: {
            "36": "Eh?",
            "42": "WOW",
            "48": "GG!!",
            "54": "Have a Nice Day!"
          }
        }
      },

      fields: {
        atkType: {
          type: 'dropdown',
          options: [{
            value: "pen",
            label: "P/M PEN"
          }, {
            value: "crit",
            label: "CRIT"
          }],
          placeholder: "Select Attack Type",
          onClear: ['pen', 'crit'],
          onUpdate: 'updateAttackTypeUI'
        },
        tSize: {
          type: 'dropdown',
          options: ["Small", "Medium", "Large"],
          placeholder: "Select Target Size"
        },
        tRace: {
          type: 'dropdown',
          options: () => RACE_TYPES,
          placeholder: "skip race",
          onClear: ['race']
        },
        tAttr: {
          type: 'dropdown',
          options: () => Object.keys(getElementCounter()),
          placeholder: "skip attribute",
          onClear: ['attr']
        },
        weapon: {
          type: 'dropdown',
          options: () => Object.keys(getWeaponSizeModifier()),
          placeholder: "Select Weapon Type"
        },
        wElem: {
          type: 'dropdown',
          options: () => Object.keys(getElementCounter()),
          placeholder: "Select Attribute"
        },
        tDef: {
          type: 'dropdown',
          options: () => Object.keys(getTargetDefenseData()),
          placeholder: "Select target",
          special: 'target'
        },
        vesperSet: {
          type: 'set',
          generator: 'vesper'
        },
        whiteSet: {
          type: 'set',
          generator: 'white'
        },
        blueSet: {
          type: 'set',
          generator: 'blue'
        },

        race: {
          type: 'conditional',
          dependsOn: 'tRace',
          active: (race) => ({
            label: `DMG to ${race}`,
            placeholder: `dmg to ${race.toLowerCase()} %`
          }),
          default: {
            label: "Race",
            placeholder: "select target race first"
          }
        },
        attr: {
          type: 'conditional',
          dependsOn: 'tAttr',
          active: (attr) => ({
            label: `DMG to ${attr} Attribute`,
            placeholder: `dmg to ${attr.toLowerCase()} attribute %`
          }),
          default: {
            label: "Attribute",
            placeholder: "select target attribute first"
          }
        },
        elemEnh: {
          type: 'conditional',
          dependsOn: 'wElem',
          active: (elem) => ({
            label: `${elem} Enhance %`,
            placeholder: `${elem.toLowerCase()} enhance`
          }),
          default: {
            label: "Element Enhance %",
            placeholder: "select weapon attribute first"
          }
        },
        sizeEnh: {
          type: 'conditional',
          dependsOn: 'tSize',
          active: (size) => ({
            label: `DMG to ${size} %`,
            placeholder: `dmg to ${size.toLowerCase()}`
          }),
          default: {
            label: "DMG to Size %",
            placeholder: "select target size first"
          }
        },
        dmg: {
          type: 'conditional',
          dependsOn: 'atkType',
          active: () => ({
            placeholder: "final p/m damage bonus"
          }),
          default: {
            placeholder: "select attack type first"
          }
        },
        dmgStack: {
          type: 'conditional',
          dependsOn: 'atkType',
          active: () => ({
            placeholder: "final damage bonus/stack %"
          }),
          default: {
            placeholder: "select attack type first"
          }
        }
      },

      setGenerators: {
        vesper: () => [{
          value: "",
          label: "skip vesper set"
        }, ...Object.entries(VESPER_SET).map(([tier, val]) => ({
          value: val,
          label: `Tier ${tier}`
        }))],
        white: () => [{
          value: "",
          label: "skip white set"
        }, ...Object.entries(WHITE_SET).map(([tier, val]) => ({
          value: val,
          label: tier
        }))],
        blue: () => [{
          value: "",
          label: "skip blue set"
        }, ...Object.entries(BLUE_SET).flatMap(([multiplier, levels]) =>
          Object.entries(levels).map(([lvl, val]) => ({
            value: val,
            label: `Level ${lvl}*${multiplier}`
          })))]
      },

      eventMap: {
        'penCritSelect': 'atkType',
        'weaponSelect': 'weapon',
        'weaponElementSelect': 'wElem',
        'targetSizeSelect': 'tSize',
        'targetRaceSelect': 'tRace',
        'targetElementSelect': 'tAttr'
      }
    };
  }

  // === HELPER METHODS ===

  getElement(key) {
    return DOM_ELEMENTS[key] || null;
  }

  safeElementOp(key, callback) {
    const el = this.getElement(key);
    if (!el) return;
    callback(el);
  }

  updateWrapperState(element, locked, tempUnlocked = false) {
    if (!element) return;
    
    const wrapper = element.closest('.input-wrap');
    if (!wrapper) return;

    wrapper.classList.toggle('locked', locked);
    
    if (tempUnlocked) {
      wrapper.setAttribute('data-temp-unlocked', '1');
    } else {
      wrapper.removeAttribute('data-temp-unlocked');
    }
  }

  createOption(optData) {
    const opt = document.createElement('option');
    const isString = typeof optData === "string";
    
    opt.value = isString ? optData : optData.value;
    opt.textContent = isString ? optData : optData.label;
    
    if (optData.disabled) {
      opt.disabled = true;
    }
    
    return opt;
  }

  setButtonStates(buttonIds, disabled) {
    buttonIds.forEach(btnId => {
      this.safeElementOp(btnId, btn => {
        btn.disabled = disabled;
      });
    });
  }

  // === INIT & DATA ===

  init() {
    if (this.isInitialized) return;
    
    this.populateAllDropdowns();
    this.bindEvents();
    this.updateAll();
    this.syncThreeSets();
    this.isInitialized = true;
  }

  getFormData() {
    return this.config.formKeys.reduce((data, key) => {
      const el = this.getElement(key);
      if (!el) return data;

      data[key] = el.value || '';
      
      if (el.tagName === 'SELECT' && el.selectedOptions[0]) {
        data[`${key}Text`] = el.selectedOptions[0].textContent;
      }
      
      return data;
    }, {});
  }

  getTargetData(targetKey) {
    if (!targetKey) return null;
    
    const rawData = getTargetDefenseData(targetKey);
    if (!rawData) return null;

    return {
      ...rawData,
      sizeMob: rawData.sizeMob || this.getElement('tSize')?.value || ""
    };
  }

  getCurrentTarget() {
    const targetKey = this.getElement('tDef')?.value;
    if (!targetKey) return null;

    return {
      key: targetKey,
      data: this.getTargetData(targetKey)
    };
  }

  // === POPULATE DROPDOWNS ===

  populateAllDropdowns() {
    Object.entries(this.config.fields).forEach(([key, config]) => {
      if (config.type !== 'dropdown' && config.type !== 'set') return;
      
      const el = this.getElement(key);
      if (!el) return;

      const options = config.generator ?
        this.config.setGenerators[config.generator]() :
        (typeof config.options === 'function' ? config.options() : config.options);

      this.populateOptions(el, options, config.placeholder);
    });
  }

  populateOptions(select, options, placeholder) {
    if (!select) return;
    
    const fragment = document.createDocumentFragment();

    if (placeholder) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = placeholder;
      fragment.appendChild(opt);
    }

    options.forEach(optData => {
      fragment.appendChild(this.createOption(optData));
    });

    select.innerHTML = '';
    select.appendChild(fragment);
  }

  // === FIELD STATE MANAGEMENT ===

  setFieldState(element, disabled, activeText = '', inactiveText = '') {
    if (!element) return;
    
    element.disabled = disabled;
    element.placeholder = disabled ? inactiveText : activeText;
    this.updateWrapperState(element, disabled);
  }

  clearFields(fieldIds) {
    fieldIds.forEach(id => {
      this.safeElementOp(id, el => {
        el.value = '';
      });
    });
  }

  applyMobProperties(targetData, mode = 'standard', lockOverride = null) {
    if (!targetData) return;

    Object.entries(this.config.mobMapping).forEach(([mobProp, domKey]) => {
      const el = this.getElement(domKey);
      if (!el) return;

      const targetValue = targetData[mobProp];
      const shouldLock = this.shouldLock(domKey, targetValue, mode, lockOverride);

      el.value = targetValue || "";
      el.disabled = shouldLock;
      this.state.lockStates.set(domKey, shouldLock);
      this.updateWrapperState(el, shouldLock);

      if (targetValue) return;

      const relatedKey = this.config.relatedFields[domKey];
      if (!relatedKey) return;

      this.safeElementOp(relatedKey, relatedField => {
        relatedField.value = "";
        this.updateWrapperState(relatedField, false, true);
      });
    });
  }

  shouldLock(domKey, targetValue, mode, lockOverride) {
    if (lockOverride !== null) return lockOverride;
    
    const selectedKey = this.getElement('tDef')?.value || "";
    
    if (mode === 'swap') return !!targetValue;
    
    return targetValue && !selectedKey.includes("Lvl.");
  }

  // === EVENT HANDLING ===

  bindEvents() {
    EventManager.removeNS(this.namespace);

    EventManager.addNS(this.namespace, document, 'change', (e) => {
      if (AppState.get('isResultShown')) return;

      if (e.target === this.getElement('tDef')) {
        this.handleTargetChange();
        return;
      }

      if (this.constants.setKeys.includes(e.target.id)) {
        this.recordSelection(e.target);
        this.syncThreeSets();
        this.scheduleUpdate();
        return;
      }

      const fieldKey = this.config.eventMap[e.target.id];
      if (!fieldKey) return;

      const fieldConfig = this.config.fields[fieldKey];
      
      if (fieldConfig?.onClear) {
        this.clearFields(fieldConfig.onClear);
      }
      
      if (fieldConfig?.onUpdate === 'updateAttackTypeUI') {
        this.updateAttackTypeUI();
      }
      
      this.scheduleUpdate();
    });
  }

  handleTargetChange() {
    if (this.state.isSwapping) return;

    const selectedKey = this.getElement('tDef')?.value;
    if (!selectedKey) return;

    const targetData = this.getTargetData(selectedKey);
    if (!targetData) return;

    this.applyMobProperties(targetData);
    this.syncBreakdownSwap(selectedKey);
    this.scheduleUpdate();
  }

  recordSelection(selectEl) {
    const formData = this.getFormData();
    const wasCycleComplete = this.state.selectionOrder.length >= 3 || 
      (formData.blueSet && (formData.blueSetText || "").includes("*8"));

    if (!selectEl?.value) {
      this.state.selectionOrder = this.state.selectionOrder.filter(el => el !== selectEl);
      return;
    }

    if (wasCycleComplete) {
      this.state.selectionOrder = [selectEl];
      return;
    }

    if (this.state.selectionOrder.includes(selectEl)) return;

    this.state.selectionOrder = [...this.state.selectionOrder, selectEl];
  }

  syncThreeSets() {
    const setElements = this.constants.setKeys.map(k => this.getElement(k)).filter(Boolean);
    const formData = this.getFormData();
    const blueIs8x = (formData.blueSetText || "").includes("*8");
    const hasBlue8x = formData.blueSet && blueIs8x;

    setElements.forEach(el => {
      Array.from(el.options).forEach(opt => {
        opt.disabled = false;
      });
    });

    if (hasBlue8x) {
      [this.getElement('vesperSet'), this.getElement('whiteSet')].forEach(el => {
        if (!el) return;
        
        Array.from(el.options).forEach(opt => {
          opt.disabled = !!opt.value;
        });
        el.value = "";
      });
      return;
    }

    const blueEl = this.getElement('blueSet');
    
    if (this.state.selectionOrder.length > 0 && blueEl) {
      Array.from(blueEl.options).forEach(opt => {
        if (opt.value && opt.textContent.includes("*8")) {
          opt.disabled = true;
        }
      });
    }

    if (this.state.selectionOrder.length >= 2) {
      setElements.filter(el => !this.state.selectionOrder.includes(el)).forEach(el => {
        Array.from(el.options).forEach(opt => {
          opt.disabled = !!opt.value;
        });
        el.value = "";
      });
    }

    if (!blueEl?.value) return;
    if (!blueEl.selectedOptions[0]?.disabled) return;

    blueEl.value = "";
    this.state.selectionOrder = this.state.selectionOrder.filter(el => el !== blueEl);
  }

  // === UPDATE UI ===

  updateAll() {
    const formData = this.getFormData();
    this.updateStaticLabels();
    this.updateDynamicLabels(formData);
    this.updateConditionalFields(formData);
    this.updateAttackTypeUI();
  }

  updateStaticLabels() {
    Object.entries(this.config.labels.static).forEach(([key, label]) => {
      this.safeElementOp(key, el => {
        el.textContent = label;
      });
    });
  }

  updateDynamicLabels(formData) {
    const vesperLabel = this.getElement('vesperSetLabel');
    const whiteLabel = this.getElement('whiteSetLabel');

    if (vesperLabel) {
      vesperLabel.textContent = this.config.labels.dynamic.vesper[formData.vesperSet] || "Vesper SET";
    }
    
    if (whiteLabel) {
      whiteLabel.textContent = this.config.labels.dynamic.white[formData.whiteSet] || "White SET (110*3)";
    }
  }

  updateConditionalFields(formData) {
    Object.entries(this.config.fields).forEach(([key, config]) => {
      if (config.type !== 'conditional') return;

      const input = this.getElement(key);
      const label = this.getElement(`${key}Label`);
      
      if (!input || !config.active || !config.default) return;

      const conditionValue = formData[config.dependsOn];
      const settings = conditionValue ? config.active(conditionValue) : config.default;
      const isActive = !!conditionValue;

      input.disabled = !isActive;
      input.placeholder = settings.placeholder;
      
      if (label && settings.label) {
        label.textContent = settings.label;
      }
    });
  }

  updateAttackTypeUI() {
    const atkType = this.getFormData().atkType;
    const penGroup = document.querySelector('.form-group.pen-group');
    const critGroup = document.querySelector('.form-group.crit-group');

    [penGroup, critGroup].forEach(group => group?.classList.add('hidden'));

    if (atkType === 'pen') {
      if (!penGroup) return;
      
      penGroup.classList.remove('hidden');
      this.setFieldState(this.getElement('pen'), false, 'total converted raw pen + final pen...');
      this.setFieldState(this.getElement('crit'), true);
      return;
    }

    if (atkType === 'crit') {
      if (!critGroup) return;
      
      critGroup.classList.remove('hidden');
      this.setFieldState(this.getElement('crit'), false, 'critical damage bonus...');
      this.setFieldState(this.getElement('pen'), true);
      return;
    }

    this.setFieldState(this.getElement('pen'), true);
    this.setFieldState(this.getElement('crit'), true);
  }

  scheduleUpdate() {
    if (this.state.updateTimer) {
      clearTimeout(this.state.updateTimer);
    }
    
    this.state.updateTimer = setTimeout(() => {
      this.updateAll();
      this.state.updateTimer = null;
    }, 50);
  }

  // === SWAP LOGIC ===

  determineSwapMode(prevKey, nextKey) {
    if (!prevKey || !nextKey || nextKey === prevKey) return 'none';

    const prevData = this.getTargetData(prevKey);
    const nextData = this.getTargetData(nextKey);
    
    if (!prevData || !nextData) return 'manual';

    const prevRaw = getTargetDefenseData(prevKey) || {};
    const nextRaw = getTargetDefenseData(nextKey) || {};

    const currentDOM = {
      sizeMob: this.getElement('tSize')?.value || "",
      raceMob: this.getElement('tRace')?.value || "",
      attributeMob: this.getElement('tAttr')?.value || ""
    };

    for (const [mobProp] of Object.entries(this.config.mobMapping)) {
      const prevValue = prevRaw[mobProp];
      const nextValue = nextRaw[mobProp];

      if (prevValue && nextValue && prevValue !== nextValue) return 'manual';
      if (!nextValue || prevValue) continue;
      if (mobProp === 'sizeMob' && currentDOM.sizeMob === nextValue) continue;

      return 'manual';
    }

    return 'auto';
  }

  executeSwap(nextKey, state, isPenMode) {
    const swapMode = this.determineSwapMode(this.getCurrentTarget()?.key, nextKey);
    if (swapMode === 'none') return;

    this.state.isSwapping = true;

    const tDefEl = this.getElement('tDef');
    if (tDefEl) tDefEl.value = nextKey;
    
    this.syncBreakdownSwap(nextKey);
    this.resetGlobalStates();

    const targetData = this.getTargetData(nextKey);
    if (!targetData) {
      this.state.isSwapping = false;
      return;
    }

    if (swapMode === 'auto') {
      this.applyMobProperties(targetData, 'swap');
      
      if (typeof processMainCalculation === 'function') {
        processMainCalculation();
      }
      
      if (typeof showSnackbar === 'function') {
        showSnackbar('Auto calc triggered!');
      }
      
      this.scheduleUpdate();
    } else {
      this.unlockCalculationFields(isPenMode);
      this.applyMobProperties(targetData, 'manual', true);
      this.updateManualSwapUI(state, isPenMode);
      this.scheduleUpdate();
    }

    this.state.isSwapping = false;
  }

  unlockCalculationFields(isPenMode) {
    const fields = [...this.config.calcFields, isPenMode ? "pen" : "crit"];
    
    fields.forEach(fieldName => {
      const field = this.getElement(fieldName);
      if (!field) return;

      const wrapper = field.closest(".input-wrap");
      if (!wrapper?.querySelector('input[type="number"]')) return;

      wrapper.classList.remove("locked");
      wrapper.dataset.tempUnlocked = "1";
      field.disabled = false;
    });

    if (typeof unbindInputLockGuard === 'function') {
      unbindInputLockGuard();
    }
  }

  updateManualSwapUI(state, isPenMode) {
    this.safeElementOp('submit', btn => {
      btn.disabled = false;
    });

    this.setButtonStates(this.config.disableButtons, true);

    this.safeElementOp('hasil', el => {
      el.dataset.specificMode = "0";
      el.textContent = 'Input your stats to see the result...';
    });

    this.safeElementOp('rec', el => {
      el.textContent = 'Balancing stat recommendations for a higher output multiplier.';
    });

    const focusElement = isPenMode ? this.getElement('pen') : this.getElement('crit');
    
    if (typeof scrollAndFocusElement === 'function') {
      scrollAndFocusElement(focusElement, "Target swapped - please verify stats and recalculate!");
    }

    if (typeof validateRequiredFields === 'function') {
      validateRequiredFields();
    }
    
    if (typeof validateStatsVsTarget === 'function') {
      validateStatsVsTarget(state);
    }
  }

  syncBreakdownSwap(targetKey) {
    const swapDropdown = document.querySelector('#breakdown-swap');
    if (!swapDropdown) return;
    if (swapDropdown.value === targetKey) return;
    
    swapDropdown.value = targetKey;
  }

  resetGlobalStates() {
    AppState.reset();
    
    ['testSpear', 'testReaper'].forEach(btnId => {
      this.safeElementOp(btnId, btn => {
        btn.classList.remove('activated');
      });
    });
  }

  createSwapSelect(state, isPenMode) {
    const select = document.createElement("select");
    select.id = "breakdown-swap";
    select.className = "breakdown-swap";

    const pen = +(state.pen);
    const dmg = +(state.dmg);
    const currentKey = this.getCurrentTarget()?.key;
    const allTargetData = getTargetDefenseData();

    const options = Object.keys(allTargetData).map(key => {
      const data = allTargetData[key];
      const def = +(data?.def || 0);
      const dmgred = +(data?.dmgred || 0);
      const insufficient = dmg <= dmgred || (isPenMode && pen <= def);
      const swapMode = this.determineSwapMode(currentKey, key);
      const disabled = swapMode === 'auto' && insufficient;

      const text = disabled ? `${key} (cant auto calc)` : key;
      return `<option value="${key}"${disabled ? ' disabled' : ''}>${text}</option>`;
    });

    select.innerHTML = options.join('');
    select.value = state.tDefKey || "DUMMY Lvl.0 (0 DEF)";

    if (!select.hasAttribute('data-dropdown-bound')) {
      EventManager.addNS(this.namespace, select, 'change', () => {
        this.executeSwap(select.value, state, isPenMode);
      });
      select.setAttribute('data-dropdown-bound', 'true');
    }

    return select;
  }

  destroy() {
    if (this.state.updateTimer) {
      clearTimeout(this.state.updateTimer);
      this.state.updateTimer = null;
    }
    
    EventManager.removeNS(this.namespace);
    this.state.selectionOrder = [];
    this.state.lockStates.clear();
    this.state.isSwapping = false;
    this.isInitialized = false;
  }
};
const dropdownManager = new DropdownManager();

// ======== VALIDATION ========
class ValidationSSoT {
  constructor() {
    this.INVALID_CLASS = 'invalid-value';
    this.touchedFields = new Set();
    this.snackbarCooldowns = new Set();
    this.fieldLastValues = new Map();
    this.namespace = 'validation-ssot';
    this.isInitialized = false;
    this.autoInit();
  }

  // Element type checkers
  isPenOrDmg = (e) => ['pen', 'dmg'].includes(e?.id);
  isRelatedNumeric = (e) => ['race', 'attr'].includes(e?.id);
  isNumeric = (e) => e?.type === 'number' ||
    e?.classList.contains('numeric-input') ||
    this.isPenOrDmg(e) ||
    this.isRelatedNumeric(e);

  // Utilities
  isValidNumber = (v) => !isNaN(+v) && isFinite(+v);
  normalizeInput = (v) => String(v)
    .replace(/[^\d.,]/g, '')
    .replace(/,/g, '.')
    .replace(/\.{2,}/g, '.')
    .replace(/^\./, '0.')
    .replace(/\.$/, '');

  showMessage = (msg) => typeof showSnackbar === 'function' && showSnackbar(msg);

  canShowSnackbar(elementId) {
    if (this.snackbarCooldowns.has(elementId)) return false;
    this.snackbarCooldowns.add(elementId);
    setTimeout(() => this.snackbarCooldowns.delete(elementId), 2000);
    return true;
  }

  getDropdownForRelated(element) {
    return element.id === 'race' ? DOM_ELEMENTS.tRace : DOM_ELEMENTS.tAttr;
  }

  validateRelatedNumeric(element, value) {
    const dropdown = this.getDropdownForRelated(element);
    if (!dropdown?.value && !value) return { isValid: true, reason: 'related_empty' };
    if (dropdown?.value && !value) return { isValid: false, reason: 'related_required' };
    return null;
  }

  validateBoundary(element, numValue, showMessages, boundType) {
    const bound = element.getAttribute(boundType);
    if (bound === null || bound === '') return null;

    const boundVal = +bound;
    const isMin = boundType === 'min';
    const isValid = isMin ? numValue >= boundVal : numValue <= boundVal;
    
    if (isValid) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      if (isMin) {
        const fieldName = element.getAttribute('data-field-name') || element.id || 'Field';
        this.showMessage(`${fieldName} must be at least ${boundVal}`);
      } else {
        this.showMessage('what are you doing?');
      }
    }

    return { isValid: false, reason: isMin ? 'below_min' : 'above_max' };
  }

  validateThreshold(element, numValue, showMessages) {
    if (!this.isPenOrDmg(element)) return null;

    const defData = getTargetDefenseData(DOM_ELEMENTS.tDef?.value);
    const threshold = element.id === 'pen' ? (+(defData?.def) || 0) : (+(defData?.dmgred) || 0);

    if (numValue > threshold) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      const minRequired = (threshold + 8).toFixed(2);
      const fieldType = element.id === 'pen' ? 'Final PEN' : 'Final P/M Bonus';
      const targetLabel = DOM_ELEMENTS.tDef?.options?.[DOM_ELEMENTS.tDef.selectedIndex]?.textContent || 'target';
      this.showMessage(`Need at least ${minRequired} ${fieldType} vs ${targetLabel}`);
    }

    return { isValid: false, reason: 'threshold_not_met' };
  }

  validateField(element, showMessages = false) {
    const value = element.value?.trim() || '';

    if (this.isRelatedNumeric(element)) {
      const result = this.validateRelatedNumeric(element, value);
      if (result) return result;
    }

    if (!value) return { isValid: false, reason: 'empty' };

    if (this.isNumeric(element) && !this.isValidNumber(value)) {
      return { isValid: false, reason: 'invalid_number' };
    }

    const numValue = +value;
    const validators = [
      () => this.validateBoundary(element, numValue, showMessages, 'min'),
      () => this.validateBoundary(element, numValue, showMessages, 'max'),
      () => this.validateThreshold(element, numValue, showMessages)
    ];

    for (const validator of validators) {
      const result = validator();
      if (result) return result;
    }

    return { isValid: true };
  }

  updateFieldState(element, isValid, force = false) {
    if (!force && !this.touchedFields.has(element.id)) return;
    element.classList.toggle(this.INVALID_CLASS, !isValid);
  }

  normalizeElement(element) {
    if (!element || !this.isNumeric(element)) return;

    const normalized = this.normalizeInput(element.value);
    if (normalized !== element.value) element.value = normalized;

    const result = this.validateField(element, this.touchedFields.has(element.id));
    this.updateFieldState(element, result.isValid, true);
  }

  setupField(element) {
    const validateHandler = (showMessages = false) => {
      const result = this.validateField(element, showMessages);
      this.updateFieldState(element, result.isValid);
    };

    const normalizeHandler = () => {
      if (!this.isNumeric(element)) return;
      const normalized = this.normalizeInput(element.value);
      if (normalized !== element.value) element.value = normalized;
    };

    this.fieldLastValues.set(element.id, element.value);

    const eventHandlers = {
      focus: () => this.touchedFields.add(element.id),
      input: () => { normalizeHandler(); validateHandler(false); },
      blur: () => validateHandler(true),
      change: () => validateHandler(true),
      paste: () => this.isNumeric(element) && setTimeout(() => this.normalizeElement(element), 0)
    };

    Object.entries(eventHandlers).forEach(([event, handler]) => {
      EventManager.addNS(this.namespace, element, event, handler);
    });
  }

  setupDefenseChangeHandler() {
    if (!DOM_ELEMENTS.tDef) return;

    EventManager.addNS(this.namespace, DOM_ELEMENTS.tDef, 'change', () => {
      [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg]
        .filter(el => el?.value.trim())
        .forEach(el => {
          const result = this.validateField(el, this.canShowSnackbar(el.id));
          this.updateFieldState(el, result.isValid);
        });
    });
  }

  startWatchingTouchedFields() {
    const el = DOM_ELEMENTS.tSize;
    if (!el) return;

    setInterval(() => {
      if (!this.touchedFields.has(el.id) || !el.classList.contains(this.INVALID_CLASS)) return;

      const lastValue = this.fieldLastValues.get(el.id);
      const currentValue = el.value;

      if (lastValue === currentValue) return;

      this.fieldLastValues.set(el.id, currentValue);
      const result = this.validateField(el, false);
      this.updateFieldState(el, result.isValid, true);
    }, 200);
  }

  checkReady = () => typeof DOM_ELEMENTS !== 'undefined' && DOM_ELEMENTS;

  init() {
    if (this.isInitialized || !this.checkReady()) return false;

    ['atkType', 'weapon', 'wElem', 'tDef', 'tSize', 'pen', 'crit', 'dmg',
      'elemEnh', 'sizeEnh', 'race', 'attr', 'dmgStack'
    ]
      .map(key => DOM_ELEMENTS[key])
      .filter(Boolean)
      .forEach(element => this.setupField(element));

    this.setupDefenseChangeHandler();
    this.startWatchingTouchedFields();

    this.isInitialized = true;
    return true;
  }

  autoInit() {
    if (this.isInitialized) return;

    const initHandler = () => !this.isInitialized && this.init();
    const isDomLoading = document.readyState === 'loading' || document.readyState === 'interactive';

    if (isDomLoading) {
      document.addEventListener('DOMContentLoaded', initHandler, { once: true });
    } else {
      this.init();
    }

    window.addEventListener('load', initHandler, { once: true });
  }

  getRequiredFields() {
    return [
      { el: DOM_ELEMENTS.atkType, name: 'Attack Type' },
      { el: DOM_ELEMENTS.weapon, name: 'Weapon Type' },
      { el: DOM_ELEMENTS.wElem, name: 'Weapon Attribute' },
      { el: DOM_ELEMENTS.tDef, name: 'Target Boss' },
      { el: DOM_ELEMENTS.tSize, name: 'Target Size' },
      { el: DOM_ELEMENTS.pen, name: 'Final P M PEN %', condition: () => DOM_ELEMENTS.atkType?.value === 'pen' },
      { el: DOM_ELEMENTS.crit, name: 'Critical DMG Bonus %', condition: () => DOM_ELEMENTS.atkType?.value === 'crit' },
      { el: DOM_ELEMENTS.dmg, name: 'Final P M DMG Bonus %' },
      { el: DOM_ELEMENTS.elemEnh, name: 'Element Enhance %' },
      { el: DOM_ELEMENTS.sizeEnh, name: 'DMG to Size %' },
      { el: DOM_ELEMENTS.race, name: 'DMG to Race %', condition: () => DOM_ELEMENTS.race && !DOM_ELEMENTS.race.disabled },
      { el: DOM_ELEMENTS.attr, name: 'DMG to Attribute %', condition: () => DOM_ELEMENTS.attr && !DOM_ELEMENTS.attr.disabled },
      { el: DOM_ELEMENTS.dmgStack, name: 'Final DMG Bonus %' }
    ];
  }

  shouldValidateField(field) {
    return field.el && (!field.condition || field.condition());
  }

  processFieldValidation(field, shouldScroll = true) {
    this.touchedFields.add(field.el.id);
    const result = this.validateField(field.el, this.canShowSnackbar(field.el.id));
    this.updateFieldState(field.el, result.isValid, true);

    if (!result.isValid && shouldScroll && typeof scrollAndFocusElement === 'function') {
      scrollAndFocusElement(field.el);
    }

    return result.isValid;
  }

  validateAllRequired() {
    const fields = this.getRequiredFields();

    for (const field of fields) {
      if (!this.shouldValidateField(field)) continue;
      if (!this.processFieldValidation(field)) return false;
    }

    return true;
  }

  getStatsElements(state) {
    const elements = [];
    if (state?.atkType?.toLowerCase() === 'pen' && DOM_ELEMENTS.pen) {
      elements.push(DOM_ELEMENTS.pen);
    }
    if (DOM_ELEMENTS.dmg) elements.push(DOM_ELEMENTS.dmg);
    return elements;
  }

  validateStats(state, focusedElement = null) {
    const elements = this.getStatsElements(state);

    for (const element of elements) {
      const shouldScroll = focusedElement === element || !focusedElement;
      const fieldObject = { el: element };
      
      if (!this.processFieldValidation(fieldObject, shouldScroll)) {
        return false;
      }
    }

    return true;
  }

  destroy() {
    EventManager.removeNS(this.namespace);
    this.touchedFields.clear();
    this.snackbarCooldowns.clear();
    this.fieldLastValues.clear();
    this.isInitialized = false;
  }
};
const ValidationSSoTInstance = new ValidationSSoT();
const normalizeNumericInput = (el, pastedValue) => {
  if (!el) return;
  if (pastedValue !== undefined) el.value = pastedValue;
  ValidationSSoTInstance.normalizeElement(el);
};
const validateRequiredFields = () => ValidationSSoTInstance.validateAllRequired();
const validateStatsVsTarget = (state, focusedElement = null) => ValidationSSoTInstance.validateStats(state, focusedElement);

// ========== INPUT LOCK SYSTEM ==========
const InputLockManager = (() => {
  const PASSIVE_SUPPORT = (() => {
    let supported = false;
    try {
      const opts = {
        get passive() {
          supported = true;
          return false;
        }
      };
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (_) {}
    return supported;
  })();

  const POINTER_SUPPORT = 'PointerEvent' in window;
  const opts = PASSIVE_SUPPORT ? {
    passive: false
  } : false;

  let cachedWrappers = null,
    cacheValid = false,
    observer = null;
  const wrapperListeners = new Map(),
    cooldowns = new WeakMap();

  const invalidateCache = () => {
    cacheValid = false;
    cachedWrappers = null;
  };

  const getCachedWrappers = () => {
    if (cacheValid && cachedWrappers) return cachedWrappers;
    cachedWrappers = Array.from(document.querySelectorAll('.input-wrap'));
    cacheValid = true;
    return cachedWrappers;
  };

  const startCacheObserver = () => {
    if (observer || typeof MutationObserver === 'undefined') return;

    observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          for (const node of [...mutation.addedNodes, ...mutation.removedNodes]) {
            if (node.nodeType === 1 && (node.classList?.contains('input-wrap') || node.querySelector?.('.input-wrap'))) {
              invalidateCache();
              return;
            }
          }
        }
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['class']
    });
  };

  const stopCacheObserver = () => {
    if (observer) observer.disconnect(), observer = null;
  };

  const showLockedMessage = (event) => {
    const target = event?.currentTarget;
    if (!target?.classList?.contains('locked')) return;

    const now = Date.now(),
      lastTime = cooldowns.get(target);
    if (lastTime && (now - lastTime) < 500) return;
    cooldowns.set(target, now);

    if (event?.cancelable) event.preventDefault(), event.stopPropagation();

    if (!window._lastSnackbarTime || (now - window._lastSnackbarTime) > 3000) {
      window._lastSnackbarTime = now;
      typeof showSnackbar === 'function' && showSnackbar("Your Stats Locked!");
    }
  };

  const bind = (wrapper) => {
    if (!wrapper?.nodeType || wrapperListeners.has(wrapper)) return;

    const ids = POINTER_SUPPORT ? [EventManager.add(wrapper, 'pointerdown', showLockedMessage, opts)] : [EventManager.add(wrapper, 'touchstart', showLockedMessage, opts), EventManager.add(wrapper, 'click', showLockedMessage, false)];

    wrapperListeners.set(wrapper, ids);
  };

  const unbind = (wrapper) => {
    if (!wrapper?.nodeType) return;
    const ids = wrapperListeners.get(wrapper);
    if (!ids) return;
    ids.forEach(id => EventManager.remove(id));
    wrapperListeners.delete(wrapper);
    cooldowns.delete(wrapper);
  };

  const lockAll = () => {
    startCacheObserver();
    const wrappers = getCachedWrappers();

    for (let i = 0; i < wrappers.length; i++) {
      const wrapper = wrappers[i];
      const elements = wrapper.querySelectorAll('input, select, textarea');
      if (!elements.length) continue;

      for (let j = 0; j < elements.length; j++) elements[j].disabled = true;
      wrapper.classList.add('locked');
      bind(wrapper);
    }
  };

  const unlockAll = () => {
    const wrappers = getCachedWrappers();

    for (let i = 0; i < wrappers.length; i++) {
      const wrapper = wrappers[i];
      const elements = wrapper.querySelectorAll('input, select, textarea');
      if (!elements.length) continue;

      for (let j = 0; j < elements.length; j++) elements[j].disabled = false;
      wrapper.classList.remove('locked');
      unbind(wrapper);
    }

    invalidateCache();
    stopCacheObserver();
  };

  const destroy = () => {
    stopCacheObserver();
    wrapperListeners.forEach((ids) => ids.forEach(id => EventManager.remove(id)));
    wrapperListeners.clear();
    invalidateCache();
  };

  return {
    bind,
    unbind,
    lockAll,
    unlockAll,
    destroy
  };
})();
const bindInputLockGuard = InputLockManager.bind;
const unbindInputLockGuard = InputLockManager.unbind;
const lockAllInputs = InputLockManager.lockAll;
const unlockAllInputs = InputLockManager.unlockAll;

// ========== STICKY ==========
class StickyHandler {
  constructor() {
    this.state = {
      isActive: false,
      isCollapsed: false,
      isMobile: false,
      animating: false
    };

    this.config = {
      MOBILE_BREAKPOINT: 480,
      BUTTON_HEIGHT: 56,
      ANIMATION_DELAY: 60,
      TRANSITION_DURATION: 300,
      DOM_REINJECT_DELAY: 50,
      OBSERVER_DEBOUNCE: 16,
      RESIZE_DEBOUNCE: 100,
      CLEANUP_DELAY: 320
    };

    this.selectors = {
      resetRek: 'resetRekomenBtn',
      resetAll: 'resetAllBtn',
      swapBoss: 'breakdown-swap',
      stickyStart: () => DOM_ELEMENTS?.stickyStart,
      testSpear: () => DOM_ELEMENTS?.testSpear,
      testReaper: () => DOM_ELEMENTS?.testReaper
    };

    this.buttonOrder = ['toggleBtn', 'swapBoss', 'testSpear', 'testReaper', 'resetRek', 'resetAll', 'backBtn'];
    this.textButtons = new Set(['resetRek', 'resetAll', 'testSpear', 'testReaper']);
    this.controlButtons = [{
        id: 'toggleStickyBtn',
        class: 'sticky-toggle',
        key: 'toggleBtn',
        handler: 'handleToggle'
      },
      {
        id: 'backToHasilBtn',
        class: 'sticky-back',
        key: 'backBtn',
        handler: 'handleBack'
      }
    ];

    this.elements = new Map();
    this.timeouts = new Map();
    this.boundListeners = new Map();
    this.scrollRAF = null;
    this.observer = null;
    this.unsubscribeAppState = null;
    this.initialized = false;

    this.init();
  }

  canOperate() {
    return this.state.isMobile && AppState.get('isResultShown') && this.state.isActive;
  }

  initElements() {
    this.elements.clear();

    for (const [key, selector] of Object.entries(this.selectors)) {
      const element = typeof selector === 'function' ? selector() : document.getElementById(selector);

      if (!element) continue;

      this.elements.set(key, element);

      if (this.textButtons.has(key) && !element.dataset.originalText) {
        element.dataset.originalText = element.textContent.trim() || '';
      }

      if (key === 'swapBoss' && this.state.isActive && this.state.isMobile) {
        element.dataset.stickyPreserve = 'true';
      }
    }

    this.createControlButtons();
  }

  createControlButtons() {
    for (const {
        id,
        class: className,
        key,
        handler
      } of this.controlButtons) {
      let button = document.getElementById(id);

      if (!button) {
        button = document.createElement('button');
        button.id = id;
        button.className = className;
        document.body.appendChild(button);
      }

      this.elements.set(key, button);

      if (!button.dataset.bound) {
        const boundHandler = (e) => this[handler](e);
        button.addEventListener('click', boundHandler);
        button.dataset.bound = 'true';
        this.boundListeners.set(`button-${key}`, {
          target: button,
          event: 'click',
          handler: boundHandler
        });
      }
    }

    const toggleBtn = this.elements.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  }

  getOrderedButtons() {
    const buttons = [];
    for (const key of this.buttonOrder) {
      const btn = this.elements.get(key);
      if (btn) buttons.push(btn);
    }
    return buttons;
  }

  handleToggle = (e) => {
    e.preventDefault();

    if (!this.canOperate() || this.state.animating) return;

    this.state.animating = true;
    this.state.isCollapsed = !this.state.isCollapsed;

    const toggleBtn = this.elements.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = String(this.state.isCollapsed);

    this.applySticky();
    this.scheduleTimeout('animationEnd', () => {
      this.state.animating = false;
    }, this.config.TRANSITION_DURATION);
  }

  handleBack = (e) => {
    e.preventDefault();
    if (!this.canOperate()) return;

    const stickyStart = this.elements.get('stickyStart');
    if (stickyStart) {
      stickyStart.scrollIntoView({
        behavior: 'smooth',
        block: 'start'
      });
    }
  }

  handleScroll = () => {
    if (!this.scrollRAF) {
      this.scrollRAF = requestAnimationFrame(() => {
        this.updateSticky();
        this.scrollRAF = null;
      });
    }
  }

  handleResize = () => {
    this.scheduleTimeout('resize', this.updateSticky.bind(this), this.config.RESIZE_DEBOUNCE);
  }

  scheduleTimeout(key, callback, delay) {
    const existing = this.timeouts.get(key);
    if (existing) clearTimeout(existing);
    this.timeouts.set(key, setTimeout(callback, delay));
  }

  clearAllTimeouts() {
    for (const timeout of this.timeouts.values()) {
      clearTimeout(timeout);
    }
    this.timeouts.clear();
  }

  updateMobileState() {
    const newIsMobile = window.innerWidth <= this.config.MOBILE_BREAKPOINT;
    const changed = newIsMobile !== this.state.isMobile;
    this.state.isMobile = newIsMobile;
    return changed;
  }

  deactivateSticky() {
    this.state.isActive = false;
    this.state.isCollapsed = false;
    this.removeSticky();
  }

  updateSticky() {
    const mobileChanged = this.updateMobileState();

    if (!this.state.isMobile) {
      if (mobileChanged || this.state.isActive) this.deactivateSticky();
      return;
    }

    if (!AppState.get('isResultShown')) {
      if (this.state.isActive) this.deactivateSticky();
      return;
    }

    const stickyStart = this.elements.get('stickyStart');
    if (!stickyStart) return;

    const shouldBeActive = stickyStart.getBoundingClientRect().top <= 0;

    if (shouldBeActive !== this.state.isActive) {
      this.state.isActive = shouldBeActive;
      shouldBeActive ? this.applySticky() : this.removeSticky();
    }
  }

  applySticky() {
    if (!this.canOperate()) return;

    const buttons = this.getOrderedButtons();
    if (buttons.length === 0) return;

    const wasSticky = buttons[0].classList.contains('sticky');
    const toggleBtn = this.elements.get('toggleBtn');

    for (let i = 0; i < buttons.length; i++) {
      const button = buttons[i];
      const isToggle = button === toggleBtn;
      const translateY = this.state.isCollapsed ? 0 : -(i * this.config.BUTTON_HEIGHT);
      const opacity = (this.state.isCollapsed && !isToggle) ? '0.4' : '1';

      button.classList.add('sticky');
      button.classList.toggle('collapsed', this.state.isCollapsed);

      if (!wasSticky) {
        this.animateButtonIn(button, i, translateY);
      } else {
        this.setButtonStyle(button, translateY, opacity);
      }
    }

    this.scheduleTimeout('textUpdate', this.updateButtonText.bind(this), 0);
  }

  animateButtonIn(button, index, translateY) {
    this.setButtonStyle(button, 50, 0, 'none');
    this.scheduleTimeout(`buttonIn-${index}`, () => {
      this.setButtonStyle(button, translateY, 1, 'all 400ms cubic-bezier(0.34, 1.56, 0.64, 1)');
    }, index * this.config.ANIMATION_DELAY);
  }

  setButtonStyle(button, translateY, opacity, transition = '') {
    button.style.cssText = `transform:translate3d(0,${translateY}px,0);opacity:${opacity};${transition ? `transition:${transition};` : ''}`;
  }

  removeSticky() {
    const buttons = this.getOrderedButtons();
    if (buttons.length === 0) return;

    for (const button of buttons) {
      if (button.classList.contains('sticky')) {
        this.setButtonStyle(button, 0, 0.3, 'transform 300ms ease,opacity 200ms ease');
      }
    }

    this.scheduleTimeout('cleanup', () => this.cleanupSticky(buttons), this.config.CLEANUP_DELAY);
  }

  cleanupSticky(buttons) {
    for (const button of buttons) {
      button.classList.remove('sticky', 'collapsed');
      button.style.cssText = '';
      if (button.dataset.originalText) {
        button.textContent = button.dataset.originalText;
      }
    }
  }

  updateButtonText() {
    for (const key of this.textButtons) {
      const button = this.elements.get(key);
      if (button) {
        button.textContent = this.state.isActive ? '' : (button.dataset.originalText || '');
      }
    }
  }

  preserveSwapState() {
    const swapElement = this.elements.get('swapBoss');
    if (!swapElement || swapElement.tagName !== 'SELECT') return null;

    const computed = window.getComputedStyle(swapElement);
    return {
      value: swapElement.value,
      transform: computed.transform,
      opacity: computed.opacity,
      isSticky: swapElement.classList.contains('sticky'),
      isCollapsed: swapElement.classList.contains('collapsed')
    };
  }

  restoreSwapState(state) {
    if (!state) return;

    const swapElement = this.elements.get('swapBoss');
    if (!swapElement || swapElement.tagName !== 'SELECT') return;

    if (state.value) swapElement.value = state.value;

    swapElement.style.cssText = `transform:${state.transform};opacity:${state.opacity};transition:none;`;
    if (state.isSticky) swapElement.classList.add('sticky');
    if (state.isCollapsed) swapElement.classList.add('collapsed');
  }

  // === EVENT LISTENERS ===
  setupEventListeners() {
    const events = [
      ['scroll', this.handleScroll],
      ['resize', this.handleResize]
    ];

    for (const [event, handler] of events) {
      const key = `window-${event}`;
      if (!this.boundListeners.has(key)) {
        window.addEventListener(event, handler, {
          passive: true
        });
        this.boundListeners.set(key, {
          target: window,
          event,
          handler
        });
      }
    }
  }

  removeEventListeners() {
    for (const {
        target,
        event,
        handler
      } of this.boundListeners.values()) {
      target.removeEventListener(event, handler);
    }
    this.boundListeners.clear();
  }

  setupDOMObserver() {
    if (typeof MutationObserver === 'undefined' || this.observer) return;
    const hasilContainer = DOM_ELEMENTS?.hasil;
    if (!hasilContainer) return;

    this.observer = new MutationObserver((mutations) => {
      const hasAddedNodes = mutations.some(m => m.addedNodes.length > 0);
      if (!hasAddedNodes) return;

      let swapReinjected = false;

      for (const mutation of mutations) {
        if (mutation.type !== 'childList') continue;

        for (const node of mutation.addedNodes) {
          if (node.nodeType !== 1) continue;
          if (node.id === 'breakdown-swap' || (node.querySelector?.('#breakdown-swap'))) {
            swapReinjected = true;
            break;
          }
        }
        if (swapReinjected) break;
      }

      if (!swapReinjected) {
        this.scheduleTimeout('observer', this.updateSticky.bind(this), this.config.OBSERVER_DEBOUNCE);
        return;
      }

      this.scheduleTimeout('observer', () => {
        const swapState = this.preserveSwapState();
        this.initElements();

        if (this.canOperate()) {
          if (swapState) this.restoreSwapState(swapState);
          this.scheduleTimeout('domReinject', this.applySticky.bind(this), this.config.DOM_REINJECT_DELAY);
        } else {
          this.updateSticky();
        }
      }, this.config.OBSERVER_DEBOUNCE);
    });

    this.observer.observe(hasilContainer, {
      childList: true,
      subtree: true
    });
  }

  // === APP STATE SUBSCRIPTION ===
  setupAppStateSubscription() {
    this.unsubscribeAppState = AppState.subscribe((key, value) => {
      if (key === 'isResultShown') {
        if (!value && this.state.isActive) {
          this.deactivateSticky();
        } else if (value && this.state.isMobile && !this.state.isActive) {
          this.updateSticky();
        }
      }
    });
  }

  init() {
    const setup = () => {
      if (this.initialized) return;

      this.initElements();
      this.setupEventListeners();
      this.setupDOMObserver();
      this.setupAppStateSubscription();
      this.updateSticky();

      this.initialized = true;
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setup, {
        once: true
      });
    } else {
      setup();
    }
  }

  destroy() {
    this.clearAllTimeouts();

    if (this.scrollRAF) {
      cancelAnimationFrame(this.scrollRAF);
      this.scrollRAF = null;
    }

    this.removeEventListeners();

    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.unsubscribeAppState) {
      this.unsubscribeAppState();
      this.unsubscribeAppState = null;
    }

    this.elements.clear();
    this.boundListeners.clear();
    this.timeouts.clear();
    this.initialized = false;
  }

  static initialize() {
    if (typeof window !== 'undefined' && !window.stickyHandler) {
      window.stickyHandler = new StickyHandler();
    }
    return window.stickyHandler;
  }
};
const stickyHandler = new StickyHandler();

// ========== FLASH SYSTEM ==========
const isMobile = () => window.innerWidth < 480;
const debounceMap = new Map();
let debounceCleanupInterval = null;
const startDebounceCleanup = () => {
  if (debounceCleanupInterval) return;

  debounceCleanupInterval = setInterval(() => {
    const now = Date.now();
    const expiredEntries = Array.from(debounceMap.entries())
      .filter(([, data]) => !data || (data.timestamp && now - data.timestamp > 10000));

    expiredEntries.forEach(([key, data]) => {
      if (data?.timerId) clearTimeout(data.timerId);
      debounceMap.delete(key);
    });

    if (debounceMap.size === 0) {
      clearInterval(debounceCleanupInterval);
      debounceCleanupInterval = null;
    }
  }, 5000);
};
const smoothDebounce = (fn, delay, key) => {
  const existing = debounceMap.get(key);

  if (existing?.timerId) clearTimeout(existing.timerId);
  if (existing?.running) return;

  const timerId = setTimeout(() => {
    const existing = debounceMap.get(key);
    debounceMap.set(key, { ...existing, running: true });
    fn();
    debounceMap.delete(key);
  }, delay);

  debounceMap.set(key, { timerId, running: false });
};
function simulateFlash(event) {
  if (!AppState.get('isResultShown')) return;

  const TIMING = {
    buttonCooldown: 1600,
    flashTrigger: 150,
    calculationDelayOn: 950,
    calculationDelayOff: 100
  };

  const btn = event?.currentTarget;
  if (!btn || btn.disabled) return;

  btn.disabled = true;
  setTimeout(() => btn.disabled = false, TIMING.buttonCooldown);

  const isReaper = btn === DOM_ELEMENTS.testReaper;
  const prefix = isReaper ? 'reaper' : 'spear';
  const oppositePrefix = isReaper ? 'spear' : 'reaper';
  const stateKey = isReaper ? 'isTestReaperActive' : 'isTestSpearActive';

  const wasActive = AppState.get(stateKey);
  const isNowActive = !wasActive;

  AppState.set(stateKey, isNowActive);
  btn.classList.toggle('activated', isNowActive);

  const isTransitionToOn = !wasActive && isNowActive;

  if (isTransitionToOn && AppState.get('currentAnimatingWeapon') && 
      AppState.get('currentAnimatingWeapon') !== prefix) {
    ['flash', 'calc'].forEach(type => {
      const key = `${oppositePrefix}-${type}`;
      const timeout = debounceMap.get(key);
      if (timeout) {
        clearTimeout(timeout);
        debounceMap.delete(key);
      }
    });
  }

  if (isTransitionToOn) {
    AppState.set('currentAnimatingWeapon', prefix);
    setTimeout(() => {
      if (AppState.get('currentAnimatingWeapon') === prefix) {
        AppState.set('currentAnimatingWeapon', null);
      }
    }, TIMING.calculationDelayOn + 100);

    smoothDebounce(triggerPulseFlash, TIMING.flashTrigger, `${prefix}-flash`);
    DOM_ELEMENTS.submit.textContent = "Calculating...";
  }

  const calcDelay = isTransitionToOn 
    ? TIMING.calculationDelayOn 
    : TIMING.calculationDelayOff;

  smoothDebounce(() => {
    if (typeof processMainCalculation === 'function') {
      processMainCalculation();
    }
  }, calcDelay, `${prefix}-calc`);

  const weaponName = isReaper ? 'Reaper' : 'Spear';
  const statusText = isNowActive ? 'Flash Active' : 'Off';

  if (typeof showSnackbar === 'function') {
    showSnackbar(`${weaponName} ${statusText}`);
  }
}
function triggerPulseFlash() {
  if (!AppState.get('isResultShown') || !isMobile() || AppState.get('isFlashActive')) return;

  const TIMING = {
    animationDuration: 1800,
    emergencyCleanup: 2200
  };

  AppState.set('isFlashActive', true);

  requestAnimationFrame(() => {
    const flash = document.createElement('div');
    const lightning = document.createElement('div');
    flash.className = 'lightning-flash-overlay';
    lightning.className = 'lightning-icon';
    flash.appendChild(lightning);

    try {
      document.body.appendChild(flash);
    } catch (e) {
      console.warn('Flash DOM insertion failed', e);
      AppState.set('isFlashActive', false);
      return;
    }

    const cleanup = () => {
      if (flash.parentNode) {
        flash.parentNode.removeChild(flash);
      }
      AppState.set('isFlashActive', false);
    };

    setTimeout(cleanup, TIMING.animationDuration);
    setTimeout(() => {
      if (AppState.get('isFlashActive') && flash.parentNode) {
        cleanup();
      }
    }, TIMING.emergencyCleanup);
  });
}

// ======== SNACKBAR ========
const SnackbarManager = (() => {
  let hideTimer = null;
  let trackingKeyboard = false;
  let lastBottom = -1;
  let viewportChangeTimer = null;
  
  const NS = 'snackbar';
  
  const CONFIG = {
    MOBILE_MAX_WIDTH: 480,
    KEYBOARD_MIN: 100,
    BASE_OFFSET: 20,
    SHOW_DURATION: 3000,
    HIDE_ANIMATION: 300,
    RESIZE_DEBOUNCE: 150
  };
  
  const isMobileView = () => window.innerWidth <= CONFIG.MOBILE_MAX_WIDTH;
  
  const calcKeyboardHeight = () => {
    const vp = window.visualViewport;
    if (!vp) return 0;
    
    const gap = window.innerHeight - vp.height;
    return (gap > 50 && gap < window.innerHeight * 0.7) ? gap : 0;
  };

  const clearTimer = (timer) => {
    if (timer) clearTimeout(timer);
    return null;
  };
  
  const updatePosition = () => {
    const el = DOM_ELEMENTS?.snackbar;
    if (!el?.classList.contains('show') || !isMobileView() || !window.visualViewport) return;
    
    const kbHeight = calcKeyboardHeight();
    const bottom = (kbHeight > CONFIG.KEYBOARD_MIN ? kbHeight : 0) 
                   + CONFIG.BASE_OFFSET 
                   - window.visualViewport.offsetTop;
    
    if (bottom === lastBottom) return;
    
    lastBottom = bottom;
    el.style.bottom = `${bottom}px`;
  };
  
  const toggleTracking = (enable) => {
    if (trackingKeyboard === enable) return;
    
    const vp = window.visualViewport;
    if (!vp) return;
    
    trackingKeyboard = enable;
    lastBottom = -1;
    
    if (enable) {
      const passiveOpt = { passive: true };
      EventManager.addNS(`${NS}_viewport`, vp, 'resize', updatePosition, passiveOpt);
      EventManager.addNS(`${NS}_viewport`, vp, 'scroll', updatePosition, passiveOpt);
    } else {
      EventManager.removeNS(`${NS}_viewport`);
      const el = DOM_ELEMENTS?.snackbar;
      if (el) el.style.bottom = '';
    }
  };
  
  const show = (message) => {
    const el = DOM_ELEMENTS?.snackbar;
    if (!el || !message) return;
    
    hideTimer = clearTimer(hideTimer);
    
    el.textContent = message;
    el.classList.remove('show');
    void el.offsetHeight;
    el.classList.add('show');
    
    if (isMobileView()) {
      lastBottom = -1;
      updatePosition();
      toggleTracking(true);
    } else {
      el.style.bottom = `${CONFIG.BASE_OFFSET}px`;
    }
    
    hideTimer = setTimeout(() => {
      el.classList.remove('show');
      setTimeout(() => {
        if (!el.classList.contains('show')) toggleTracking(false);
      }, CONFIG.HIDE_ANIMATION);
      hideTimer = null;
    }, CONFIG.SHOW_DURATION);
  };
  
  const handleWindowResize = () => {
    viewportChangeTimer = clearTimer(viewportChangeTimer);
    
    viewportChangeTimer = setTimeout(() => {
      const el = DOM_ELEMENTS?.snackbar;
      if (!el?.classList.contains('show')) {
        viewportChangeTimer = null;
        return;
      }
      
      if (isMobileView()) {
        if (!trackingKeyboard) {
          lastBottom = -1;
          toggleTracking(true);
          updatePosition();
        }
      } else {
        toggleTracking(false);
        el.style.bottom = `${CONFIG.BASE_OFFSET}px`;
      }
      
      viewportChangeTimer = null;
    }, CONFIG.RESIZE_DEBOUNCE);
  };
  
  EventManager.addNS(NS, window, 'resize', handleWindowResize, { passive: true });
  
  return {
    show,
    cleanup: () => {
      hideTimer = clearTimer(hideTimer);
      viewportChangeTimer = clearTimer(viewportChangeTimer);
      
      EventManager.removeNS(NS);
      EventManager.removeNS(`${NS}_viewport`);
      EventManager.forceCleanup();
      
      trackingKeyboard = false;
      lastBottom = -1;
      
      const el = DOM_ELEMENTS?.snackbar;
      if (el) {
        el.style.bottom = '';
        el.classList.remove('show');
      }
    }
  };
})();
const showSnackbar = SnackbarManager.show;
const scrollAndFocusElement = (el, msg) => {
  if (msg) showSnackbar(msg);

  const offsetTop = el.getBoundingClientRect().top + window.pageYOffset - 80;
  window.scrollTo({
    top: offsetTop,
    behavior: 'smooth'
  });

  if (!el.disabled) {
    el.focus({ preventScroll: true });
  }

  return false;
};

// ========== TOOLTIP SYSTEM ==========
const TooltipManager = (() => {
  const activeTooltips = new Map();
  const lazyTooltips = new Map();
  let orphanObserver = null;
  let autoInitObserver = null;
  let tooltipConfig = {};

  const CONFIG = {
    HIDE_DELAY: 300,
    THROTTLE_DELAY: 16,
    MARGIN: 16,
    OFFSET: 12,
    TRANSITION_DURATION: 200,
    TRANSITION_TIMING: 'cubic-bezier(0.25, 0.8, 0.25, 1)'
  };

  const SVG_ICON = `<svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>`;

  const forceReflow = (element) => void element.offsetHeight;

  const cleanupTooltipData = (map, node) => {
    const data = map.get(node);
    if (!data) return;

    if (data.cleanup) data.cleanup();
    if (data.listenerIds) {
      data.listenerIds.forEach(id => EventManager.remove(id));
    }
    map.delete(node);
  };

  const cleanupOrphanedTooltip = (node) => {
    cleanupTooltipData(activeTooltips, node);
    cleanupTooltipData(lazyTooltips, node);
  };

  const cleanupChildTooltips = (node) => {
    if (!node.querySelectorAll) return;

    [activeTooltips, lazyTooltips].forEach(map => {
      map.forEach((data, el) => {
        if (el !== node && node.contains(el)) {
          if (data.cleanup) data.cleanup();
          if (data.listenerIds) {
            data.listenerIds.forEach(id => EventManager.remove(id));
          }
          map.delete(el);
        }
      });
    });
  };

  const createObserver = (callback, shouldObserve) => {
    if (!shouldObserve || typeof MutationObserver === 'undefined') return null;

    const observer = new MutationObserver(callback);
    observer.observe(document.body, { childList: true, subtree: true });
    return observer;
  };

  const startOrphanDetection = () => {
    if (orphanObserver) return;

    orphanObserver = createObserver((mutations) => {
      const elementsToCheck = new Set();

      mutations.forEach(mutation => {
        mutation.removedNodes.forEach(node => {
          if (node.nodeType === 1) elementsToCheck.add(node);
        });
      });

      elementsToCheck.forEach(node => {
        cleanupOrphanedTooltip(node);
        cleanupChildTooltips(node);
      });
    }, true);
  };

  const matchesSelector = (element, selector) => {
    if (selector.startsWith('#')) return element.id === selector.slice(1);
    if (selector.startsWith('.')) return element.classList.contains(selector.slice(1));
    if (selector.startsWith('[')) {
      const attrMatch = selector.match(/\[([^\]]+)\]/);
      if (attrMatch) {
        const [attrName, attrValue] = attrMatch[1].split('=');
        return attrValue 
          ? element.getAttribute(attrName) === attrValue.replace(/['"]/g, '')
          : element.hasAttribute(attrName);
      }
    }
    return element.matches(selector);
  };

  const injectSVG = (element) => {
    if (element.classList.contains('tooltip-button') && !element.querySelector('svg')) {
      element.innerHTML = SVG_ICON;
    }
  };

  const initializeElement = (element) => {
    if (lazyTooltips.has(element)) return;

    injectSVG(element);

    Object.entries(tooltipConfig).forEach(([selector, content]) => {
      try {
        if (matchesSelector(element, selector)) {
          registerLazyTooltip(element, content);
        }
      } catch (e) {}
    });
  };

  const startAutoInit = () => {
    if (autoInitObserver || Object.keys(tooltipConfig).length === 0) return;

    autoInitObserver = createObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType !== 1) return;

          initializeElement(node);

          if (node.querySelectorAll) {
            Object.keys(tooltipConfig).forEach(selector => {
              try {
                node.querySelectorAll(selector).forEach(el => initializeElement(el));
              } catch (e) {}
            });
          }
        });
      });
    }, true);
  };

  const stopObserver = (observer) => {
    if (!observer) return null;
    observer.disconnect();
    return null;
  };

  const stopAutoInit = () => {
    autoInitObserver = stopObserver(autoInitObserver);
  };

  const stopOrphanDetection = () => {
    orphanObserver = stopObserver(orphanObserver);
  };

  const calculateTooltipSize = (tooltip) => {
    tooltip.style.cssText = 'visibility:hidden;display:block';
    const size = { width: tooltip.offsetWidth, height: tooltip.offsetHeight };
    tooltip.style.cssText = '';
    return size;
  };

  const calculatePosition = (rect, scrollX, scrollY, tooltipWidth, tooltipHeight) => {
    const centerX = rect.left + scrollX + (rect.width / 2);
    const maxLeft = window.innerWidth - tooltipWidth - CONFIG.MARGIN;
    const left = Math.max(CONFIG.MARGIN, Math.min(centerX - (tooltipWidth / 2), maxLeft));

    let top = rect.top + scrollY - tooltipHeight - CONFIG.OFFSET;
    let isFlipped = false;

    if (top < CONFIG.MARGIN + scrollY) {
      top = rect.bottom + scrollY + CONFIG.OFFSET;
      isFlipped = true;
    }

    return { left, top, isFlipped };
  };

  const applyTooltipStyles = (tooltip, transform, opacity) => {
    tooltip.style.transform = transform;
    tooltip.style.opacity = opacity.toString();
  };

  const createTooltip = (triggerElement, content) => {
    if (!triggerElement || !content) return;

    const existing = activeTooltips.get(triggerElement);
    if (existing?.cleanup) {
      existing.cleanup();
      activeTooltips.delete(triggerElement);
    }

    const tooltip = document.createElement("div");
    tooltip.className = "tooltip-wrap";
    tooltip.innerHTML = content;
    
    const transitionProps = `opacity ${CONFIG.TRANSITION_DURATION}ms ${CONFIG.TRANSITION_TIMING}, transform ${CONFIG.TRANSITION_DURATION}ms ${CONFIG.TRANSITION_TIMING}`;
    tooltip.style.transition = transitionProps;
    tooltip.style.willChange = 'opacity, transform';
    
    document.body.appendChild(tooltip);

    let isVisible = false;
    let hideTimer = null;
    const namespace = `tooltip-active-${Date.now()}-${Math.random()}`;

    const cleanup = () => {
      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      EventManager.removeNS(namespace);

      if (tooltip.parentNode) {
        tooltip.parentNode.removeChild(tooltip);
      }

      activeTooltips.delete(triggerElement);
    };

    const updatePosition = () => {
      if (!document.contains(triggerElement) || !document.contains(tooltip)) {
        cleanup();
        return;
      }

      const rect = triggerElement.getBoundingClientRect();
      const scrollX = window.pageXOffset;
      const scrollY = window.pageYOffset;

      const { width: tooltipWidth, height: tooltipHeight } = calculateTooltipSize(tooltip);
      const { left, top, isFlipped } = calculatePosition(rect, scrollX, scrollY, tooltipWidth, tooltipHeight);

      tooltip.classList.toggle('flipped', isFlipped);
      tooltip.style.transform = `translate(${left}px, ${top}px)`;
    };

    const show = () => {
      if (isVisible) return;

      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      updatePosition();
      
      applyTooltipStyles(tooltip, `${tooltip.style.transform} scale(0.95)`, 0);
      forceReflow(tooltip);
      
      isVisible = true;
      tooltip.classList.add('show');
      
      requestAnimationFrame(() => {
        applyTooltipStyles(tooltip, tooltip.style.transform.replace(' scale(0.95)', ' scale(1)'), 1);
      });
    };

    const hide = () => {
      if (!isVisible) return;

      isVisible = false;
      applyTooltipStyles(tooltip, tooltip.style.transform.replace(' scale(1)', ' scale(0.95)'), 0);
      
      setTimeout(() => {
        tooltip.classList.remove('show');
        cleanup();
      }, CONFIG.TRANSITION_DURATION);
    };

    const handleOutsideInteraction = (e) => {
      if (!isVisible) return;
      if (triggerElement.contains(e.target) || tooltip.contains(e.target)) return;
      hide();
    };

    const handleKeydown = (e) => {
      if (e.key === "Escape" && isVisible) hide();
    };

    const throttledPosition = () => {
      if (!isVisible) return;

      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      hideTimer = setTimeout(() => {
        updatePosition();
        hideTimer = null;
      }, CONFIG.THROTTLE_DELAY);
    };

    const passiveOpt = { passive: true };

    EventManager.addNS(namespace, document, "click", handleOutsideInteraction);
    EventManager.addNS(namespace, document, "touchend", handleOutsideInteraction, passiveOpt);
    EventManager.addNS(namespace, document, "keydown", handleKeydown);
    EventManager.addNS(namespace, window, 'resize', throttledPosition, passiveOpt);
    EventManager.addNS(namespace, window, 'scroll', throttledPosition, passiveOpt);

    activeTooltips.set(triggerElement, { tooltip, cleanup, namespace });

    show();
  };

  const registerLazyTooltip = (triggerElement, content) => {
    if (!triggerElement || !content) return;

    const existing = lazyTooltips.get(triggerElement);
    if (existing && existing.content === content) return;

    if (existing?.listenerIds) {
      existing.listenerIds.forEach(id => EventManager.remove(id));
    }

    const namespace = `tooltip-lazy-${Date.now()}-${Math.random()}`;

    const initTooltip = (e) => {
      if (e?.cancelable) e.preventDefault();
      createTooltip(triggerElement, content);
    };

    const handleClick = (e) => {
      const target = e.target;
      if (target === triggerElement || triggerElement.contains(target)) {
        initTooltip(e);
      }
    };

    const listenerIds = [
      EventManager.addNS(namespace, triggerElement, "click", handleClick),
      EventManager.addNS(namespace, triggerElement, "touchend", handleClick, { passive: false })
    ];

    lazyTooltips.set(triggerElement, { content, namespace, listenerIds });

    if (lazyTooltips.size === 1 && !orphanObserver) {
      startOrphanDetection();
    }
  };

  const destroyAll = () => {
    stopAutoInit();
    stopOrphanDetection();

    activeTooltips.forEach(({ cleanup }) => {
      if (cleanup) cleanup();
    });
    activeTooltips.clear();

    lazyTooltips.forEach(({ listenerIds }) => {
      if (listenerIds) {
        listenerIds.forEach(id => EventManager.remove(id));
      }
    });
    lazyTooltips.clear();

    tooltipConfig = {};
  };

  return {
    registerLazyTooltip,
    startAutoInit,
    stopAutoInit,
    setConfig: (config) => {
      tooltipConfig = config;
      startAutoInit();
    },
    destroyAll,
    initializeElement
  };
})();
const setupTooltips = (config) => {
  TooltipManager.setConfig(config);

  Object.entries(config).forEach(([selector, content]) => {
    const elements = typeof selector === 'string' 
      ? document.querySelectorAll(selector)
      : selector instanceof Element ? [selector] : [];

    elements.forEach(el => {
      if (el instanceof Element) {
        TooltipManager.initializeElement(el);
      }
    });
  });
};
setupTooltips({
  "#dmgStackTips": "<strong>Final DMG Bonus</strong> and <strong>F. P/M DMG BONUS</strong> are two <strong>different</strong> things! Look for it in your <strong>detailed stats</strong> where it shows as <strong>Final Damage Stack</strong> or <strong>Final Damage Bonus</strong>. Make sure you don't have any buffs active. Can't find it? Just set 0.",
  "#targetRaceTips": "Specific MVP/MINi will <strong>auto sync and lock</strong> this option. Select <strong>Avg Lvl Boss</strong> if you want to target spesific race!",
  "#targetAttrTips": "also same with race.",
  "#dmgRaceTips": "Unlocked when target race selected, minimum valid value is 0.",
  "#dmgAttrTips": "same condition with dmg to race",
  "#mvpminiTips": "DUMMY have no defense stat. Avg 130, Necro, Ogre, Ktul defs less accurate than others!",
  "#attackTips": "As you can see, it starts with 1, which is your attack. You can use the final result of this calculation to multiply with your attack (up to 99.5% accurate, <a href='#' class='job-sim' data-lightbox-gallery='my-gallery' data-lightbox-trigger>see this</a>).<br><br>But, dont expect to much! This tool calculates RNG buffs from equipment sets, flashes, and doesn't include flat or percentage damage bonuses.",
  "#flashTips": "The values below are normalized to 100% uptime because both flashes only last 10 seconds on a 20 second cooldown.",
  "#reaperTips": "Whether the elements match (+84% Final DMG Bonus) or differ (+28% Final DMG Bonus), the bonus doesn't have 100% uptime since it only lasts 10 seconds with a 20-second cooldown, and the final result shown below represents the highest output during the buff's active period.",
  "#spearTips": "This bonus doesn't have 100% uptime because it only lasts 10 seconds while the cooldown is 20 seconds. The final result shown below represents the highest output during the buff's active period.",
  "#elemCtrTips": "Tools assume target Neutral if you're not targeting any attribute.",
  "#breakdownTips": "Values shown to two decimal places for readability. The final result is computed with full precision, so it may differ slightly if you recompute using the displayed (rounded) numbers.",
  "#tableTips": "An upward arrow means higher than your stat, a square means roughly equal (±3%), and a downward means lower."
});

// ========== ACCORDION SYSTEM ==========
const accordionManager = (() => {
  const duration = 320;
  const easing = 'cubic-bezier(0.25, 0.8, 0.25, 1)';
  const transition = `max-height ${duration}ms ${easing}, opacity ${duration}ms ease-out`;
  const instances = new Map();
  const namespace = 'accordion-manager';
  let observer = null;
  let cleanupInterval = null;
  
  const forceReflow = (element) => void element.offsetHeight;
  
  const applyStyles = (content, maxHeight, opacity, enableTransition) => {
    content.style.transition = enableTransition ? transition : 'none';
    content.style.maxHeight = maxHeight;
    content.style.opacity = opacity.toString();
  };
  
  const createInstance = (details, summary, content) => {
    let isAnimating = false;
    let currentAnimation = null;
    let transitionListenerId = null;
    const instanceNamespace = `${namespace}-${Date.now()}-${Math.random()}`;
    
    const cleanup = () => {
      if (currentAnimation) {
        cancelAnimationFrame(currentAnimation);
        currentAnimation = null;
      }
      if (transitionListenerId !== null) {
        EventManager.remove(transitionListenerId);
        transitionListenerId = null;
      }
      isAnimating = false;
    };
    
    const setupTransitionListener = (callback) => {
      if (transitionListenerId !== null) {
        EventManager.remove(transitionListenerId);
      }
      
      const onTransitionEnd = (e) => {
        if (e.target !== content) return;
        if (e.propertyName !== 'max-height') return;
        
        EventManager.remove(transitionListenerId);
        transitionListenerId = null;
        isAnimating = false;
        callback();
      };
      
      transitionListenerId = EventManager.add(content, 'transitionend', onTransitionEnd);
    };
    
    const animateOpen = () => {
      details.setAttribute('open', '');
      
      applyStyles(content, '0px', 0.3, false);
      forceReflow(content);
      
      const targetHeight = content.scrollHeight + 'px';
      
      currentAnimation = requestAnimationFrame(() => {
        applyStyles(content, targetHeight, 1, true);
        
        setupTransitionListener(() => {
          applyStyles(content, 'none', 1, true);
        });
      });
    };
    
    const animateClose = () => {
      const currentHeight = content.scrollHeight + 'px';
      
      applyStyles(content, currentHeight, 1, false);
      forceReflow(content);
      
      currentAnimation = requestAnimationFrame(() => {
        applyStyles(content, '0px', 0.3, true);
        
        setupTransitionListener(() => {
          details.removeAttribute('open');
        });
      });
    };
    
    const handleClick = (e) => {
      e.preventDefault();
      if (isAnimating) return;
      
      cleanup();
      isAnimating = true;
      
      const isOpen = details.hasAttribute('open');
      isOpen ? animateClose() : animateOpen();
    };
    
    EventManager.addNS(instanceNamespace, summary, 'click', handleClick);
    
    return {
      cleanup: () => {
        cleanup();
        EventManager.removeNS(instanceNamespace);
      },
      get isAnimating() {
        return isAnimating;
      },
      namespace: instanceNamespace
    };
  };
  
  const cleanupOrphans = () => {
    const orphanedKeys = [];
    
    instances.forEach((instance, details) => {
      if (!document.contains(details)) {
        instance.cleanup();
        orphanedKeys.push(details);
      }
    });
    
    orphanedKeys.forEach(key => instances.delete(key));
    
    if (instances.size === 0 && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };
  
  const startCleanupInterval = () => {
    if (cleanupInterval || instances.size === 0) return;
    cleanupInterval = setInterval(cleanupOrphans, 30000);
  };
  
  const initializeDetailsElement = (details) => {
    const summary = details.querySelector('summary');
    const content = details.querySelector('.body');
    
    if (!summary || !content || instances.has(details)) return;
    
    const isOpen = details.hasAttribute('open');
    
    content.style.overflow = 'hidden';
    content.style.willChange = 'max-height, opacity';
    applyStyles(content, isOpen ? 'none' : '0px', isOpen ? 1 : 0.3, false);
    forceReflow(content);
    content.style.transition = transition;
    
    instances.set(details, createInstance(details, summary, content));
  };
  
  const processDetails = () => {
    cleanupOrphans();
    document.querySelectorAll('details').forEach(initializeDetailsElement);
    startCleanupInterval();
  };
  
  const shouldProcessMutation = (mutations) => {
    for (const mutation of mutations) {
      if (mutation.addedNodes.length === 0) continue;
      
      for (const node of mutation.addedNodes) {
        if (node.nodeType !== 1) continue;
        if (node.tagName === 'DETAILS' || node.querySelector?.('details')) return true;
      }
    }
    return false;
  };
  
  const handleRemovedNodes = (mutations) => {
    for (const mutation of mutations) {
      if (mutation.removedNodes.length === 0) continue;
      
      for (const node of mutation.removedNodes) {
        if (node.nodeType !== 1) continue;
        
        if (node.tagName === 'DETAILS' && instances.has(node)) {
          instances.get(node).cleanup();
          instances.delete(node);
          continue;
        }
        
        if (node.querySelectorAll) {
          instances.forEach((instance, details) => {
            if (node.contains(details)) {
              instance.cleanup();
              instances.delete(details);
            }
          });
        }
      }
    }
  };
  
  processDetails();
  
  observer = new MutationObserver((mutations) => {
    handleRemovedNodes(mutations);
    if (shouldProcessMutation(mutations)) {
      requestAnimationFrame(processDetails);
    }
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  const destroy = () => {
    if (cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
    if (observer) {
      observer.disconnect();
      observer = null;
    }
    instances.forEach(instance => instance.cleanup());
    instances.clear();
  };
  
  EventManager.addNS(namespace, window, 'beforeunload', destroy);
  
  return {
    destroy,
    reinitialize: processDetails
  };
})();

// ======== LOG MODAL ========
const modalManager = (() => {
  const { log, openLog, closeLog } = DOM_ELEMENTS || {};
  if (!log) {
    return {
      show: () => {},
      hide: () => {},
      destroy: () => {}
    };
  }
  
  const content = log.querySelector('.modal-content, .log-content, .modal-body') || log.firstElementChild;
  const changelog = log.querySelector('#changelog');
  const duration = 280;
  const easing = 'cubic-bezier(0.25, 0.8, 0.25, 1)';
  const namespace = 'modal-manager';
  
  const transition = `${duration}ms ${easing}`;
  const baseStyles = {
    modal: {
      display: 'none',
      transition: `opacity ${transition}, transform ${transition}, backdrop-filter ${transition}`,
      transformOrigin: 'center'
    },
    content: content ? {
      transition: `transform ${transition}, opacity ${transition}`
    } : null
  };
  
  Object.assign(log.style, baseStyles.modal);
  if (content) Object.assign(content.style, baseStyles.content);
  
  let isVisible = false;
  let animationId = null;
  let hideTimeout = null;
  let changelogLoaded = false;
  
  const clearTimers = () => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    if (hideTimeout) {
      clearTimeout(hideTimeout);
      hideTimeout = null;
    }
  };
  
  const applyStyles = (isShowing) => {
    const modalStyles = isShowing ? {
      opacity: '1',
      transform: 'scale(1)',
      backdropFilter: 'blur(6px)',
      backgroundColor: 'rgba(0, 0, 0, 0.3)'
    } : {
      opacity: '0',
      transform: 'scale(0.96)',
      backdropFilter: 'blur(0px)',
      backgroundColor: 'transparent'
    };
    
    const contentStyles = content ? (isShowing ? {
      transform: 'translateY(0) scale(1)',
      opacity: '1'
    } : {
      transform: 'translateY(-8px) scale(0.98)',
      opacity: '0.5'
    }) : null;
    
    Object.assign(log.style, modalStyles);
    if (contentStyles) Object.assign(content.style, contentStyles);
  };
  
  // Render nested list items
  const renderList = (items) => {
    if (!Array.isArray(items)) return '';
    
    return items.map(item => {
      if (typeof item === 'string') {
        return `<li>${item}</li>`;
      }
      if (item.category !== undefined) {
        if (item.category === '') {
          return renderList(item.items);
        }
        return `
          <li>
            <span class="sub-cats">${item.category}</span>
            <ul>${renderList(item.items)}</ul>
          </li>`;
      }
      if (item.text) {
        const nested = item.items ? `<ul>${renderList(item.items)}</ul>` : '';
        return `<li>${item.text}${nested}</li>`;
      }
      return '';
    }).join('');
  };
  
  // Load changelog from JSON
  const loadChangelog = async () => {
    if (changelogLoaded) return;
    
    try {
      const response = await fetch('changelog.json');
      if (!response.ok) throw new Error('Failed to load changelog');
      
      const data = await response.json();
      
      // Clear existing content except header
      const header = changelog.querySelector('.header-log');
      changelog.innerHTML = '';
      if (header) changelog.appendChild(header);
      
      // Render versions
      data.versions.forEach(version => {
        const versionDiv = document.createElement('div');
        versionDiv.className = 'version';
        versionDiv.innerHTML = `
          <h3>[${version.version}] - ${version.date}</h3>
          <ul>${renderList(version.changes)}</ul>
        `;
        changelog.appendChild(versionDiv);
      });
      
      changelogLoaded = true;
    } catch (error) {
      console.error('Error loading changelog:', error);
      
      // Show error message
      const errorDiv = document.createElement('div');
      errorDiv.className = 'version';
      errorDiv.innerHTML = '<p style="color: #ff6b6b;">Failed to load changelog. Please try again later.</p>';
      changelog.appendChild(errorDiv);
    }
  };
  
  const hide = () => {
    if (!isVisible) return;
    
    isVisible = false;
    clearTimers();
    applyStyles(false);
    
    hideTimeout = setTimeout(() => {
      if (!isVisible) {
        log.style.display = 'none';
      }
    }, duration);
  };
  
  const show = async () => {
    if (isVisible) return;
    
    isVisible = true;
    clearTimers();
    
    log.style.display = 'flex';
    
    // Lazy load changelog
    await loadChangelog();
    
    animationId = requestAnimationFrame(() => {
      applyStyles(true);
    });
  };
  
  const handleOpen = (e) => {
    e.stopPropagation();
    show();
  };
  
  const handleKeydown = (e) => {
    if (e.key === 'Escape' && isVisible) hide();
  };
  
  const handleOutsideClick = (e) => {
    if (!isVisible || !content) return;
    if (content.contains(e.target) || e.target === openLog) return;
    hide();
  };
  
  EventManager.addNS(namespace, openLog, 'click', handleOpen);
  EventManager.addNS(namespace, closeLog, 'click', hide);
  EventManager.addNS(namespace, document, 'keydown', handleKeydown);
  EventManager.addNS(namespace, document, 'click', handleOutsideClick);
  
  const destroy = () => {
    clearTimers();
    EventManager.removeNS(namespace);
  };
  
  EventManager.addNS(namespace, window, 'beforeunload', destroy);
  
  return { show, hide, destroy };
})();

// ======== LIGHTBOX ========
const imgLightbox = (() => {
  const NS = 'img-lightbox';
  const els = {
    overlay: document.getElementById('img-lightbox-overlay'),
    image: document.querySelector('.img-lightbox-image'),
    loader: document.querySelector('.img-lightbox-loader'),
    closeBtn: document.querySelector('.img-lightbox-close'),
    inner: document.querySelector('.img-lightbox-inner'),
    caption: document.querySelector('.img-lightbox-caption'),
    counter: document.querySelector('.img-lightbox-counter'),
    prevBtn: document.querySelector('.img-lightbox-prev'),
    nextBtn: document.querySelector('.img-lightbox-next')
  };

  const state = {
    scale: 1,
    translateX: 0,
    translateY: 0,
    isDragging: false,
    dragStartX: 0,
    dragStartY: 0,
    pinchStart: 0,
    scaleStart: 1,
    imageLoadId: null,
    galleries: {},
    currentGallery: null,
    currentIndex: 0
  };

  const cfg = {
    MIN: 1,
    MAX: 5,
    STEP: 0.3
  };

  const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
  const dist = (t1, t2) => Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
  const center = (t1, t2) => ({
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  });

  const apply = () => {
    els.image.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
  };

  const reset = () => {
    Object.assign(state, {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isDragging: false
    });
    apply();
    els.image.style.cursor = 'default';
  };

  const cleanupLoaders = () => {
    if (els.image) {
      els.image.onload = null;
      els.image.onerror = null;
    }
    state.imageLoadId = null;
  };

  const getCurrentItems = () => {
    return state.currentGallery ? state.galleries[state.currentGallery] : [];
  };

  const updateUI = () => {
    const items = getCurrentItems();
    const item = items[state.currentIndex];
    
    els.prevBtn.classList.toggle('disabled', state.currentIndex === 0);
    els.nextBtn.classList.toggle('disabled', state.currentIndex === items.length - 1);
    els.counter.textContent = `${state.currentIndex + 1} / ${items.length}`;
    
    if (item?.caption) {
      els.caption.textContent = item.caption;
      els.caption.classList.add('active');
    } else {
      els.caption.textContent = '';
      els.caption.classList.remove('active');
    }
  };

  const setActive = (active) => {
    els.overlay.classList.toggle('img-lightbox-active', active);
    document.body.style.overflow = active ? 'hidden' : '';
    if (!active) {
      cleanupLoaders();
      reset();
      state.currentGallery = null;
    }
  };

  const loadImage = (index) => {
    const items = getCurrentItems();
    if (index < 0 || index >= items.length) return;

    state.currentIndex = index;
    cleanupLoaders();

    els.loader.style.display = 'block';
    els.image.style.display = 'none';
    reset();

    const item = items[index];
    const id = Symbol();
    state.imageLoadId = id;

    const handleLoad = (success) => {
      if (state.imageLoadId !== id) return;
      
      els.loader.style.display = 'none';
      if (success) {
        els.image.style.display = 'block';
      } else {
        console.error('Failed to load image');
      }
      cleanupLoaders();
    };

    els.image.onload = () => handleLoad(true);
    els.image.onerror = () => handleLoad(false);
    els.image.src = item.src;
    
    updateUI();
  };

  const openGallery = (galleryName, startIndex = 0) => {
    if (!state.galleries[galleryName]) return;
    state.currentGallery = galleryName;
    setActive(true);
    loadImage(startIndex);
  };

  const close = () => setActive(false);

  const navigate = (direction) => {
    const items = getCurrentItems();
    const newIndex = state.currentIndex + direction;
    if (newIndex >= 0 && newIndex < items.length) {
      loadImage(newIndex);
    }
  };

  const onWheel = (e) => {
    if (!els.overlay.classList.contains('img-lightbox-active')) return;
    e.preventDefault();

    const delta = e.deltaY < 0 ? cfg.STEP : -cfg.STEP;
    const old = state.scale;
    state.scale = clamp(state.scale + delta, cfg.MIN, cfg.MAX);

    if (state.scale !== old) {
      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
      } else {
        const ratio = state.scale / old;
        state.translateX = e.clientX - (e.clientX - state.translateX) * ratio;
        state.translateY = e.clientY - (e.clientY - state.translateY) * ratio;
      }
      apply();
      els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
    }
  };

  const onMouseDown = (e) => {
    if (state.scale <= cfg.MIN) return;
    state.isDragging = true;
    state.dragStartX = e.clientX - state.translateX;
    state.dragStartY = e.clientY - state.translateY;
    els.image.style.cursor = 'grabbing';
    e.preventDefault();
  };

  const onMouseMove = (e) => {
    if (!state.isDragging) return;
    state.translateX = e.clientX - state.dragStartX;
    state.translateY = e.clientY - state.dragStartY;
    apply();
  };

  const onMouseUp = () => {
    if (!state.isDragging) return;
    state.isDragging = false;
    els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
  };

  const onDblClick = (e) => {
    e.preventDefault();
    if (state.scale > cfg.MIN) {
      reset();
    } else {
      const rect = els.image.getBoundingClientRect();
      state.scale = 2;
      state.translateX = e.clientX - (e.clientX - rect.left) * 2;
      state.translateY = e.clientY - (e.clientY - rect.top) * 2;
      apply();
      els.image.style.cursor = 'move';
    }
  };

  const onTouchStart = (e) => {
    const t = e.touches;

    if (t.length === 1 && state.scale > cfg.MIN) {
      state.isDragging = true;
      state.dragStartX = t[0].clientX - state.translateX;
      state.dragStartY = t[0].clientY - state.translateY;
    } else if (t.length === 2) {
      e.preventDefault();
      state.isDragging = false;
      state.pinchStart = dist(t[0], t[1]);
      state.scaleStart = state.scale;
    }
  };

  const onTouchMove = (e) => {
    const t = e.touches;

    if (t.length === 1 && state.isDragging) {
      e.preventDefault();
      state.translateX = t[0].clientX - state.dragStartX;
      state.translateY = t[0].clientY - state.dragStartY;
      apply();
    } else if (t.length === 2 && state.pinchStart) {
      e.preventDefault();
      const c = center(t[0], t[1]);
      const ratio = dist(t[0], t[1]) / state.pinchStart;
      const newScale = clamp(state.scaleStart * ratio, cfg.MIN, cfg.MAX);
      const scaleRatio = newScale / state.scale;

      state.scale = newScale;
      state.translateX = c.x - (c.x - state.translateX) * scaleRatio;
      state.translateY = c.y - (c.y - state.translateY) * scaleRatio;

      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
      }

      apply();
    }
  };

  const onTouchEnd = (e) => {
    if (e.touches.length === 0) {
      state.isDragging = false;
      state.pinchStart = 0;
      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
        apply();
      }
    } else if (e.touches.length === 1 && state.scale > cfg.MIN) {
      state.isDragging = true;
      state.dragStartX = e.touches[0].clientX - state.translateX;
      state.dragStartY = e.touches[0].clientY - state.translateY;
      state.pinchStart = 0;
    }
  };

  const onKey = (e) => {
    if (!els.overlay.classList.contains('img-lightbox-active')) return;
    const actions = {
      'Escape': close,
      '0': reset,
      'ArrowLeft': () => navigate(-1),
      'ArrowRight': () => navigate(1)
    };
    actions[e.key]?.();
  };

  const onVisibility = () => {
    if (document.hidden && state.isDragging) {
      state.isDragging = false;
      els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
    }
  };

  const initGalleries = (container = document) => {
    container.querySelectorAll('[data-lightbox-item]:not([data-lb-init])').forEach(item => {
      item.setAttribute('data-lb-init', '');
      const galleryName = item.getAttribute('data-lightbox-item');
      const src = item.getAttribute('data-lightbox-image');
      const caption = item.getAttribute('data-caption') || '';

      if (!state.galleries[galleryName]) {
        state.galleries[galleryName] = [];
      }

      state.galleries[galleryName].push({ src, caption });
    });

    container.querySelectorAll('[data-lightbox-trigger]:not([data-lb-trigger-init])').forEach(trigger => {
      trigger.setAttribute('data-lb-trigger-init', '');
      const galleryName = trigger.getAttribute('data-lightbox-gallery');

      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        if (galleryName && state.galleries[galleryName]) {
          openGallery(galleryName, 0);
        }
      });
    });

    container.querySelectorAll('[data-lightbox-image]:not([data-lightbox-trigger]):not([data-lb-single-init])').forEach(link => {
      link.setAttribute('data-lb-single-init', '');
      const src = link.getAttribute('data-lightbox-image');
      const caption = link.getAttribute('data-caption') || '';

      const singleGalleryName = `single-${Math.random().toString(36).substr(2, 9)}`;
      state.galleries[singleGalleryName] = [{ src, caption }];

      link.addEventListener('click', (e) => {
        e.preventDefault();
        openGallery(singleGalleryName, 0);
      });
    });
  };

  initGalleries();

  const observer = new MutationObserver((mutations) => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        if (node.nodeType === 1) {
          if (node.hasAttribute?.('data-lightbox-item') || node.hasAttribute?.('data-lightbox-trigger')) {
            initGalleries(node.parentElement);
          }
          if (node.querySelectorAll) {
            initGalleries(node);
          }
        }
      }
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });

  const passiveOpt = { passive: false };
  const events = [
    [els.closeBtn, 'click', close],
    [els.prevBtn, 'click', () => navigate(-1)],
    [els.nextBtn, 'click', () => navigate(1)],
    [els.overlay, 'click', (e) => e.target === els.overlay && close()],
    [els.inner, 'click', (e) => e.stopPropagation()],
    [document, 'keydown', onKey],
    [document, 'visibilitychange', onVisibility],
    [els.image, 'wheel', onWheel, passiveOpt],
    [els.image, 'mousedown', onMouseDown],
    [document, 'mousemove', onMouseMove],
    [document, 'mouseup', onMouseUp],
    [els.image, 'dblclick', onDblClick],
    [els.image, 'touchstart', onTouchStart, passiveOpt],
    [els.image, 'touchmove', onTouchMove, passiveOpt],
    [els.image, 'touchend', onTouchEnd],
    [els.image, 'touchcancel', onTouchEnd]
  ];

  events.forEach(([el, type, handler, opts]) => {
    EventManager.addNS(NS, el, type, handler, opts);
  });

  window.addEventListener('beforeunload', () => {
    cleanupLoaders();
    observer.disconnect();
    EventManager.removeNS(NS);
  }, { once: true });
})();

// ========== MAIN BUTTON EVENT ==========
const mainButtonEvent = (() => {
  if (window._eventsAlreadyBound) return;
  window._eventsAlreadyBound = true;

  const buttonBindings = new Map([
    [DOM_ELEMENTS.testSpear, simulateFlash],
    [DOM_ELEMENTS.testReaper, simulateFlash],
    [DOM_ELEMENTS.submit, processMainCalculation],
    [DOM_ELEMENTS.resetRek, () => {
      regenerateRecommendations();
      showSnackbar?.("Table Refreshed!");
    }],
    [DOM_ELEMENTS.resetAll, resetAllData]
  ]);

  window._buttonListenerIds = [];

  buttonBindings.forEach((handler, element) => {
    if (element?.addEventListener) {
      const listenerId = EventManager.add(element, 'click', handler);
      window._buttonListenerIds.push(listenerId);

      if (element === DOM_ELEMENTS.testSpear || element === DOM_ELEMENTS.testReaper) {
        element.classList.remove('activated');
      }
    }
  });
})();

// ========== PWA ==========
const isPWAMode = () => 
  window.matchMedia('(display-mode: standalone)').matches || 
  window.navigator.standalone === true;
const IS_PWA = isPWAMode();
const CONSTANTS = {
  PWA_STORAGE_KEY: 'pwa_snap',
  PWA_EXPIRY_MS: 691200000,
  PWA_RESTORE_DELAY_MS: 200,
  PWA_NAMESPACE: 'pwa_persistence',
  FORM_SELECTORS: 'select, input[type="number"]',
  SCROLL_OFFSET: 80,
  SNACKBAR_DELAY: 300,
  SW_UPDATE_CHECK_DELAY: 500
};
if ('serviceWorker' in navigator) {
  const PWAServiceWorker = (() => {
    let updatePromptShown = false;
    let pendingUpdate = false;
    let isReloading = false;
    let waitingWorker = null;
    
    const saveState = () => {
      if (typeof AppState !== 'undefined' && AppState.get('isResultShown')) {
        return PWAPersistence?.snap?.();
      }
      return false;
    };
    
    const reloadApp = (cacheVersion) => {
      if (isReloading) return;
      isReloading = true;
      
      localStorage.setItem('app_cache_version', cacheVersion);
      saveState();
      
      requestAnimationFrame(() => {
        if (waitingWorker) {
          waitingWorker.postMessage({ action: 'skipWaiting' });
        }
        window.location.reload();
      });
    };
    
    const showUpdatePrompt = (newCache) => {
      if (updatePromptShown) return;
      
      updatePromptShown = true;
      
      if (confirm('Update Available!\nDont worry, your calculated stats wont get reset!')) {
        reloadApp(newCache);
      } else {
        updatePromptShown = false;
        pendingUpdate = false;
      }
    };
    
    const checkCacheVersion = async () => {
      if (updatePromptShown || pendingUpdate || isReloading) {
        return false;
      }
      
      try {
        const cacheNames = await caches.keys();
        
        const currentCache = cacheNames.find(name => name.startsWith('rox-calc-v'));
        
        if (!currentCache) return false;
        
        const storedVersion = localStorage.getItem('app_cache_version');
        
        if (!storedVersion) {
          localStorage.setItem('app_cache_version', currentCache);
          return false;
        }
        
        if (storedVersion === currentCache) {
          return false;
        }
        
        pendingUpdate = true;
        showUpdatePrompt(currentCache);
        return true;
      } catch (e) {
        console.error('[PWA] Check cache error:', e);
        return false;
      }
    };
    
    const setupUpdateListener = (registration) => {
      registration.update();
      
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        waitingWorker = newWorker;
        
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            checkCacheVersion();
          }
        });
      });
    };
    
    const registerSW = () => {
      navigator.serviceWorker.register('/sim/sw.js', {
        scope: '/sim/',
        updateViaCache: 'none'
      })
      .then(reg => {
        if (IS_PWA) setupUpdateListener(reg);
      })
      .catch((err) => {
        console.error('[PWA] SW registration failed:', err);
      });
    };
    
    const handleVisibilityChange = async () => {
      if (document.hidden) return;
      
      const reg = await navigator.serviceWorker.getRegistration('/sim/');
      if (!reg) return;
      
      await reg.update();
      setTimeout(checkCacheVersion, CONSTANTS.SW_UPDATE_CHECK_DELAY);
    };
    
    const initPWAMode = async () => {
      registerSW();
      document.addEventListener('visibilitychange', handleVisibilityChange);
    };
    
    const init = () => {
      window.addEventListener('load', () => {
        IS_PWA ? initPWAMode() : registerSW();
      });
    };
    
    return { init };
  })();
  
  PWAServiceWorker.init();
};


const initA2HS = (() => {
  const CFG = {
    storage: 'a2hsDismissed',
    animDur: 300,
    modalDelay: 3000,
    promptTimeout: 5000,
    dismissExpiry: 259200000,
    app: {
      name: 'RöX Calculator',
      desc: 'Quick access, save stats & work offline',
      icon: 'https://masihterjaga.github.io/sim/icons/a2hs.png'
    },
    devices: {
      ios: {
        title: 'Install this app on your iPhone:',
        steps: [
          'Tap the <strong>"Share" button <svg style="display:inline;width:14px;height:14px;vertical-align:middle" viewBox="0 0 50 50"><path fill="currentColor" d="M30.3 13.7L25 8.4l-5.3 5.3-1.4-1.4L25 5.6l6.7 6.7z"/><path fill="currentColor" d="M24 7h2v21h-2z"/><path fill="currentColor" d="M35 40H15c-1.7 0-3-1.3-3-3V19c0-1.7 1.3-3 3-3h7v2h-7c-.6 0-1 .4-1 1v18c0 .6.4 1 1 1h20c.6 0 1-.4 1-1V19c0-.6-.4-1-1-1h-7v-2h7c1.7 0 3 1.3 3 3v18c0 1.7-1.3 3-3 3z"/></svg></strong>',
          'Scroll and tap <strong>"Add to Home Screen"</strong>',
          'Tap <strong>"Add"</strong> to confirm'
        ]
      },
      android: {
        title: 'Install this app on your device:',
        steps: [
          'Tap the <strong>menu button "⋮"</strong>',
          'Select <strong>"Add to Home Screen"</strong>',
          'Tap <strong>"Add"</strong> or <strong>"Install"</strong>'
        ]
      },
      desktop: {
        title: 'Install this app for quick access:',
        steps: [
          'Click the <strong>browser menu "⋮" or "⋯"</strong>',
          'Look for <strong>"Install"</strong> option',
          'Follow the prompts to install'
        ]
      }
    }
  };
  
  let state = {
    deferredPrompt: null,
    installButton: null,
    promptReceived: false,
    lsAvailable: null
  };
  
  const checkLocalStorage = () => {
    if (state.lsAvailable !== null) return state.lsAvailable;
    
    try {
      const test = '__test__';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      state.lsAvailable = true;
    } catch (e) {
      state.lsAvailable = false;
    }
    
    return state.lsAvailable;
  };
  
  const isInstalled = () => {
    if (window.matchMedia('(display-mode: standalone)').matches) return true;
    if (window.navigator.standalone === true) return true;
    if (document.referrer.includes('android-app://')) return true;
    if (window.matchMedia('(display-mode: fullscreen)').matches) return true;
    if (window.matchMedia('(display-mode: minimal-ui)').matches) return true;
    
    if (checkLocalStorage()) {
      try {
        return localStorage.getItem('app_installed') === 'true';
      } catch (e) {}
    }
    
    return false;
  };
  
  const isDismissed = () => {
    if (!checkLocalStorage()) return true;
    
    try {
      const data = localStorage.getItem(CFG.storage);
      if (!data) return false;
      
      const { timestamp } = JSON.parse(data);
      const isExpired = Date.now() - timestamp > CFG.dismissExpiry;
      
      if (isExpired) {
        localStorage.removeItem(CFG.storage);
        return false;
      }
      
      return true;
    } catch (e) {
      return false;
    }
  };
  
  const setDismissed = () => {
    if (!checkLocalStorage()) return;
    
    try {
      localStorage.setItem(CFG.storage, JSON.stringify({ timestamp: Date.now() }));
    } catch (e) {}
  };
  
  const setInstalled = () => {
    if (!checkLocalStorage()) return;
    
    try {
      localStorage.setItem('app_installed', 'true');
    } catch (e) {}
  };
  
  const detectDevice = () => {
    const ua = navigator.userAgent.toLowerCase();
    if (/iphone|ipad|ipod/.test(ua)) return 'ios';
    if (/android/.test(ua)) return 'android';
    return 'desktop';
  };
  
  const createElement = (tag, className = '', attrs = {}) => {
    const el = document.createElement(tag);
    if (className) el.className = className;
    Object.assign(el, attrs);
    return el;
  };
  
  const buildUI = (device, hasNativePrompt) => {
    const data = CFG.devices[device];
    
    const closeBtn = createElement('button', 'a2hs-close', { 
      'aria-label': 'Close', 
      textContent: '×' 
    });
    
    const img = createElement('img', '', {
      src: CFG.app.icon,
      alt: CFG.app.name,
      loading: 'lazy'
    });
    
    const icon = createElement('div', 'a2hs-icon');
    icon.appendChild(img);
    
    const title = createElement('h2');
    title.textContent = CFG.app.name;
    
    const desc = createElement('p');
    desc.textContent = CFG.app.desc;
    
    const info = createElement('div', 'a2hs-info');
    info.appendChild(title);
    info.appendChild(desc);
    
    const top = createElement('div', 'a2hs-top');
    top.appendChild(icon);
    top.appendChild(info);
    
    const header = createElement('div', 'a2hs-hdr');
    header.appendChild(closeBtn);
    header.appendChild(top);
    
    const instructionTitle = createElement('p', 'a2hs-title');
    instructionTitle.textContent = data.title;
    
    const stepsList = createElement('ol', 'a2hs-steps');
    data.steps.forEach((step, i) => {
      const num = createElement('span');
      num.textContent = (i + 1) + '.';
      
      const text = createElement('span');
      text.innerHTML = step;
      
      const li = createElement('li');
      li.appendChild(num);
      li.appendChild(text);
      stepsList.appendChild(li);
    });
    
    if (hasNativePrompt) {
      const num = createElement('span');
      num.textContent = '4.';
      
      const text = createElement('span');
      text.innerHTML = '<strong>Or tap the button below for quick install</strong>';
      
      const btn = createElement('button', 'a2hs-btn');
      btn.innerHTML = '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>Install App';
      state.installButton = btn;
      
      const li = createElement('li');
      li.appendChild(num);
      li.appendChild(text);
      li.appendChild(btn);
      stepsList.appendChild(li);
    }
    
    const body = createElement('div', 'a2hs-body');
    body.appendChild(instructionTitle);
    body.appendChild(stepsList);
    
    const card = createElement('div', 'a2hs-card');
    card.appendChild(header);
    card.appendChild(body);
    
    const container = createElement('div', 'a2hs');
    container.appendChild(card);
    
    return { container, closeBtn };
  };
  
  const closeModal = (container) => {
    const card = container.firstElementChild;
    card.classList.add('a2hs-closing');
    setTimeout(() => container.remove(), CFG.animDur);
    setDismissed();
  };
  
  const triggerInstall = async () => {
    if (!state.deferredPrompt) return false;
    
    try {
      await state.deferredPrompt.prompt();
      const { outcome } = await state.deferredPrompt.userChoice;
      
      if (outcome === 'accepted') {
        setDismissed();
        setInstalled();
        state.deferredPrompt = null;
        return true;
      }
      
      return false;
    } catch (err) {
      return false;
    }
  };
  
  const showModal = () => {
    if (isInstalled() || isDismissed()) return;
    
    const device = detectDevice();
    const { container, closeBtn } = buildUI(device, state.promptReceived);
    
    document.body.appendChild(container);
    
    if (state.promptReceived) {
      state.installButton.addEventListener('click', async () => {
        const success = await triggerInstall();
        if (success) closeModal(container);
      });
    }
    
    closeBtn.addEventListener('click', () => closeModal(container), { once: true });
  };
  
  const waitForPrompt = () => {
    return new Promise((resolve) => {
      if (state.promptReceived) {
        resolve(true);
        return;
      }
      
      const timeout = setTimeout(() => resolve(false), CFG.promptTimeout);
      
      const checker = setInterval(() => {
        if (state.promptReceived) {
          clearTimeout(timeout);
          clearInterval(checker);
          resolve(true);
        }
      }, 100);
    });
  };
  
  const init = () => {
    if (!checkLocalStorage() || isInstalled()) return;
    
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      state.deferredPrompt = e;
      state.promptReceived = true;
      
      const existingModal = document.querySelector('.a2hs');
      if (existingModal && !state.installButton) {
        existingModal.remove();
        showModal();
      }
    });
    
    window.addEventListener('appinstalled', () => {
      setDismissed();
      setInstalled();
      
      const modal = document.querySelector('.a2hs');
      if (modal) closeModal(modal);
    });
    
    const execute = async () => {
      await new Promise(resolve => setTimeout(resolve, CFG.modalDelay));
      await waitForPrompt();
      showModal();
    };
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', execute, { once: true });
    } else {
      execute();
    }
  };
  
  init();
})();
const preventPullToRefresh = (() => {
  if (!IS_PWA) return { cleanup: () => {} };
  
  let lastY = 0;
  let shouldPrevent = false;
  
  const touchStartHandler = (e) => {
    if (e.touches.length !== 1) return;
    lastY = e.touches[0].clientY;
    shouldPrevent = window.scrollY === 0;
  };
  
  const touchMoveHandler = (e) => {
    if (!shouldPrevent) return;
    
    const deltaY = e.touches[0].clientY - lastY;
    lastY = e.touches[0].clientY;
    
    if (deltaY > 0 && e.cancelable) {
      e.preventDefault();
    }
  };

  const passiveOpt = { passive: false };
  document.addEventListener('touchstart', touchStartHandler, passiveOpt);
  document.addEventListener('touchmove', touchMoveHandler, passiveOpt);
  
  const style = document.createElement('style');
  style.textContent = 'body { overscroll-behavior-y: contain; -webkit-overflow-scrolling: touch; }';
  document.head.appendChild(style);
  
  const cleanup = () => {
    document.removeEventListener('touchstart', touchStartHandler);
    document.removeEventListener('touchmove', touchMoveHandler);
    style?.remove();
  };
  
  return { cleanup };
})();
const PWAPersistenceInit = (() => {
  if (!IS_PWA) return;

  const PWAPersistence = (() => {
    let cachedElements = null;
    
    const getFormElements = () => {
      if (!cachedElements) {
        cachedElements = document.querySelectorAll(CONSTANTS.FORM_SELECTORS);
      }
      return cachedElements;
    };
    
    const collectFormValues = () => {
      const values = {};
      getFormElements().forEach(el => {
        if (el.id && el.value) values[el.id] = el.value;
      });
      return values;
    };
    
    const snap = () => {
      try {
        localStorage.setItem(CONSTANTS.PWA_STORAGE_KEY, JSON.stringify({
          form: collectFormValues(),
          isResultShown: true,
          ts: Date.now()
        }));
        return true;
      } catch (e) {
        return false;
      }
    };
    
    const restore = () => {
      try {
        const saved = localStorage.getItem(CONSTANTS.PWA_STORAGE_KEY);
        if (!saved) return false;
        
        const state = JSON.parse(saved);
        
        if (Date.now() - state.ts > CONSTANTS.PWA_EXPIRY_MS) {
          localStorage.removeItem(CONSTANTS.PWA_STORAGE_KEY);
          return false;
        }
        
        Object.entries(state.form).forEach(([id, val]) => {
          const el = document.getElementById(id);
          if (el) el.value = val;
        });
        
        if (state.isResultShown && typeof processMainCalculation === 'function') {
          setTimeout(processMainCalculation, CONSTANTS.PWA_RESTORE_DELAY_MS);
        }
        
        return true;
      } catch (e) {
        localStorage.removeItem(CONSTANTS.PWA_STORAGE_KEY);
        return false;
      }
    };
    
    return { snap, restore };
  })();
  
  window.PWAPersistence = PWAPersistence;
  
  const handlePWAExit = () => {
    if (AppState.get('isResultShown')) {
      PWAPersistence.snap();
    }
  };
  
  const init = () => {
    PWAPersistence.restore();

    const captureOpt = { capture: true };

    EventManager.addNS(CONSTANTS.PWA_NAMESPACE, document, 'visibilitychange', () => {
      if (document.hidden) {
        handlePWAExit();
      }
    }, captureOpt);
    
    EventManager.addNS(CONSTANTS.PWA_NAMESPACE, window, 'pagehide', handlePWAExit, captureOpt);
  };
  
  document.addEventListener('DOMContentLoaded', () => {
    init();
    if (typeof dropdownManager !== 'undefined' && dropdownManager.init) {
      dropdownManager.scheduleUpdate();
    }
  });
  
  window.clearPWAStorage = () => {
    try {
      localStorage.removeItem(CONSTANTS.PWA_STORAGE_KEY);
      EventManager.removeNS(CONSTANTS.PWA_NAMESPACE);
      return true;
    } catch (e) {
      return false;
    }
  };
})();

// ========== RESET SYSTEM ==========
const ResetHelpers = {
  clearDebounceTimers() {
    if (window.debounceCleanupInterval) {
      clearInterval(window.debounceCleanupInterval);
      window.debounceCleanupInterval = null;
    }
    
    if (window.debounceMap) {
      window.debounceMap.forEach(data => {
        if (data?.timerId) clearTimeout(data.timerId);
      });
      window.debounceMap.clear();
    }
  },

  resetDropdownManager() {
    if (typeof dropdownManager === 'undefined') return;
    
    dropdownManager.state.selectionOrder = [];
    dropdownManager.state.lockStates.clear();
    dropdownManager.state.isSwapping = false;
    
    if (dropdownManager.state.updateTimer) {
      clearTimeout(dropdownManager.state.updateTimer);
      dropdownManager.state.updateTimer = null;
    }
  },

  resetStickyHandler() {
    if (typeof stickyHandler === 'undefined') return;

    if (stickyHandler.scrollRAF) {
      cancelAnimationFrame(stickyHandler.scrollRAF);
      stickyHandler.scrollRAF = null;
    }

    stickyHandler.clearAllTimeouts?.();

    if (stickyHandler.state) {
      stickyHandler.state.isActive = false;
      stickyHandler.state.isCollapsed = false;
      stickyHandler.state.animating = false;
    }

    const buttons = stickyHandler.getOrderedButtons?.() || [];
    buttons.forEach(button => {
      button.classList.remove('sticky', 'collapsed');
      button.style.cssText = '';
      if (button.dataset.originalText) {
        button.textContent = button.dataset.originalText;
      }
    });

    const toggleBtn = stickyHandler.elements?.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  },

  resetValidation() {
    if (typeof ValidationSSoTInstance === 'undefined') return;
    
    ValidationSSoTInstance.touchedFields.clear();
    ValidationSSoTInstance.snackbarCooldowns.clear();
  },

  resetFormInputs() {
    document.querySelectorAll('input[type="number"], input[type="text"], select, textarea').forEach(el => {
      el.value = '';
      el.disabled = false;
      el.classList.remove('invalid-value');

      const wrapper = el.closest('.input-wrap');
      if (wrapper) {
        wrapper.classList.remove('locked');
        delete wrapper.dataset.tempUnlocked;
      }
    });
  },

  resetDisplayContainers() {
    if (DOM_ELEMENTS.hasil) {
      DOM_ELEMENTS.hasil.innerHTML = '';
      DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
      delete DOM_ELEMENTS.hasil.dataset.showFullPrecision;
      delete DOM_ELEMENTS.hasil.dataset.specificMode;
    }

    if (DOM_ELEMENTS.rec) {
      DOM_ELEMENTS.rec.innerHTML = '';
      DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';
    }
  },

  resetButtons() {
    if (DOM_ELEMENTS.submit) {
      DOM_ELEMENTS.submit.disabled = false;
      DOM_ELEMENTS.submit.textContent = "Calculate";
    }

    [DOM_ELEMENTS.resetRek, DOM_ELEMENTS.resetAll, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.testReaper]
      .forEach(btn => {
        if (btn) {
          btn.disabled = true;
          btn.classList.remove('activated');
        }
      });
  },

  cleanupStickyStates() {
    document.querySelectorAll('.sticky').forEach(el => {
      el.classList.remove('sticky', 'collapsed');
      el.style.cssText = '';
      if (el.dataset.originalText) {
        el.textContent = el.dataset.originalText;
      }
    });

    const toggleBtn = document.getElementById('toggleStickyBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  },

  resetSnackbar() {
    if (DOM_ELEMENTS.snackbar) {
      DOM_ELEMENTS.snackbar.classList.remove('show');
      DOM_ELEMENTS.snackbar.style.cssText = '';
    }
    delete window._lastSnackbarTime;
  },

  reinitializeComponents() {
    if (typeof dropdownManager !== 'undefined' && dropdownManager.init) {
      dropdownManager.populateAllDropdowns();
      dropdownManager.updateAll();
      dropdownManager.syncThreeSets();
    }

    ValidationSSoTInstance?.init?.();
    stickyHandler?.updateSticky?.();
  },

  scrollToTop(smooth = true) {
    if (DOM_ELEMENTS.topOfPage) {
      const offsetTop = DOM_ELEMENTS.topOfPage.getBoundingClientRect().top + 
        window.pageYOffset - CONSTANTS.SCROLL_OFFSET;
      window.scrollTo({ top: offsetTop, behavior: smooth ? 'smooth' : 'auto' });
    } else {
      window.scrollTo({ top: 0, behavior: smooth ? 'smooth' : 'auto' });
    }
  }
};
const CleanupManager = (() => {
  let isCleaningUp = false;
  
  const cleanupListeners = () => {
    if (typeof EventManager !== 'undefined') {
      EventManager.forceCleanup?.();
      EventManager.removeAll?.();
    }
    
    AppState?.clearListeners?.();
    
    if (window._buttonListenerIds && typeof EventManager !== 'undefined') {
      window._buttonListenerIds.forEach(id => EventManager.remove?.(id));
      window._buttonListenerIds = [];
    }
  };
  
  const cleanupTimers = () => {
    ResetHelpers.clearDebounceTimers();
  };
  
  const cleanupManagers = () => {
    ValidationSSoTInstance?.destroy?.();
    TooltipManager?.destroyAll?.();
    SnackbarManager?.cleanup?.();
    dropdownManager?.destroy?.();
    stickyHandler?.destroy?.();
    accordionManager?.destroy?.();
    modalManager?.destroy?.();
  };
  
  const cleanupCache = () => {
    cache?.clear?.();
    RandomGenerator?.reset?.();
    
    delete window._eventsAlreadyBound;
    delete window._lastSnackbarTime;
  };
  
  const cleanupAll = () => {
    if (isCleaningUp) return;
    isCleaningUp = true;
    
    try {
      cleanupListeners();
      cleanupTimers();
      cleanupManagers();
      cleanupCache();
    } finally {
      isCleaningUp = false;
    }
  };
  
  return { 
    cleanupListeners, 
    cleanupTimers, 
    cleanupManagers, 
    cleanupCache, 
    cleanupAll 
  };
})();
function clearCache(type = null) {
  if (type) {
    cache.clear(type);
  } else {
    cache.clear();
    cache.rewarm();
    RandomGenerator.reset();
  }
};
function resetAllData() {
  if (!confirm('Reset all data and inputs?')) return;

  const shouldClearCache = confirm('Also clear calculation cache?');

  if (shouldClearCache) {
    cache.clear();
    cache.rewarm();
    RandomGenerator.reset();
  }
  
  localStorage.removeItem(CONSTANTS.PWA_STORAGE_KEY);
  
  AppState.reset();
  ResetHelpers.clearDebounceTimers();
  ResetHelpers.resetDropdownManager();
  ResetHelpers.resetStickyHandler();
  ResetHelpers.resetValidation();
  
  SnackbarManager?.cleanup?.();
  
  ResetHelpers.resetFormInputs();
  ResetHelpers.resetDisplayContainers();
  ResetHelpers.resetButtons();
  ResetHelpers.cleanupStickyStates();
  ResetHelpers.resetSnackbar();
  ResetHelpers.reinitializeComponents();
  ResetHelpers.scrollToTop();

  const message = shouldClearCache ? 'All data and cache cleared!' : 'All data reset!';
  setTimeout(() => showSnackbar?.(message), CONSTANTS.SNACKBAR_DELAY);
};

// ========
EventManager.add(window, 'beforeunload', () => {
  CleanupManager.cleanupListeners();
  CleanupManager.cleanupTimers();
});