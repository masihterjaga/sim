/**
 * I don’t care how long this code is or whether it’s efficient — it was all generated by AI anyway. Even this line generated by AI too, lol.
*/
// ========== DOM CACHE ==========
const DOM_ELEMENTS = {
  topOfPage: document.getElementById('top'),
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  blueSet: document.getElementById("blueSet"),
  blueSetLabel: document.getElementById("blueSetLabel"),
  vesperSet: document.getElementById("vesperSet"),
  vesperSetLabel: document.getElementById("vesperSetLabel"),
  whiteSet: document.getElementById("whiteSet"),
  whiteSetLabel: document.getElementById("whiteSetLabel"),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  attack: document.getElementById('attack'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmgStack: document.getElementById('dmgStack'),
  dmgStackTips: document.getElementById('dmgStackTips'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeEnhLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  testSpear: document.getElementById('testSpear'),
  testReaper: document.getElementById('testReaper'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog"),
  stickyStart: document.getElementById("stickyStart")
};

// ========== DATA CONSTANTS ==========
const VESPER_SET = {
  0: 8,
  1: 16,
  2: 24,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64,
  8: 72,
  9: 80
};
const BLUE_SET = {
  3: {
    30: 5,
    40: 7.5,
    50: 10,
    60: 12.5,
    70: 15,
    80: 17.5,
    90: 20,
    100: 22.5,
    110: 25,
    120: 27.5,
    130: 30,
    140: 32.5,
    150: 35
  /**
   * 
  },
  8: {
    30: 5,
    40: 10,
    50: 15,
    60: 20,
    70: 25,
    80: 30,
    90: 35,
    100: 40,
    110: 45,
    120: 50,
    130: 55,
    140: 60,
    150: 65
   */
  }
};
const WHITE_SET = {
  "Tier 0": 30,
  "Tier 1": 36,
  "Tier 2": 42,
  "Tier 3": 48,
  "Tier 4": 54
};
const RACE_TYPES = [
  "Angel", 
  "Demon", 
  "Formless", 
  "Insect", 
  "Fish", 
  "Demi-Human", 
  "Undead", 
  "Dragon", 
  "Plant", 
  "Brute"
];
// Defense Stats From Nila
const DEFENSE_TABLE = {
  "DUMMY": {
    def: 0,
    dmgred: 0
  },
  "Avg. MVP Lvl.130": {
    def: 182.27,
    dmgred: 148.10
  },
  "Avg. MINI Lvl.130": {
    def: 206.45,
    dmgred: 165.52
  },
  "Avg. MVP MINI Lvl.130": {
    def: 194.36,
    dmgred: 156.81
  },
  "Avg. MVP Lvl.140": {
    def: 155.32,
    dmgred: 191.35
  },
  "Avg. MINI Lvl.140": {
    def: 161.41,
    dmgred: 233.48
  },
  "Avg. MVP MINI Lvl.140": {
    def: 158.37,
    dmgred: 212.41
  },
  "Avg. MVP Lvl.150": {
    def: 191.03,
    dmgred: 283.92
  },
  "Avg. MINI Lvl.150": {
    def: 198.53,
    dmgred: 324.23
  },
  "Avg. MVP MINI Lvl.150": {
    def: 194.78,
    dmgred: 304.08
  },
  "Avg. Small MVP Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small"
  },
  "Avg. Medium MVP Lv.140": {
    def: 199.62,
    dmgred: 195.88,
    sizeMob: "Medium"
  },
  "Avg. Large MVP Lv.140": {
    def: 143.05,
    dmgred: 184.84,
    sizeMob: "Large"
  },
  "Avg. Small MINI Lv.140": {
    def: 161.12,
    dmgred: 225.97,
    sizeMob: "Small"
  },
  "Avg. Medium MINI Lv.140": {
    def: 148.23,
    dmgred: 212.13,
    sizeMob: "Medium"
  },
  "Avg. Large MINI Lv.140": {
    def: 178.61,
    dmgred: 267.37,
    sizeMob: "Large"
  },
  "Avg. Small MVP Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small"
  },
  "Avg. Medium MVP Lv.150": {
    def: 240.07,
    dmgred: 273.72,
    sizeMob: "Medium"
  },
  "Avg. Large MVP Lv.150": {
    def: 177.51,
    dmgred: 282.29,
    sizeMob: "Large"
  },
  "Avg. Small MINI Lv.150": {
    def: 198.01,
    dmgred: 312.15,
    sizeMob: "Small"
  },
  "Avg. Medium MINI Lv.150": {
    def: 182.88,
    dmgred: 304.72,
    sizeMob: "Medium"
  },
  "Avg. Large MINI Lv.150": {
    def: 219.08,
    dmgred: 359.67,
    sizeMob: "Large"
  },
  "Phreeoni Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mistress Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eddga Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Kraken Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Maya Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Orc Hero Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Pharaoh Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Shadow"
  },
  "Orc Lord Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Doppelganger Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Amon Ra Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Morroc Lv.140": {
    def: 131.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Time Holder Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Tao Gunka Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Lost Dragon Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Fallen Bishop Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Lord of the Dead Lv.140": {
    def: 131.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Arc Angeling Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Gioia Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Wind"
  },
  "RSX-0806 Lv.140": {
    def: 238.66,
    dmgred: 202.00,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Neutral"
  },
  "Nidhoggr's Shadow Lv.140": {
    def: 181.21,
    dmgred: 134.00,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Gloom Under Night Lv.140": {
    def: 306.00,
    dmgred: 300.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Ghost"
  },
  "Retribution Lv.140": {
    def: 256.50,
    dmgred: 300.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Shadow"
  },
  "Dragon Fly Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eclipse Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mastering Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Plant",
    attributeMob: "Water"
  },
  "Ghostring Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Toad Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Small",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "King Dramoh Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Angeling Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Deviling Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Dark Priest Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Undead"
  },
  "Vagabond Wolf Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Brute",
    attributeMob: "Earth"
  },
  "Chimera Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Mysteltainn Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Ogretooth Lv.140": {
    def: 212.68,
    dmgred: 306.35,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Necromancer Lv.140": {
    def: 131.97,
    dmgred: 150.75,
    sizeMob: "Medium",
    raceMob: "Undead",
    attributeMob: "Undead"
  },
  "Coelacanth Lv.140": {
    def: 139.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Naght Sieger Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Observation Lv.140": {
    def: 146.68,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Neutral"
  },
  "Skeggiold Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Small",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Queen Scaraba Lv.140": {
    def: 212.30,
    dmgred: 268.70,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Faceworm Queen Lv.140": {
    def: 245.30,
    dmgred: 268.70,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Poison"
  },
  "Ktullanux Lv.140": {
    def: 256.50,
    dmgred: 542.27,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Water"
  },
  "Shelter Lv.140": {
    def: 251.18,
    dmgred: 258.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Phreeoni Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mistress Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eddga Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Kraken Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Maya Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Orc Hero Lv.150": {
    def: 110.67,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Pharaoh Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Shadow"
  },
  "Orc Lord Lv.150": {
    def: 110.67,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Doppelganger Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Amon Ra Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Morroc Lv.150": {
    def: 169.17,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Time Holder Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Tao Gunka Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Lost Dragon Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Fallen Bishop Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Lord of the Dead Lv.150": {
    def: 169.17,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Arc Angeling Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Gioia Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Wind"
  },
  "RSX-0806 Lv.150": {
    def: 293.16,
    dmgred: 317.00,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Neutral"
  },
  "Nidhoggr's Shadow Lv.150": {
    def: 228.13,
    dmgred: 266.00,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Gloom Under Night Lv.150": {
    def: 357.57,
    dmgred: 367.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Ghost"
  },
  "Retribution Lv.150": {
    def: 299.07,
    dmgred: 367.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Shadow"
  },
  "Dragon Fly Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eclipse Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mastering Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Plant",
    attributeMob: "Water"
  },
  "Ghostring Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Toad Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Small",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "King Dramoh Lv.150": {
    def: 110.67,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Angeling Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Deviling Lv.150": {
    def: 110.66,
    dmgred: 261.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Dark Priest Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Undead"
  },
  "Vagabond Wolf Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Brute",
    attributeMob: "Earth"
  },
  "Chimera Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Mysteltainn Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Ogretooth Lv.150": {
    def: 259.48,
    dmgred: 385.89,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Necromancer Lv.150": {
    def: 169.17,
    dmgred: 272.00,
    sizeMob: "Medium",
    raceMob: "Undead",
    attributeMob: "Undead"
  },
  "Coelacanth Lv.150": {
    def: 175.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Naght Sieger Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Observation Lv.150": {
    def: 181.48,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Neutral"
  },
  "Skeggiold Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Small",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Queen Scaraba Lv.150": {
    def: 258.55,
    dmgred: 351.40,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Faceworm Queen Lv.150": {
    def: 297.55,
    dmgred: 351.40,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Poison"
  },
  "Ktullanux Lv.150": {
    def: 299.07,
    dmgred: 575.77,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Water"
  },
  "Shelter Lv.150": {
    def: 293.16,
    dmgred: 317.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  }
};
const ELEMENT_COUNTER_TABLE = {
  Neutral: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 1,
    Shadow: 1,
    Ghost: 0.70,
    Undead: 1
  },
  Fire: {
    Neutral: 1,
    Fire: 0.25,
    Water: 1,
    Earth: 1.25,
    Wind: 1,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1.125
  },
  Water: {
    Neutral: 1,
    Fire: 1.25,
    Water: 0.25,
    Earth: 1,
    Wind: 0.90,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Earth: {
    Neutral: 1,
    Fire: 0.90,
    Water: 1,
    Earth: 0.25,
    Wind: 1.25,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Wind: {
    Neutral: 1,
    Fire: 1,
    Water: 1.375,
    Earth: 0.90,
    Wind: 0.25,
    Poison: 1,
    Holy: 0.70,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Poison: {
    Neutral: 1,
    Fire: 1.125,
    Water: 1,
    Earth: 1.125,
    Wind: 1.125,
    Poison: 0,
    Holy: 0.75,
    Shadow: 0.50,
    Ghost: 1,
    Undead: -0.25
  },
  Holy: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 0,
    Shadow: 1.375,
    Ghost: 1,
    Undead: 1.375
  },
  Shadow: {
    Neutral: 1.125,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 0.50,
    Holy: 1.375,
    Shadow: 0,
    Ghost: 1,
    Undead: -0.25
  },
  Ghost: {
    Neutral: 0.90,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 0.75,
    Shadow: 0.75,
    Ghost: 1.375,
    Undead: 1
  },
  Undead: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 0.50,
    Holy: 1.375,
    Shadow: 0,
    Ghost: 1.25,
    Undead: 0
  }
};
const WEAPON_SIZE_MODIFIER_TABLE = {
  "Empty Handed": {
    Large: 0.5,
    Medium: 0.5,
    Small: 0.5
  },
  "One-Handed Sword": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Two-Handed Sword": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Two-Handed Spear": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Dagger": {
    Large: 0.75,
    Medium: 0.75,
    Small: 1
  },
  "Katar": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Light Knuckle": {
    Large: 0.75,
    Medium: 0.75,
    Small: 1
  },
  "Heavy Knuckle": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "GS": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Ninja Sword": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Huuma Shuriken": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Tome": {
    Large: 0.75,
    Medium: 1,
    Small: 1
  },
  "Book": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Two-Handed Rod": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "One-Handed Rod": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Mace": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "One-Handed Axe": {
    Large: 0.75,
    Medium: 0.75,
    Small: 0.75
  },
  "Two-Handed Axe": {
    Large: 0.5,
    Medium: 0.75,
    Small: 0.75
  },
  "Bow": {
    Large: 0.75,
    Medium: 1,
    Small: 1
  },
  "Instrument": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Whip": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  }
};

// ========== CENTRALIZED STATE ==========
const AppState = (() => {
  const state = {
    isResultShown: false,
    isTestReaperActive: false,
    isTestSpearActive: false,
    isFlashActive: false,
    keyboardListenersAdded: false,
    currentAnimatingWeapon: null
  };
  const listeners = new Set();
  let cleanupInterval = null;

  const toggleCleanup = (start) => {
    if (start && !cleanupInterval) {
      cleanupInterval = setInterval(() => listeners.size === 0 && (clearInterval(cleanupInterval), cleanupInterval = null), 60000);
    } else if (!start && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  return {
    get: (key) => state[key],
    set: (key, value) => {
      if (state[key] === value) return false;
      const old = state[key];
      state[key] = value;
      listeners.forEach(fn => {
        try {
          fn(key, value, old);
        } catch {
          listeners.delete(fn);
        }
      });
      return true;
    },
    reset: () => Object.keys(state).forEach(k => state[k] = typeof state[k] === 'boolean' ? false : null),
    subscribe: (fn) => {
      if (typeof fn !== 'function') return () => {};
      listeners.add(fn);
      listeners.size === 1 && toggleCleanup(true);
      return () => (listeners.delete(fn), listeners.size === 0 && toggleCleanup(false));
    },
    clearListeners: () => (listeners.clear(), toggleCleanup(false)),
    getListenerCount: () => listeners.size
  };
})();

// ========== EVENT MANAGER ==========
const EventManager = (() => {
  const listenersByElement = new WeakMap();
  const listenersById = new Map();
  const namespaces = new Map();
  let id = 0,
    cleanupInterval = null;

  const toggleCleanup = (start) => {
    if (start && !cleanupInterval) {
      cleanupInterval = setInterval(() => {
        Array.from(listenersById.entries())
          .filter(([, l]) => !l?.el || !(l.el instanceof Node) || !document.contains(l.el))
          .forEach(([listenerId]) => remove(listenerId));
      }, 30000);
    } else if (!start && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  const add = (el, evt, handler, opts = false) => {
    if (!el?.addEventListener) return null;
    const listenerId = ++id;
    el.addEventListener(evt, handler, opts);
    listenersById.set(listenerId, {
      el,
      evt,
      handler,
      opts
    });

    if (!listenersByElement.has(el)) listenersByElement.set(el, new Set());
    listenersByElement.get(el).add(listenerId);
    listenersById.size === 1 && toggleCleanup(true);
    return listenerId;
  };

  const remove = (listenerId) => {
    const listener = listenersById.get(listenerId);
    if (!listener) return false;

    const {
      el,
      evt,
      handler,
      opts
    } = listener;
    try {
      el?.removeEventListener?.(evt, handler, opts);
    } catch {}
    listenersById.delete(listenerId);

    try {
      const elementListeners = listenersByElement.get(el);
      elementListeners?.delete(listenerId);
      elementListeners?.size === 0 && listenersByElement.delete(el);
    } catch {}

    listenersById.size === 0 && toggleCleanup(false);
    return true;
  };

  const removeFromElement = (el) => {
    if (!el) return 0;
    try {
      const elementListeners = listenersByElement.get(el);
      if (!elementListeners) return 0;
      return Array.from(elementListeners).reduce((count, id) => count + (remove(id) ? 1 : 0), 0);
    } catch {
      return 0;
    }
  };

  const addNS = (namespace, el, evt, handler, opts = false) => {
    const listenerId = add(el, evt, handler, opts);
    if (!listenerId) return null;
    if (!namespaces.has(namespace)) namespaces.set(namespace, new Set());
    namespaces.get(namespace).add(listenerId);
    return listenerId;
  };

  const removeNS = (namespace) => {
    const nsListeners = namespaces.get(namespace);
    if (!nsListeners) return 0;
    const count = Array.from(nsListeners).reduce((c, id) => c + (remove(id) ? 1 : 0), 0);
    namespaces.delete(namespace);
    return count;
  };

  const removeAll = () => {
    toggleCleanup(false);
    listenersById.forEach(({
      el,
      evt,
      handler,
      opts
    }) => {
      try {
        el?.removeEventListener?.(evt, handler, opts);
      } catch {}
    });
    listenersById.clear();
    namespaces.clear();
  };

  const forceCleanup = () => {
    const toRemove = Array.from(listenersById.entries())
      .filter(([, l]) => !l?.el || !(l.el instanceof Node) || !document.contains(l.el))
      .map(([id]) => id);
    toRemove.forEach(remove);
    return toRemove.length;
  };

  return {
    add,
    remove,
    removeFromElement,
    addNS,
    removeNS,
    removeAll,
    forceCleanup
  };
})();

// ========== OPTIMIZED CACHE ==========
const cache = (() => {
  const stores = {
    weaponSize: new Map(),
    elementCounter: new Map(),
    defenseData: new Map()
  };

  const warm = () => {
    Object.entries(WEAPON_SIZE_MODIFIER_TABLE).forEach(([w, sizes]) =>
      Object.entries(sizes).forEach(([s, v]) => stores.weaponSize.set(`${w}:${s}`, v)));
    Object.entries(ELEMENT_COUNTER_TABLE).forEach(([w, targets]) =>
      Object.entries(targets).forEach(([t, v]) => stores.elementCounter.set(`${w}:${t}`, v)));
    Object.entries(DEFENSE_TABLE).forEach(([k, v]) => stores.defenseData.set(k, v));
  };

  warm();
  return {
    get: (type, key) => stores[type]?.get(key),
    clear: (type) => type ? stores[type]?.clear() : Object.values(stores).forEach(s => s.clear()),
    rewarm: warm
  };
})();

// ========== RANDOM GENERATOR ==========
const RandomGenerator = (() => {
  const SIZE = 500;
  let cache = new Float64Array(SIZE),
    idx = 0;
  const refill = () => {
    for (let i = 0; i < SIZE; i++) cache[i] = Math.random();
    idx = 0;
  };
  refill();
  return {
    get: () => (idx >= SIZE && refill(), cache[idx++]),
    reset: refill
  };
})();

// ========== HELPER FUNCTIONS ==========
const getWeaponSizeModifier = (weapon, size) => weapon === 'all' || !weapon ? WEAPON_SIZE_MODIFIER_TABLE : cache.get('weaponSize', `${weapon}:${size}`) ?? 1.0;
const getElementCounter = (weaponElem, targetElem) => weaponElem === 'all' || !weaponElem ? ELEMENT_COUNTER_TABLE : cache.get('elementCounter', `${weaponElem}:${targetElem || 'Neutral'}`) ?? 1.0;
const getTargetDefenseData = (key) => !key ? DEFENSE_TABLE : cache.get('defenseData', key) || DEFENSE_TABLE["DUMMY"];

// ========== CALCULATION CORE ==========
const processMainCalculation = (() => {
  let timeoutId = null;
  let calculationRAF = null;
  let isProcessing = false;
  let executionId = 0;

  const resetUI = () => {
    DOM_ELEMENTS.submit.disabled = false;
    DOM_ELEMENTS.submit.textContent = "Calculate";
  };

  const setCalculatingUI = () => {
    DOM_ELEMENTS.submit.disabled = true;
    DOM_ELEMENTS.submit.textContent = "Calculating...";
  };

  const cleanup = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
    if (calculationRAF !== null) {
      cancelAnimationFrame(calculationRAF);
      calculationRAF = null;
    }
  };

  const enableResultButtons = () => {
    [DOM_ELEMENTS.testReaper, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.resetRek, DOM_ELEMENTS.resetAll]
    .forEach(btn => {
      if (btn) btn.disabled = false;
    });
  };

  const performCalculation = (calculationState) => {
    AppState.set('isResultShown', true);
    lockAllInputs();
    bindInputLockGuard();
    renderMultiplierBreakdown(calculationState);
    generateRecommendationTable(calculationState);
    enableResultButtons();
  };

  const handleCalculationError = (error) => {
    console.error('Calculation error:', error);
    resetUI();

    if (typeof showSnackbar === 'function') {
      showSnackbar('Calculation failed. Please check your inputs.');
    }
  };

  return () => {
    if (isProcessing) return;

    cleanup();

    if (!validateRequiredFields()) {
      resetUI();
      return;
    }

    isProcessing = true;
    executionId++;
    const currentId = executionId;

    setCalculatingUI();

    timeoutId = setTimeout(() => {
      timeoutId = null;

      if (currentId !== executionId) return;

      calculationRAF = requestAnimationFrame(() => {
        calculationRAF = null;

        if (currentId !== executionId) return;

        try {
          const calculationState = getCurrentCalculationState();

          if (!validateStatsVsTarget(calculationState)) {
            resetUI();
            return;
          }

          performCalculation(calculationState);

          DOM_ELEMENTS.submit.disabled = true;
          DOM_ELEMENTS.submit.textContent = "Calculate";

        } catch (error) {
          handleCalculationError(error);
        } finally {
          if (currentId === executionId) {
            isProcessing = false;
          }
        }
      });
    }, 300);
  };
})();
function getCurrentCalculationState() {
  const safeNum = (el) => el ? (Number(el.value) || 0) : 0;
  const safeStr = (el) => el?.value || '';

  // Attack Type & Weapon (DOM row 1, cols 1-3)
  const atkType = safeStr(DOM_ELEMENTS.atkType);
  const weapon = safeStr(DOM_ELEMENTS.weapon);
  const wElem = safeStr(DOM_ELEMENTS.wElem);

  // Target Properties (DOM row 1, cols 4-7)
  const tDefKey = safeStr(DOM_ELEMENTS.tDef);
  const tSize = safeStr(DOM_ELEMENTS.tSize);
  const tRace = safeStr(DOM_ELEMENTS.tRace);
  const tAttr = safeStr(DOM_ELEMENTS.tAttr);

  // Equipment Sets (DOM row 1, cols 8-10)
  const vesper = safeNum(DOM_ELEMENTS.vesperSet);
  const vesperTier = vesper ? ((vesper - 8) / 8) : -1;

  // Extract blue set values
  let blue3 = 0,
    blue8 = 0;
  const blueSet = DOM_ELEMENTS.blueSet;
  if (blueSet?.selectedIndex >= 0) {
    const selectedOption = blueSet.options[blueSet.selectedIndex];
    if (selectedOption) {
      const blueValue = safeNum(blueSet);
      const optionText = selectedOption.textContent;
      if (optionText.includes('*3')) {
        blue3 = blueValue;
      } else if (optionText.includes('*8')) {
        blue8 = blueValue;
      }
    }
  }

  const white = safeNum(DOM_ELEMENTS.whiteSet);

  // Stats (DOM row 2, follows field order)
  const baseAttack = safeNum(DOM_ELEMENTS.attack);
  /**
   * Experimental, keep this
  const vesperAttackMultiplier = vesperTier >= 0 ? (1 + (0.03 + vesperTier * 0.03)) : 1;
  const baseAttack = rawBaseAttack * vesperAttackMultiplier;
   */

  const pen = safeNum(DOM_ELEMENTS.pen);
  const crit = safeNum(DOM_ELEMENTS.crit);
  const dmg = safeNum(DOM_ELEMENTS.dmg);
  const elemEnh = safeNum(DOM_ELEMENTS.elemEnh);
  const sizeEnh = safeNum(DOM_ELEMENTS.sizeEnh);
  const race = safeNum(DOM_ELEMENTS.race);
  const attr = safeNum(DOM_ELEMENTS.attr);
  const dmgStack = safeNum(DOM_ELEMENTS.dmgStack);

  // Test equipment bonuses
  const isReaperActive = AppState.get('isTestReaperActive');
  const reaperValue = isReaperActive ? ((wElem === tAttr) || (wElem === "Neutral" && !tAttr) ? 84 : 28) : 0;

  const isSpearActive = AppState.get('isTestSpearActive');
  const spearValue = isSpearActive ? 84 : 0;

  const state = {
    baseAttack,
    // rawBaseAttack,
    // vesperAttackMultiplier,
    atkType,
    pen,
    crit,
    dmg,
    sizeEnh,
    elemEnh,
    race,
    attr,
    weapon,
    tSize,
    wElem,
    tAttr,
    tRace,
    tDefKey,
    vesper,
    white,
    dmgStack,
    blue3,
    blue8,
    reaperValue,
    spearValue
  };

  const result = calculateMultiplier({
    ...state,
    extras: {
      vesper: state.vesper,
      white: state.white,
      dmgStack: state.dmgStack,
      blue3: state.blue3,
      blue8: state.blue8,
      reaperValue: state.reaperValue,
      spearValue: state.spearValue
    }
  });

  return {
    ...state,
    ...result
  };
}
function calculateMultiplier(params={}) {
  const { baseAttack,
    atkType,
    pen,
    crit,
    dmg,
    sizeEnh,
    elemEnh,
    race,
    attr,
    weapon,
    tSize,
    wElem,
    tAttr,
    tRace,
    tDefKey,
    extras = {}
  } = params;

  
  const EXTRA_LABELS = {
    vesper: 'Vesper',
    blue3: 'BlueGroup3',
    white: 'White',
    dmgStack: 'Final DMG Bonus',
    reaperValue: 'Reaper',
    blue8: 'BlueGroup8',
    spearValue: 'Spear'
  };


  const {
    def,
    dmgred
  } = getTargetDefenseData(tDefKey);

  // Calculate attack factor (PEN or CRIT mode)
  let atkF = 0;
  if (atkType === 'crit') {
    atkF = (crit || 0) / 100;
  } else if (atkType === 'pen') {
    const rawPen = (pen || 0) - (def || 0);
    if (rawPen > 0) {
      atkF = (rawPen >= 150 ? (rawPen * 2 - 150) : rawPen) / 100;
    }
  }

  const effDmgVal = dmg - dmgred;
  const sizeMod = getWeaponSizeModifier(weapon, tSize);
  const elemCtr = getElementCounter(wElem, tAttr);

  // Base multiplier calculation
  const baseMult = (baseAttack || 1) *
    (1 + atkF) *
    (1 + effDmgVal / 100) *
    (sizeMod + sizeEnh / 100) *
    (elemCtr + elemEnh / 100) *
    (1 + (tAttr ? attr / 100 : 0)) *
    (1 + (tRace ? race / 100 : 0));

  // Process extra modifiers (two separate groups)
  const processExtras = (keys, type) => {
    const items = [];
    const rawValues = [];

    keys.forEach(key => {
      const value = extras[key] || 0;
      if (value > 0) {
        const normalized = value / 100;
        items.push({
          key: EXTRA_LABELS[key],
          type,
          value: normalized
        });
        rawValues.push(normalized);
      }
    });

    const sum = rawValues.reduce((acc, val) => acc + val, 0);
    return {
      items,
      sum,
      factor: 1 + sum
    };
  };

  const extra1 = processExtras(['vesper', 'blue3', 'white', 'dmgStack', 'reaperValue'], 'extra1');
  const extra2 = processExtras(['blue8', 'spearValue'], 'extra2');
  const mult = baseMult * extra1.factor * extra2.factor; 
  // ===== COMPARISON CALCULATIONS =====
  const spearVal = (extras.spearValue || 0) / 100;
  const reaperVal = (extras.reaperValue || 0) / 100;

  const extra1FactorNoReaper = 1 + (extra1.sum - reaperVal);
  const extra2FactorNoSpear = 1 + (extra2.sum - spearVal);

  const multNoSpear = baseMult * extra1.factor * extra2FactorNoSpear;
  const multNoReaper = baseMult * extra1FactorNoReaper * extra2.factor;
  const multNoReaperSpear = baseMult * extra1FactorNoReaper * extra2FactorNoSpear;

  const pctSpear = multNoSpear > 0 ? ((mult - multNoSpear) / multNoSpear * 100) : 0;
  const pctReaper = multNoReaper > 0 ? ((mult - multNoReaper) / multNoReaper * 100) : 0;
  const pctReaperSpear = multNoReaperSpear > 0 ? ((mult - multNoReaperSpear) / multNoReaperSpear * 100) : 0;
  // ===== END COMPARISON CALCULATIONS =====

  // Build result groups for breakdown
  const resultGroups = [...extra1.items];
  extra1.sum > 0 && resultGroups.push({
    type: 'extra1',
    sum: extra1.sum,
    factor: extra1.factor
  });
  resultGroups.push(...extra2.items);
  extra2.sum > 0 && resultGroups.push({
    type: 'extra2',
    sum: extra2.sum,
    factor: extra2.factor
  });

  const isPenMode = atkType === 'pen';
  const includeRace = !!(tRace && race > 0);
  const includeAttr = !!(tAttr && attr > 0);
  const includeExtra = extra1.sum > 0;
  const includeExtraTwo = extra2.sum > 0;

  // Build factor list (order matches calculation flow)
  const factorList = [{
      key: 'baseAtk',
      label: 'Attack',
      val: baseAttack,
      mult: baseAttack || 1
      /**
       * Experimental, keep!
      raw: params.rawBaseAttack,
      vesperMult: params.vesperAttackMultiplier
      */
    },
    {
      key: 'main',
      label: isPenMode ? 'Type (PEN)' : 'Type (CRIT)',
      val: isPenMode ? pen : crit,
      mult: 1 + atkF
    },
    {
      key: 'dmg',
      label: 'Final P/M DMG BNS',
      val: dmg,
      mult: 1 + effDmgVal / 100
    },
    {
      key: 'elem',
      label: 'Element',
      val: elemEnh,
      mult: elemCtr + elemEnh / 100,
      extra: `counter ${elemCtr}`
    },
    {
      key: 'size',
      label: 'Size',
      val: sizeEnh,
      mult: sizeMod + sizeEnh / 100,
      extra: `mod ${sizeMod}`
    },
    {
      key: 'race',
      label: 'Race',
      val: race,
      mult: 1 + race / 100,
      show: includeRace
    },
    {
      key: 'attr',
      label: 'Attribute',
      val: attr,
      mult: 1 + attr / 100,
      show: includeAttr
    },
    {
      key: 'extra',
      label: 'Extra#1',
      val: extra1.sum,
      mult: extra1.factor,
      show: includeExtra
    },
    {
      key: 'extraTwo',
      label: 'Extra#2',
      val: extra2.sum,
      mult: extra2.factor,
      show: includeExtraTwo
    },
    {
      key: 'contribution',
      label: 'Flash Contribution',
      show: pctSpear > 0 || pctReaper > 0
    }
  ];

  return {
    mult,
    pctSpear,
    pctReaper,
    pctReaperSpear,
    def,
    dmgred,
    effDmgVal,
    atkF,
    sizeModifier: sizeMod,
    elementCounter: elemCtr,
    breakdownData: {
      factorList,
      isPenMode,
      includeRace,
      includeAttr,
      includeExtra,
      includeExtraTwo
    },
    parts: {
      baseMult,
      extraGroups: resultGroups,
      extra1Factor: extra1.factor,
      extra2Factor: extra2.factor,
      extra1Sum: extra1.sum,
      extra2Sum: extra2.sum
    }
  };
}

// ======== BREAKDOWN ========
function renderMultiplierBreakdown(calculationState) {
  if (!AppState.get('isResultShown')) return;

  const resultContainer = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";

  // Format helpers
  const fmt = (n) => NumberFormatter.format(n, showFullPrecision);
  const fmtWithData = (n) => `<span data-raw-value="${n}">${fmt(n)}</span>`;

  // Destructure state
  const {
    mult,
    def,
    dmgred,
    pen,
    crit,
    dmg,
    wElem,
    tAttr,
    tSize,
    weapon,
    atkType,
    tRace,
    vesper,
    blue3,
    blue8,
    white,
    tDefKey,
    elementCounter,
    sizeModifier,
    parts = {},
    breakdownData = {}
  } = calculationState;

  const {
    extraGroups = [], extra1Factor = 1, extra2Factor = 1
  } = parts;
  const {
    factorList = [], isPenMode = false
  } = breakdownData;

  const LABELS = {
    'Vesper': 'Vesper SET',
    'BlueGroup3': 'Blue SET (Ferocity)',
    'BlueGroup8': 'Blue SET',
    'White': 'White SET (110*3)',
    'Reaper': 'Reaper Scythe',
    'Spear': 'Divinity#1 Flash: Spear of Eternity'
  };

  // Group extras by type
  const extras = {
    extra1: {
      items: [],
      factor: extra1Factor
    },
    extra2: {
      items: [],
      factor: extra2Factor
    }
  };

  extraGroups.forEach(group => {
    const type = group.type;
    if ('sum' in group && 'factor' in group) {
      extras[type].factor = group.factor;
    } else if ('key' in group && 'value' in group) {
      extras[type].items.push(group);
    }
  });

  // Check if line is a note
  const isNote = (text) =>
    text.includes('Tools assume') || text.includes('uptime') ||
    text.includes('Elements') || text.includes('This bonus');

  // Build HTML list items
  const buildLines = (lines) =>
    lines.map(line => `<li${isNote(line) ? ' class="note"' : ''}>${line}</li>`).join('');

  // Build extra bonus section (Extra#1 or Extra#2)
  function buildExtraSection(extraType, title, state) {
    const extraData = extras[extraType];
    const lines = [];
    const values = [];

    extraData.items.forEach(item => {
      const label = LABELS[item.key] || item.key;
      const valPercent = fmtWithData(item.value * 100);

      if (item.key === 'Reaper') {
        lines.push(
          `${label}: ${state.wElem} vs ${state.tAttr || 'Neutral'} <button type="button" id="reaperTips" class="tooltip-button"></button>`,
          `${valPercent} / 100`
        );
      } else if (item.key === 'Spear') {
        lines.push(
          `${LABELS[item.key]} <button type="button" id="spearTips" class="tooltip-button"></button>`,
          `${valPercent} / 100`
        );
      } else {
        let display = `${label}: ${valPercent}`;

        switch (item.key) {
          case 'Vesper':
            if (state.vesper) display = `${label}: Tier ${(state.vesper-8)/8}`;
            break;
          case 'BlueGroup3':
            if (state.blue3) display = `${label}: Level ${4*state.blue3+10}*3`;
            break;
          case 'White':
            if (state.white) display = `${label}: Tier ${(state.white-30)/6}`;
            break;
          case 'BlueGroup8':
            if (state.blue8) display = `${label}: ${state.blue8}%`;
            break;
        }

        lines.push(display, `${valPercent} / 100`);
      }
      values.push(fmtWithData(item.value));
    });

    const valuesDisplay = values.join(' + ');
    lines.push(`1 + ${valuesDisplay} \u2192 <code data-raw-mult="${extraData.factor}">\u00D7${fmt(extraData.factor)}</code>`);

    return {
      title,
      lines
    };
  }

  // Build individual factor breakdown
  function buildFactor(factor, state) {
    if (factor.show === false && factor.key !== 'contribution') {
      return {
        html: `<li>${factor.label}: \u00D71.00 (no stat)</li>`,
        mult: `1.00 (no ${factor.label.toLowerCase()})`
      };
    }

    let factorData = null;

    switch (factor.key) {
      case 'baseAtk':
        return {
          html: '', mult: fmt(factor.mult)
        };
        /*
        * Experimental, not relevant. but keep this
        if (factor.vesperMult && factor.vesperMult > 1) {
          const tier = Math.round((state.vesper - 8) / 8);
          factorData = {
            title: 'Attack (Vesper Boosted)',
            lines: [
              `Base Attack: ${factor.raw}`,
              `Vesper Tier ${tier} Bonus: \u00D7${fmt(factor.vesperMult)}`,
              `${factor.raw} \u00D7 ${fmt(factor.vesperMult)} \u2192 <code>${factor.val}</code>`
            ]
          };
        } else {
          return {
            html: `<li>Attack: ${factor.val}</li>`,
            mult: fmt(factor.mult)
          };
        }
        */

      case 'main':
        if (!state.isPenMode) {
          factorData = {
            title: `Attack Type: CRIT vs ${state.tDefKey}`,
            lines: [
              `Crit DMG: ${fmtWithData(state.crit)}`,
              `1.00 + ( ${fmtWithData(state.crit)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
            ]
          };
        } else {
          const lines = [
            `Raw PEN + Final PEN: ${fmtWithData(state.pen)}`,
            `Target DEF: ${fmtWithData(state.def)}`
          ];

          const rawBasePen = state.pen - state.def;
          if (rawBasePen >= 150) {
            lines.push(
              `1.00 + ((( ${fmtWithData(state.pen)} - ${fmtWithData(state.def)} ) \u00D7 2 ) - 150 ) / 100`,
              `1.00 + ( ${fmtWithData((rawBasePen * 2) - 150)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
            );
          } else {
            lines.push(`1.00 + (( ${fmtWithData(state.pen)} - ${fmtWithData(state.def)} ) / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`);
          }

          factorData = {
            title: `Attack Type: PEN vs ${state.tDefKey}`,
            lines
          };
        }
        break;

      case 'dmg':
        factorData = {
          title: 'Final P/M Damage Bonus',
          lines: [
            `P/M BO: ${fmtWithData(state.dmg)}`,
            `Target Reduction: ${fmtWithData(state.dmgred)}`,
            `1.00 + (( ${fmtWithData(state.dmg)} - ${fmtWithData(state.dmgred)} ) / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'elem':
        factorData = {
          title: `Element: ${state.wElem} vs ${state.tAttr || "Neutral<button type='button' id='elemCtrTips' class='tooltip-button'></button>"}`,
          lines: [
            `Counter: ${fmtWithData(state.elementCounter)}`,
            `${state.wElem} Enhance: ${fmtWithData(factor.val)}`,
            `${fmtWithData(state.elementCounter)} + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'size':
        factorData = {
          title: `Size: ${state.weapon} vs ${state.tSize}`,
          lines: [
            `Modifier: ${fmtWithData(state.sizeModifier)}`,
            `${state.tSize} Enhance: ${fmtWithData(factor.val)}`,
            `${fmtWithData(state.sizeModifier)} + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'race':
        factorData = {
          title: `Race: ${state.tRace}`,
          lines: [
            `DMG to ${state.tRace}: ${fmtWithData(factor.val)}`,
            `1.00 + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'attr':
        factorData = {
          title: `Attribute: ${state.tAttr}`,
          lines: [
            `DMG to ${state.tAttr} Attribute: ${fmtWithData(factor.val)}`,
            `1.00 + ( ${fmtWithData(factor.val)} / 100 ) \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code>`
          ]
        };
        break;

      case 'extra':
        factorData = buildExtraSection('extra1', 'Extra#1: Final DMG Bonus', state);
        break;

      case 'extraTwo':
        factorData = buildExtraSection('extra2', 'Extra#2: Bonus DMG to MVP/MINI', state);
        break;

      case 'contribution':
        const hasSpear = state.pctSpear > 0;
        const hasReaper = state.pctReaper > 0;

        if (!hasSpear && !hasReaper) {
          return {
            html: '',
            mult: ''
          };
        }

        const formatBoost = (value) => `<code>\u2248${Math.trunc(value/2)}%</code>`;
        const createLine = (label, value) => `${label}: ${formatBoost(value)}`;

        const lines = [];
        if (hasSpear && hasReaper) {
          lines.push(
            createLine('Spear Flash', state.pctSpear) + ' damage boost.',
            createLine('Reaper Flash', state.pctReaper) + ' damage boost.',
            `Both flashes gives you ${formatBoost(state.pctReaperSpear)} total damage increase.`
          );
        } else if (hasSpear) {
          lines.push(`Spear Flash boost: ${formatBoost(state.pctSpear)}`);
        } else {
          lines.push(`Reaper Flash boost: ${formatBoost(state.pctReaper)}`);
        }

        factorData = {
          title: "How Much Flash Boosts Your Damage<button type='button' id='flashTips' class='tooltip-button'></button>",
          lines
        };
        break;

      default:
        return {
          html: `<li>${factor.label}: ${fmtWithData(factor.val)} \u2192 <code data-raw-mult="${factor.mult}">\u00D7${fmt(factor.mult)}</code></li>`,
            mult: fmt(factor.mult)
        };
    }

    const html = `<li>${factorData.title}<ul>${buildLines(factorData.lines)}</ul></li>`;
    return {
      html,
      mult: fmt(factor.mult)
    };
  }

  // Process all factors
  const factorHTML = [];
  const multiplierParts = [];
  const stateContext = {
    ...calculationState,
    extras,
    LABELS,
    isPenMode
  };

  factorList.forEach((factor, i) => {
    const result = buildFactor(factor, stateContext);

    factorHTML.push(result.html);
    if (factor.key === 'contribution') return;

    multiplierParts.push((i === 0 ? '' : '\u00D7 ') + result.mult);
  });

  // Prepare UI components
  const targetInfo = [tSize, tRace, tAttr].filter(Boolean).join(" + ");

  /**
   * 
  const bq1Text = "By default, every factor starts at \u00D71.00. Numbers show how it changes with your stats.\n\nValues shown to two decimal places for readability. The final result is computed with full precision(";
  const bq1Suffix = document.createTextNode("), so it may differ slightly if you recompute using the displayed (rounded) numbers.");
   */
  const bq1Text = `By default, every factor starts at \u00D71.00<button type='button' id='breakdownTips' class='tooltip-button'></button>\nNumbers`;
  const bq1Suffix = document.createTextNode(" how it changes with your stats.");

  const precisionBtn = PrecisionToggle.create(
    resultContainer,
    (showFullPrecision) => {
      PrecisionToggle.refreshNumbers(resultContainer, showFullPrecision);
    }
  );

  const swapSelect = dropdownManager.createSwapSelect(calculationState, isPenMode);

  // Cleanup old event listeners
  resultContainer.querySelectorAll('[data-listener-id]').forEach(el => {
    const id = el.dataset.listenerId;
    id && EventManager.remove(parseInt(id));
  });

  // Render HTML
  resultContainer.innerHTML = `
    <div class="multiplier-breakdown" id="multiplier-breakdown">
      <blockquote class="noted">${bq1Text.replace(/\n/g, '<br>')}</blockquote>
      <ul class="factor-breakdown">${factorHTML.join('')}</ul>
      <hr class="separ">
      <div class="breakdown-swap-wrapper" id="swap-wrapper"></div>
      <p class="sum-head">Your base multiplier to <i>${targetInfo} (${tDefKey})</i></p>
      <div class="last-calc">${multiplierParts.join(" ")}<br>\u2248<code data-raw-mult="${mult}">\u00D7${fmt(mult)}</code><button type="button" id="attackTips" class="tooltip-button"></button></div>
      <blockquote class="noted">Only base multipliers! Real output depends on class, skills, buffs (vesper, blue, or white stack), and more. More accurate? Just use <a class="job-sim" target="_blank" href="//discord.com/channels/784407151342256148/909016309218541568/1407521807459811328">job sim!</a></blockquote>
    </div>`;

  // Attach components to DOM
  const bq1 = resultContainer.querySelector('.noted');
  bq1.appendChild(precisionBtn);
  bq1.appendChild(bq1Suffix);
  resultContainer.querySelector('#swap-wrapper').appendChild(swapSelect);
}
const NumberFormatter = {
  format(n, showFullPrecision) {
    const num = Number(n) || 0;
    const isInteger = num % 1 === 0;
    const absNum = Math.abs(num);

    if (showFullPrecision) {
      if (absNum >= 99999) return Math.floor(num).toString();
      if (isInteger) return num.toString();

      const str = num.toFixed(6).replace(/(\.\d*?)0+$/, '$1');
      if (str.endsWith('.')) return num.toFixed(2);

      const parts = str.split('.');
      if (parts[1] && parts[1].length === 1) return num.toFixed(2);

      return str;
    }

    if (absNum > 99999) {
      const divisor = absNum >= 1e6 ? 1e6 : 1e3;
      const suffix = divisor === 1e6 ? 'M' : 'K';
      return `${Math.floor(num / divisor)}${suffix}`;
    }

    if (isInteger) return num.toString();
    return num.toFixed(2);
  }
};
const PrecisionToggle = {
  create(resultContainer, onToggleCallback) {
    const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";

    const btn = document.createElement('button');
    btn.className = 'toggle-precision job-sim';
    btn.type = 'button';
    btn.textContent = showFullPrecision ? "hide" : "show";

    const listenerId = EventManager.add(btn, 'click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!resultContainer?.dataset) return;

      const newState = resultContainer.dataset.showFullPrecision === "1" ? "0" : "1";
      resultContainer.dataset.showFullPrecision = newState;

      btn.textContent = newState === "1" ? "hide" : "show";

      onToggleCallback(newState === "1");

      typeof showSnackbar === 'function' &&
        showSnackbar(newState === "1" ? "Precise numbers displayed" : "Rounded numbers displayed");
    });

    btn.dataset.listenerId = listenerId;
    return btn;
  },

  refreshNumbers(resultContainer, showFullPrecision) {
    const fmt = (n) => NumberFormatter.format(n, showFullPrecision);

    resultContainer.querySelectorAll('[data-raw-value]').forEach(el => {
      const rawValue = parseFloat(el.dataset.rawValue);
      el.textContent = fmt(rawValue);
    });

    resultContainer.querySelectorAll('code[data-raw-mult]').forEach(el => {
      const rawMult = parseFloat(el.dataset.rawMult);
      el.textContent = `\u00D7${fmt(rawMult)}`;
    });
  }
};

// ========== RECOMMENDATION ==========
function generateRecommendationTable(gameState) {
  if (!AppState.get('isResultShown')) return;

  // Random value generator with jitter
  const generateRandomValue = (baseValue, jitter = RECOMMENDATION_CONFIG.jitter) => {
    const {
      randomMode,
      clampMaxFraction,
      clampMaxAbsolute
    } = RECOMMENDATION_CONFIG;

    if (randomMode === 'clamp') {
      const delta = (RandomGenerator.get() * 2 - 1) * jitter;
      const maxClamp = Math.min(clampMaxFraction * jitter, clampMaxAbsolute);
      const clampedDelta = Math.max(Math.min(delta, maxClamp), -maxClamp);
      return Math.max(0, baseValue * (1 + clampedDelta));
    }

    if (randomMode === 'normal') {
      let u1 = 0,
        u2 = 0;
      while (u1 === 0) u1 = RandomGenerator.get();
      while (u2 === 0) u2 = RandomGenerator.get();
      const normalValue = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return Math.max(0, baseValue * (1 + normalValue * jitter * 0.5));
    }

    return Math.max(0, baseValue * (1 + (RandomGenerator.get() * 2 - 1) * jitter));
  };

  // Adjust small combined race/attr values
  const applySmallValueAdjustment = (value, raceValue, attrValue) => {
    const {
      smallThreshold,
      smallExp,
      smallMin
    } = RECOMMENDATION_CONFIG;
    const combinedTotal = raceValue + attrValue;
    return (combinedTotal > 0 && combinedTotal < smallThreshold) ?
      Math.max(Math.pow(value, smallExp), smallMin) :
      value;
  };

  // Get max allowed value with tolerance
  const getMaxAllowedValue = (userValue, capLimit, tolerance, isSmall) =>
    userValue >= capLimit ? (isSmall ? capLimit + tolerance : userValue + tolerance) : capLimit;

  // Avoid hitting exact cap limit
  const avoidCapLimit = (value, capLimit) =>
    value < capLimit ? value : capLimit - (capLimit * (0.01 + RandomGenerator.get() * 0.02));

  // Avoid round multiples of 10
  const avoidRoundTen = (value) => {
    const rounded = Math.round(value);
    return rounded % 10 === 0 ? rounded + 1 : rounded;
  };

  // Get cell CSS class based on comparison
  const getCellClass = (currentValue, baseValue) => {
    const diff = Math.round(+currentValue || 0) - Math.round(+baseValue || 0);
    const threshold = RECOMMENDATION_CONFIG.upDownThreshold;
    return diff >= threshold ? 'up' : diff <= -threshold ? 'down' : 'neutral';
  };

  const isPenetrationMode = gameState.atkType === 'pen';
  const tRace = gameState.tRace,
    tAttr = gameState.tAttr;
  const raceVal = +gameState.race || 0,
    attrVal = +gameState.attr || 0;
  const shouldIncludeRace = !!tRace && raceVal > 0;
  const shouldIncludeAttr = !!tAttr && attrVal > 0;
  const originalMultiplier = +gameState.mult || 1;
  const baseAttackValue = +gameState.baseAttack || 1;

  // User's current stats - cache all conversions
  const userStats = {
    main: isPenetrationMode ? (+gameState.pen || 0) : (+gameState.crit || 0),
    dmg: +gameState.dmg || 0,
    size: +gameState.sizeEnh || 0,
    elem: +gameState.elemEnh || 0,
    attr: shouldIncludeAttr ? attrVal : 0,
    race: shouldIncludeRace ? raceVal : 0
  };

  // Calculate stat weights for recommendation algorithm
  const statWeights = calculateRecommendationWeights({
    includeRace: shouldIncludeRace,
    includeAttr: shouldIncludeAttr,
    baseMain: userStats.main,
    baseDmg: userStats.dmg,
    baseElem: userStats.elem,
    baseSize: userStats.size,
    baseRace: userStats.race,
    baseAttr: userStats.attr
  });

  const {
    centerScale,
    raceAttrCap,
    smallThreshold,
    raceAttrSoloCap,
    raceAttrTol,
    ratioMin,
    ratioMax,
    maxAttempts,
    jitter,
    jitterStep,
    jitterStepEvery,
    jitterMax
  } = RECOMMENDATION_CONFIG;

  // Center values around weighted means
  const centeredValues = {
    main: userStats.main * (1 + statWeights.main * centerScale),
    dmg: userStats.dmg * (1 + statWeights.dmg * centerScale),
    elem: userStats.elem * (1 + statWeights.elem * centerScale),
    size: userStats.size * (1 + statWeights.size * centerScale)
  };

  // Adjust race/attr for small combined totals - consolidated
  const raceAttrSum = userStats.race + userStats.attr;
  const adjustedRace = shouldIncludeRace ? applySmallValueAdjustment(userStats.race, userStats.race, userStats.attr) : 0;
  const adjustedAttr = shouldIncludeAttr ? applySmallValueAdjustment(userStats.attr, userStats.race, userStats.attr) : 0;

  const raceAttrValues = {
    race: shouldIncludeRace ? Math.min(adjustedRace * (1 + statWeights.race * centerScale), raceAttrCap) : 0,
    attr: shouldIncludeAttr ? Math.min(adjustedAttr * (1 + statWeights.attr * centerScale), raceAttrCap) : 0,
    adjustedRace,
    adjustedAttr
  };

  // Base extras (equipment bonuses) - cache object
  const baseExtras = {
    blue3: +gameState.blue3 || 0,
    blue8: +gameState.blue8 || 0,
    vesper: +gameState.vesper || 0,
    white: +gameState.white || 0,
    dmgStack: +gameState.dmgStack || 0,
    reaperValue: +gameState.reaperValue || 0,
    spearValue: +gameState.spearValue || 0
  };

  // Select appropriate categories based on race/attr totals
  const hasSmallCombined = shouldIncludeRace && shouldIncludeAttr && raceAttrSum > 0 && raceAttrSum < smallThreshold;
  const categories = hasSmallCombined ? RECOMMENDATION_CONFIG.forSmallCats : RECOMMENDATION_CONFIG.cats;

  // Build column headers (follows DOM field order) - optimized with conditional push
  const mainStatLabel = isPenetrationMode ? 'PEN' : 'CRIT';
  const columnHeaders = ['STAT', mainStatLabel, 'P/M BO', 'Element', 'Size'];
  shouldIncludeRace && columnHeaders.push('Race');
  shouldIncludeAttr && columnHeaders.push('Attribute');
  columnHeaders.push('Multiplier', '\u2206');

  const tablesHTML = [];
  const headerRow = columnHeaders.map(h => `<th>${h}</th>`).join('');

  // Pre-calculate common values for race/attr generation
  const userTotal = userStats.race + userStats.attr;
  const boostedTotal = raceAttrValues.adjustedRace + raceAttrValues.adjustedAttr;
  const isSmallTotal = userTotal > 0 && userTotal < smallThreshold;
  const maxTotal = shouldIncludeRace && shouldIncludeAttr ? getMaxAllowedValue(userTotal, raceAttrCap, raceAttrTol, isSmallTotal) : 0;

  // Cache single stat values
  const userSingle = shouldIncludeRace ? userStats.race : userStats.attr;
  const boostedSingle = shouldIncludeRace ? raceAttrValues.adjustedRace : raceAttrValues.adjustedAttr;
  const isSmallSingle = userSingle > 0 && userSingle < smallThreshold;
  const maxSingle = (shouldIncludeRace || shouldIncludeAttr) && !(shouldIncludeRace && shouldIncludeAttr) ?
    getMaxAllowedValue(userSingle, raceAttrSoloCap, raceAttrTol, isSmallSingle) :
    0;

  // Cache gameState properties used in calculateMultiplier
  const calcParams = {
    baseAttack: baseAttackValue,
    atkType: isPenetrationMode ? 'pen' : 'crit',
    weapon: gameState.weapon || '',
    tSize: gameState.tSize || '',
    wElem: gameState.wElem || '',
    tAttr: tAttr || '',
    tRace: tRace || '',
    tDefKey: gameState.tDefKey || '',
    extras: baseExtras
  };

  // Generate recommendation tables for each category
  for (let catIdx = 0, catLen = categories.length; catIdx < catLen; catIdx++) {
    const category = categories[catIdx];
    const uniqueKeys = new Set();
    const uniqueDeltas = new Set();
    const uniqueComposites = new Set();
    const acceptedRows = [];
    let attempts = 0,
      currentJitter = jitter;

    // Generate unique recommendations with adaptive jitter
    while (acceptedRows.length < 5 && attempts < maxAttempts) {
      attempts++;

      // Generate random stat values - reuse object
      const statValues = {
        pen: +gameState.pen || 0,
        crit: +gameState.crit || 0,
        dmg: generateRandomValue(centeredValues.dmg, currentJitter),
        elem: generateRandomValue(centeredValues.elem, currentJitter),
        size: generateRandomValue(centeredValues.size, currentJitter)
      };

      statValues[isPenetrationMode ? 'pen' : 'crit'] = generateRandomValue(centeredValues.main, currentJitter);

      let raceValue = 0,
        attrValue = 0;

      // Handle race/attr allocation - optimized branching
      if (shouldIncludeAttr && shouldIncludeRace) {
        const randomTotal = avoidCapLimit(Math.min(generateRandomValue(boostedTotal, currentJitter), maxTotal), maxTotal);
        const ratio = ratioMin + RandomGenerator.get() * (ratioMax - ratioMin);
        raceValue = randomTotal * ratio;
        attrValue = randomTotal * (1 - ratio);

        // Scale down if exceeds max total
        const actualSum = raceValue + attrValue;
        if (actualSum > maxTotal) {
          const scale = avoidCapLimit(maxTotal, maxTotal) / actualSum;
          raceValue *= scale;
          attrValue *= scale;
        }
      } else if (shouldIncludeRace || shouldIncludeAttr) {
        const generatedValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingle, currentJitter), maxSingle), maxSingle);
        shouldIncludeRace ? (raceValue = generatedValue) : (attrValue = generatedValue);
      }

      // Calculate new multiplier with generated stats
      const {
        mult: calculatedMultiplier
      } = calculateMultiplier({
        ...calcParams,
        pen: +statValues.pen || 0,
        crit: +statValues.crit || 0,
        dmg: +statValues.dmg || 0,
        sizeEnh: +statValues.size || 0,
        elemEnh: +statValues.elem || 0,
        race: +raceValue || 0,
        attr: +attrValue || 0
      });

      // Combined filters with early exit
      const ratio = calculatedMultiplier / originalMultiplier;
      if (calculatedMultiplier <= originalMultiplier || ratio < category.min || ratio > category.max) continue;

      // Round and avoid multiples of 10
      const mainVal = avoidRoundTen(isPenetrationMode ? statValues.pen : statValues.crit);
      const dmgVal = avoidRoundTen(statValues.dmg);
      const elemVal = avoidRoundTen(statValues.elem);
      const sizeVal = avoidRoundTen(statValues.size);
      const rVal = shouldIncludeRace ? avoidRoundTen(raceValue) : null;
      const aVal = shouldIncludeAttr ? avoidRoundTen(attrValue) : null;

      // Uniqueness checks - optimized string building
      const rStr = rVal || '-',
        aStr = aVal || '-';
      const rowKey = `${mainVal}|${dmgVal}|${elemVal}|${sizeVal}|${rStr}|${aStr}`;
      const compositeKey = `${mainVal}|${dmgVal}|${elemVal}|${sizeVal}|${rVal}|${aVal}`;

      if (uniqueKeys.has(rowKey) || uniqueComposites.has(compositeKey)) continue;

      const deltaPercent = ((calculatedMultiplier - originalMultiplier) / originalMultiplier) * 100;
      const roundedDelta = Number(deltaPercent.toFixed(1));
      if (uniqueDeltas.has(roundedDelta)) continue;

      // Filter: at least one stat must be lower - optimized conditional
      if (mainVal > userStats.main && dmgVal > userStats.dmg && elemVal > userStats.elem && sizeVal > userStats.size &&
        (!shouldIncludeRace || rVal > userStats.race) && (!shouldIncludeAttr || aVal > userStats.attr)) continue;

      // Accept this recommendation
      uniqueKeys.add(rowKey);
      uniqueDeltas.add(roundedDelta);
      uniqueComposites.add(compositeKey);

      acceptedRows.push({
        main: mainVal,
        dmg: dmgVal,
        elem: elemVal,
        size: sizeVal,
        attr: aVal,
        race: rVal,
        newMultiplier: calculatedMultiplier,
        deltaPercent
      });

      // Increase jitter adaptively if struggling to find recommendations
      if (acceptedRows.length < 5 && attempts % jitterStepEvery === 0) {
        currentJitter = Math.min(currentJitter + jitterStep, jitterMax);
      }
    }

    if (acceptedRows.length === 0) continue;

    // Sort by improvement percentage, then multiplier, then main stat
    acceptedRows.sort((a, b) =>
      b.deltaPercent - a.deltaPercent || b.newMultiplier - a.newMultiplier || b.main - a.main
    );

    // Build table rows - optimized array building
    const tableRows = acceptedRows.map((row, i) => {
      const cells = [
        `<td class="build">BUILD#${i + 1}</td>`,
        `<td><span class="${getCellClass(row.main, userStats.main)}">${row.main}</span></td>`,
        `<td><span class="${getCellClass(row.dmg, userStats.dmg)}">${row.dmg}</span></td>`,
        `<td><span class="${getCellClass(row.elem, userStats.elem)}">${row.elem}</span></td>`,
        `<td><span class="${getCellClass(row.size, userStats.size)}">${row.size}</span></td>`
      ];

      shouldIncludeRace && cells.push(`<td><span class="${getCellClass(row.race, userStats.race)}">${row.race}</span></td>`);
      shouldIncludeAttr && cells.push(`<td><span class="${getCellClass(row.attr, userStats.attr)}">${row.attr}</span></td>`);

      cells.push(
        `<td class="mult">\u00D7${row.newMultiplier.toFixed(2)}</td>`,
        `<td class="delta">+${row.deltaPercent.toFixed(1)}%</td>`
      );

      return `<tr>${cells.join('')}</tr>`;
    }).join('');

    // Build "your stats" row - optimized with same pattern
    const yourStatsCells = [
      '<td class="yours-label">YOURS</td>',
      `<td><span>${userStats.main}</span></td>`,
      `<td><span>${userStats.dmg}</span></td>`,
      `<td><span>${userStats.elem}</span></td>`,
      `<td><span>${userStats.size}</span></td>`
    ];

    shouldIncludeRace && yourStatsCells.push(`<td><span>${userStats.race}</span></td>`);
    shouldIncludeAttr && yourStatsCells.push(`<td><span>${userStats.attr}</span></td>`);

    yourStatsCells.push(
      `<td class="mult current-mult">\u00D7${gameState.mult.toFixed(2)}</td>`,
      `<td id="table-help" class="delta current-delta"><button type='button' id='tableTips' class='tooltip-button'></button></td>`
    );

    const yourStatsRow = `<tr class="your-stats-values">${yourStatsCells.join('')}</tr>`;

    tablesHTML.push(
      `<div class="table-wrapper"><table class="recommend-table"><caption>Increase ${category.label}</caption><tr>${headerRow}</tr><tbody>${tableRows}${yourStatsRow}</tbody></table></div>`
    );
  }

  DOM_ELEMENTS.rec.innerHTML = tablesHTML.join('');
}
const calculateRecommendationWeights = (params) => {
  if (!AppState.get('isResultShown')) return;

  const {
    includeRace,
    includeAttr,
    baseMain,
    baseDmg,
    baseElem,
    baseSize,
    baseRace,
    baseAttr
  } = params;
  const {
    bias,
    smallExp,
    smallMin,
    raceAttrCap
  } = RECOMMENDATION_CONFIG;

  // Calculate weighted values for core stats
  const weights = [
    baseMain * bias.main,
    baseDmg * bias.dmg,
    baseElem * bias.elem,
    baseSize * bias.size
  ];

  const maxWeight = Math.max(...weights, 1);
  const coreSum = Math.max(weights.reduce((sum, w) => sum + w / maxWeight, 0), 0.0001);

  // Allocate weight share between core and additional stats
  const hasAdditional = includeRace || includeAttr;
  const coreShare = hasAdditional ? 0.75 : 1.0;

  const finalWeights = {
    main: (weights[0] / maxWeight / coreSum) * coreShare,
    dmg: (weights[1] / maxWeight / coreSum) * coreShare,
    elem: (weights[2] / maxWeight / coreSum) * coreShare,
    size: (weights[3] / maxWeight / coreSum) * coreShare,
    race: 0,
    attr: 0
  };

  // If no additional stats, normalize and return
  if (!hasAdditional) {
    const totalSum = Object.values(finalWeights).reduce((a, b) => a + b, 0);
    Object.keys(finalWeights).forEach(k => finalWeights[k] /= totalSum);
    return finalWeights;
  }

  // Handle race/attr weight distribution - optimized
  const additionalShare = 1 - coreShare;
  const effectiveRace = includeRace ? Math.max(Math.pow(baseRace, smallExp), smallMin) : 0;
  const effectiveAttr = includeAttr ? Math.max(Math.pow(baseAttr, smallExp), smallMin) : 0;
  const raceAvailable = includeRace && effectiveRace > 0 && effectiveRace < raceAttrCap;
  const attrAvailable = includeAttr && effectiveAttr > 0 && effectiveAttr < raceAttrCap;

  if (raceAvailable && attrAvailable) {
    const combinedSum = effectiveRace + effectiveAttr;
    finalWeights.race = (effectiveRace / combinedSum) * additionalShare;
    finalWeights.attr = (effectiveAttr / combinedSum) * additionalShare;
  } else if (raceAvailable) {
    finalWeights.race = additionalShare;
  } else if (attrAvailable) {
    finalWeights.attr = additionalShare;
  } else {
    // Redistribute to core stats if no additional stats qualify
    const redistribution = additionalShare * 0.25;
    ['main', 'dmg', 'elem', 'size'].forEach(k => finalWeights[k] += redistribution);
  }

  // Final normalization
  const totalSum = Object.values(finalWeights).reduce((a, b) => a + b, 0);
  Object.keys(finalWeights).forEach(k => finalWeights[k] /= totalSum);

  return finalWeights;
};
const regenerateRecommendations = () => {
  AppState.get('isResultShown') && (generateRecommendationTable(getCurrentCalculationState()), showSnackbar?.("Table Refreshed!"));
};

// Recommendation  configuration
const RECOMMENDATION_CONFIG = {
  randomMode: 'clamp',
  maxAttempts: 500,
  centerScale: 0.25,
  jitter: 0.12,
  jitterStep: 0.025,
  jitterStepEvery: 35,
  jitterMax: 0.50,
  clampMaxFraction: 3.5,
  clampMaxAbsolute: 0.20,
  upDownThreshold: 3,
  raceAttrCap: 310,
  raceAttrSoloCap: 250,
  raceAttrTol: 6,
  smallThreshold: 115,
  smallMin: 85,
  smallExp: 0.75,
  ratioMin: 0.32,
  ratioMax: 0.64,
  ratioNoise: 0.12,
  bias: {
    main: 1.0,
    dmg: 0.95,
    elem: 0.90,
    size: 0.90,
    race: 0.72,
    attr: 0.72
  },
  cats: [{
      label: '6-12%',
      min: 1.06,
      max: 1.12
    },
    {
      label: '18-24%',
      min: 1.18,
      max: 1.24
    },
    {
      label: '32-48%',
      min: 1.32,
      max: 1.48
    },
    {
      label: '64-128%',
      min: 1.64,
      max: 2.28
    }
  ],
  forSmallCats: [{
      label: '84-168%',
      min: 1.84,
      max: 2.68
    },
    {
      label: '180-270%',
      min: 2.80,
      max: 3.70
    },
    {
      label: '320-480%',
      min: 4.32,
      max: 5.80
    },
    {
      label: '510-720%',
      min: 6.10,
      max: 8.20
    }
  ]
}

// ========== FLASH SYSTEM ==========
const isMobile = () => window.innerWidth < 480;
const debounceMap = new Map();
let debounceCleanupInterval = null;
const startDebounceCleanup = () => {
  if (debounceCleanupInterval) return;

  debounceCleanupInterval = setInterval(() => {
    const now = Date.now();
    const expiredEntries = Array.from(debounceMap.entries())
      .filter(([, data]) => !data || (data.timestamp && now - data.timestamp > 10000));

    expiredEntries.forEach(([key, data]) => {
      if (data?.timerId) clearTimeout(data.timerId);
      debounceMap.delete(key);
    });

    if (debounceMap.size === 0) {
      clearInterval(debounceCleanupInterval);
      debounceCleanupInterval = null;
    }
  }, 5000);
};
const smoothDebounce = (fn, delay, key) => {
  const existing = debounceMap.get(key);

  if (existing?.timerId) clearTimeout(existing.timerId);
  if (existing?.running) return;

  const timerId = setTimeout(() => {
    const existing = debounceMap.get(key);
    debounceMap.set(key, {
      ...existing,
      running: true
    });
    fn();
    debounceMap.delete(key);
  }, delay);

  debounceMap.set(key, {
    timerId,
    running: false
  });
};
function simulateFlash(event) {
  if (!AppState.get('isResultShown')) return;

  const TIMING = {
    buttonCooldown: 1600,
    flashTrigger: 150,
    calculationDelayOn: 950,
    calculationDelayOff: 100,
    animationDuration: 1800
  };

  const btn = event?.currentTarget;
  if (!btn || btn.disabled) return;

  btn.disabled = true;
  setTimeout(() => btn.disabled = false, TIMING.buttonCooldown);

  const isReaper = btn === DOM_ELEMENTS.testReaper;
  const prefix = isReaper ? 'reaper' : 'spear';
  const oppositePrefix = isReaper ? 'spear' : 'reaper';
  const stateKey = isReaper ? 'isTestReaperActive' : 'isTestSpearActive';

  const wasActive = AppState.get(stateKey);
  const isNowActive = !wasActive;

  AppState.set(stateKey, isNowActive);
  btn.classList.toggle('activated', isNowActive);

  const isTransitionToOn = !wasActive && isNowActive;

  if (isTransitionToOn && AppState.get('currentAnimatingWeapon') && AppState.get('currentAnimatingWeapon') !== prefix) {
    ['flash', 'calc'].forEach(type => {
      const key = `${oppositePrefix}-${type}`;
      const timeout = debounceMap.get(key);
      if (timeout) {
        clearTimeout(timeout);
        debounceMap.delete(key);
      }
    });
  }

  if (isTransitionToOn) {
    AppState.set('currentAnimatingWeapon', prefix);
    setTimeout(() => {
      if (AppState.get('currentAnimatingWeapon') === prefix) {
        AppState.set('currentAnimatingWeapon', null);
      }
    }, TIMING.calculationDelayOn + 100);

    smoothDebounce(triggerPulseFlash, TIMING.flashTrigger, `${prefix}-flash`);
    DOM_ELEMENTS.submit.textContent = "Calculating...";
  }

  const calcDelay = isTransitionToOn ? TIMING.calculationDelayOn : TIMING.calculationDelayOff;
  smoothDebounce(() => {
    if (typeof processMainCalculation === 'function') {
      processMainCalculation();
    }
  }, calcDelay, `${prefix}-calc`);

  const weaponName = isReaper ? 'Reaper' : 'Spear';
  const statusText = isNowActive ? 'Flash Active' : 'Off';

  if (typeof showSnackbar === 'function') {
    showSnackbar(`${weaponName} ${statusText}`);
  }
}
function triggerPulseFlash() {
  if (!AppState.get('isResultShown')) return;
  if (!isMobile()) return;
  if (AppState.get('isFlashActive')) return;

  const TIMING = {
    animationDuration: 1800,
    emergencyCleanup: 2200
  };

  AppState.set('isFlashActive', true);

  requestAnimationFrame(() => {
    const flash = document.createElement('div');
    const lightning = document.createElement('div');
    flash.className = 'lightning-flash-overlay';
    lightning.className = 'lightning-icon';
    flash.appendChild(lightning);

    try {
      document.body.appendChild(flash);
    } catch (e) {
      console.warn('Flash DOM insertion failed', e);
      AppState.set('isFlashActive', false);
      return;
    }

    const cleanup = () => {
      if (flash.parentNode) {
        flash.parentNode.removeChild(flash);
      }
      AppState.set('isFlashActive', false);
    };

    setTimeout(cleanup, TIMING.animationDuration);
    setTimeout(() => {
      if (AppState.get('isFlashActive') && flash.parentNode) {
        cleanup();
      }
    }, TIMING.emergencyCleanup);
  });
}

// ========== TOOLTIP SYSTEM ==========
const TooltipManager = (() => {
  const activeTooltips = new Map();
  const lazyTooltips = new Map();
  let orphanObserver = null;
  let autoInitObserver = null;
  let tooltipConfig = {};

  const CONFIG = {
    HIDE_DELAY: 300,
    THROTTLE_DELAY: 16,
    MARGIN: 16,
    OFFSET: 12
  };

  const cleanupOrphanedTooltip = (node) => {
    if (activeTooltips.has(node)) {
      const activeData = activeTooltips.get(node);
      if (activeData?.cleanup) activeData.cleanup();
      activeTooltips.delete(node);
    }

    if (lazyTooltips.has(node)) {
      const lazyData = lazyTooltips.get(node);
      if (lazyData?.listenerIds) {
        lazyData.listenerIds.forEach(id => EventManager.remove(id));
      }
      lazyTooltips.delete(node);
    }
  };

  const cleanupChildTooltips = (node) => {
    if (!node.querySelectorAll) return;

    activeTooltips.forEach((data, el) => {
      if (el !== node && node.contains(el)) {
        if (data?.cleanup) data.cleanup();
        activeTooltips.delete(el);
      }
    });

    lazyTooltips.forEach((data, el) => {
      if (el !== node && node.contains(el)) {
        if (data?.listenerIds) {
          data.listenerIds.forEach(id => EventManager.remove(id));
        }
        lazyTooltips.delete(el);
      }
    });
  };

  const startOrphanDetection = () => {
    if (orphanObserver) return;
    if (typeof MutationObserver === 'undefined') return;

    orphanObserver = new MutationObserver((mutations) => {
      const elementsToCheck = new Set();

      mutations.forEach(mutation => {
        mutation.removedNodes.forEach(node => {
          if (node.nodeType === 1) {
            elementsToCheck.add(node);
          }
        });
      });

      elementsToCheck.forEach(node => {
        cleanupOrphanedTooltip(node);
        cleanupChildTooltips(node);
      });
    });

    orphanObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
  };

  const matchesSelector = (element, selector) => {
    if (selector.startsWith('#')) {
      return element.id === selector.slice(1);
    } else if (selector.startsWith('.')) {
      return element.classList.contains(selector.slice(1));
    } else if (selector.startsWith('[')) {
      const attrMatch = selector.match(/\[([^\]]+)\]/);
      if (attrMatch) {
        const [attrName, attrValue] = attrMatch[1].split('=');
        if (attrValue) {
          return element.getAttribute(attrName) === attrValue.replace(/['"]/g, '');
        }
        return element.hasAttribute(attrName);
      }
    }
    return element.matches(selector);
  };

  const injectSVG = (element) => {
    if (element.classList.contains('tooltip-button') && !element.querySelector('svg')) {
      element.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70">
          <path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
        </svg>
      `;
    }
  };

  const initializeElement = (element) => {
    if (lazyTooltips.has(element)) return;

    injectSVG(element);

    Object.entries(tooltipConfig).forEach(([selector, content]) => {
      try {
        if (matchesSelector(element, selector)) {
          registerLazyTooltip(element, content);
        }
      } catch (e) {
        // Selector invalid, skip
      }
    });
  };

  const startAutoInit = () => {
    if (autoInitObserver) return;
    if (typeof MutationObserver === 'undefined') return;
    if (Object.keys(tooltipConfig).length === 0) return;

    autoInitObserver = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType !== 1) return;

          // Check the node itself
          initializeElement(node);

          // Check all descendants
          if (node.querySelectorAll) {
            Object.keys(tooltipConfig).forEach(selector => {
              try {
                const elements = node.querySelectorAll(selector);
                elements.forEach(el => initializeElement(el));
              } catch (e) {
                // Invalid selector, skip
              }
            });
          }
        });
      });
    });

    autoInitObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
  };

  const stopAutoInit = () => {
    if (!autoInitObserver) return;
    autoInitObserver.disconnect();
    autoInitObserver = null;
  };

  const stopOrphanDetection = () => {
    if (!orphanObserver) return;
    orphanObserver.disconnect();
    orphanObserver = null;
  };

  const calculateTooltipSize = (tooltip) => {
    tooltip.style.cssText = 'visibility:hidden;display:block';
    const width = tooltip.offsetWidth;
    const height = tooltip.offsetHeight;
    tooltip.style.cssText = '';
    return {
      width,
      height
    };
  };

  const calculatePosition = (rect, scrollX, scrollY, tooltipWidth, tooltipHeight) => {
    const centerX = rect.left + scrollX + (rect.width / 2);
    const maxLeft = window.innerWidth - tooltipWidth - CONFIG.MARGIN;
    const left = Math.max(CONFIG.MARGIN, Math.min(centerX - (tooltipWidth / 2), maxLeft));

    let top = rect.top + scrollY - tooltipHeight - CONFIG.OFFSET;
    let isFlipped = false;

    if (top < CONFIG.MARGIN + scrollY) {
      top = rect.bottom + scrollY + CONFIG.OFFSET;
      isFlipped = true;
    }

    return {
      left,
      top,
      isFlipped
    };
  };

  const createTooltip = (triggerElement, content) => {
    if (!triggerElement || !content) return;

    const existing = activeTooltips.get(triggerElement);
    if (existing?.cleanup) {
      existing.cleanup();
      activeTooltips.delete(triggerElement);
    }

    const tooltip = document.createElement("div");
    tooltip.className = "tooltip-wrap";
    tooltip.innerHTML = content;
    document.body.appendChild(tooltip);

    let isVisible = false;
    let hideTimer = null;
    const namespace = `tooltip-active-${Date.now()}-${Math.random()}`;

    const cleanup = () => {
      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      EventManager.removeNS(namespace);

      if (tooltip.parentNode) {
        tooltip.parentNode.removeChild(tooltip);
      }

      activeTooltips.delete(triggerElement);
    };

    const updatePosition = () => {
      if (!document.contains(triggerElement) || !document.contains(tooltip)) {
        cleanup();
        return;
      }

      const rect = triggerElement.getBoundingClientRect();
      const scrollX = window.pageXOffset;
      const scrollY = window.pageYOffset;

      const {
        width: tooltipWidth,
        height: tooltipHeight
      } = calculateTooltipSize(tooltip);
      const {
        left,
        top,
        isFlipped
      } = calculatePosition(rect, scrollX, scrollY, tooltipWidth, tooltipHeight);

      tooltip.classList.toggle('flipped', isFlipped);
      tooltip.style.transform = `translate(${left}px, ${top}px)`;
    };

    const show = () => {
      if (isVisible) return;

      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      updatePosition();
      isVisible = true;
      tooltip.classList.add('show');
    };

    const hide = () => {
      if (!isVisible) return;

      tooltip.classList.remove('show');
      isVisible = false;

      hideTimer = setTimeout(() => {
        cleanup();
      }, CONFIG.HIDE_DELAY);
    };

    const handleOutsideClick = (e) => {
      if (!isVisible) return;
      if (triggerElement.contains(e.target)) return;
      if (tooltip.contains(e.target)) return;

      hide();
    };

    const handleKeydown = (e) => {
      if (e.key === "Escape" && isVisible) {
        hide();
      }
    };

    const throttledPosition = () => {
      if (!isVisible) return;

      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      hideTimer = setTimeout(() => {
        updatePosition();
        hideTimer = null;
      }, CONFIG.THROTTLE_DELAY);
    };

    EventManager.addNS(namespace, document, "click", handleOutsideClick);
    EventManager.addNS(namespace, document, "touchend", handleOutsideClick, {
      passive: true
    });
    EventManager.addNS(namespace, document, "keydown", handleKeydown);
    EventManager.addNS(namespace, window, 'resize', throttledPosition, {
      passive: true
    });
    EventManager.addNS(namespace, window, 'scroll', throttledPosition, {
      passive: true
    });

    activeTooltips.set(triggerElement, {
      tooltip,
      cleanup,
      namespace
    });

    show();
  };

  const registerLazyTooltip = (triggerElement, content) => {
    if (!triggerElement || !content) return;

    const existing = lazyTooltips.get(triggerElement);
    if (existing && existing.content === content) return;

    if (existing?.listenerIds) {
      existing.listenerIds.forEach(id => EventManager.remove(id));
    }

    const namespace = `tooltip-lazy-${Date.now()}-${Math.random()}`;
    const listenerIds = [];

    const initTooltip = (e) => {
      if (e?.cancelable) e.preventDefault();
      createTooltip(triggerElement, content);
    };

    const handleClick = (e) => {
      // Check if click is on SVG or its children
      const target = e.target;
      if (target === triggerElement || triggerElement.contains(target)) {
        initTooltip(e);
      }
    };

    listenerIds.push(
      EventManager.addNS(namespace, triggerElement, "click", handleClick),
      EventManager.addNS(namespace, triggerElement, "touchend", handleClick, {
        passive: false
      })
    );

    lazyTooltips.set(triggerElement, {
      content,
      namespace,
      listenerIds
    });

    if (lazyTooltips.size === 1 && !orphanObserver) {
      startOrphanDetection();
    }
  };

  const destroyAll = () => {
    stopAutoInit();
    stopOrphanDetection();

    activeTooltips.forEach(({
      cleanup
    }) => {
      if (cleanup) cleanup();
    });
    activeTooltips.clear();

    lazyTooltips.forEach(({
      listenerIds
    }) => {
      if (listenerIds) {
        listenerIds.forEach(id => EventManager.remove(id));
      }
    });
    lazyTooltips.clear();

    tooltipConfig = {};
  };

  return {
    registerLazyTooltip,
    startAutoInit,
    stopAutoInit,
    setConfig: (config) => {
      tooltipConfig = config;
      startAutoInit();
    },
    destroyAll
  };
})();
const setupTooltips = (config) => {
  // Save config for auto-init
  TooltipManager.setConfig(config);

  // Initialize existing elements
  Object.entries(config).forEach(([selector, content]) => {
    const elements = typeof selector === 'string' ?
      document.querySelectorAll(selector) :
      selector instanceof Element ? [selector] : [];

    elements.forEach(el => {
      if (el instanceof Element) {
        // Auto inject SVG if it's a tooltip-button
        if (el.classList.contains('tooltip-button') && !el.querySelector('svg')) {
          el.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70">
              <path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
            </svg>
          `;
        }
        TooltipManager.registerLazyTooltip(el, content);
      }
    });
  });
};
setupTooltips({
  "#dmgStackTips": "<strong>Final DMG Bonus</strong> and <strong>F. P/M DMG BONUS</strong> are two <strong>different</strong> things! Look for it in your <strong>detailed stats</strong> where it shows as <strong>Final Damage Stack</strong> or <strong>Final Damage Bonus</strong>. Make sure you don't have any buffs active. Can't find it? Just set 0.",
  "#targetRaceTips": "Specific MVP/MINi will <strong>auto sync and lock</strong> this option. Select <strong>Avg Lvl Boss</strong> if you want to target spesific race!",
  "#targetAttrTips": "also same with race.",
  "#dmgRaceTips": "Unlocked when target race selected, minimum valid value is 0.",
  "#dmgAttrTips": "same condition with dmg to race",
  "#mvpminiTips": "DUMMY have no defense stat. Avg 130, Necro, Ogre, Ktul defs less accurate than others!",
  //'"#blueTips": "BLUE*8 is experimental.",
  "#attackTips": "As you can see, it starts with 1, which is your attack. You can use the final result of this calculation to multiply with your attack (up to 99.5% accurate, <a href='#' class='job-sim' data-lightbox-gallery='my-gallery' data-lightbox-trigger>see this</a>).<br><br>But, dont expect to much! This tool calculates RNG buffs from equipment sets, flashes, and doesn't include flat or percentage damage bonuses.",
  "#flashTips": "The values below are normalized to 100% uptime because both flashes only last 10 seconds on a 20 second cooldown.",
  "#reaperTips": "Whether the elements match (+84% Final DMG Bonus) or differ (+28% Final DMG Bonus), the bonus doesn’t have 100% uptime since it only lasts 10 seconds with a 20-second cooldown, and the final result shown below represents the highest output during the buff’s active period.",
  "#spearTips": "This bonus doesn't have 100% uptime because it only lasts 10 seconds while the cooldown is 20 seconds. The final result shown below represents the highest output during the buff's active period.",
  "#elemCtrTips": "Tools assume target Neutral if you're not targeting any attribute.",
  "#breakdownTips": "Values shown to two decimal places for readability. The final result is computed with full precision, so it may differ slightly if you recompute using the displayed (rounded) numbers.",
  "#tableTips": "An upward arrow means higher than your stat, a square means roughly equal (±3%), and a downward means lower."

});

// ========== NOTIFICATION ==========
const SnackbarManager = (() => {
  let timer = null;
  const namespace = 'snackbar-manager';

  const cleanup = () => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    EventManager.removeNS(namespace);
    AppState.set('keyboardListenersAdded', false);
  };

  const setupVisualViewportListeners = (sb) => {
    if (!window.visualViewport) return;

    const updatePosition = () => {
      const offset = window.innerHeight - (window.visualViewport.height || window.innerHeight);
      sb.style.bottom = `${80 + offset}px`;
    };

    EventManager.addNS(namespace, window.visualViewport, 'resize', updatePosition, {
      passive: true
    });
    EventManager.addNS(namespace, window.visualViewport, 'scroll', updatePosition, {
      passive: true
    });
  };

  const setupInputFocusListeners = (sb) => {
    const input = document.querySelector('input[type=number]');
    if (!input) return;

    EventManager.addNS(namespace, input, 'focusin', () => sb.style.bottom = '300px');
    EventManager.addNS(namespace, input, 'focusout', () => sb.style.bottom = '16px');
  };

  const setupMobileKeyboardHandlers = (sb) => {
    if (window.innerWidth > 480) return;
    if (AppState.get('keyboardListenersAdded')) return;

    AppState.set('keyboardListenersAdded', true);

    if (window.visualViewport) {
      setupVisualViewportListeners(sb);
    } else {
      setupInputFocusListeners(sb);
    }
  };

  const show = (text) => {
    const sb = DOM_ELEMENTS?.snackbar;
    if (!sb || !text) return;

    sb.textContent = text;

    if (timer) clearTimeout(timer);

    sb.classList.remove('show');
    void sb.offsetHeight;
    sb.classList.add('show');

    setupMobileKeyboardHandlers(sb);

    timer = setTimeout(() => {
      sb.classList.remove('show');
    }, 3000);
  };

  const handleResize = () => {
    if (window.innerWidth > 480 && AppState.get('keyboardListenersAdded')) {
      cleanup();
    }
  };

  EventManager.addNS(namespace, window, 'resize', handleResize, {
    passive: true
  });

  return {
    show,
    cleanup,
    destroy: cleanup
  };
})();
const showSnackbar = SnackbarManager.show;
const scrollAndFocusElement = (el, msg) => {
  if (msg) showSnackbar(msg);

  const offsetTop = el.getBoundingClientRect().top + window.pageYOffset - 80;
  window.scrollTo({
    top: offsetTop,
    behavior: 'smooth'
  });

  if (!el.disabled) {
    el.focus({
      preventScroll: true
    });
  }

  return false;
};

// ========== ACCORDION SYSTEM ==========
const accordionManager = (() => {
  const duration = 320;
  const easing = 'cubic-bezier(0.25, 0.8, 0.25, 1)';
  const transition = `max-height ${duration}ms ${easing}, opacity ${duration}ms ease-out`;
  const instances = new Map();
  const namespace = 'accordion-manager';
  let observer = null;
  let cleanupInterval = null;

  const setStyles = (content, maxHeight, opacity = 1) => {
    Object.assign(content.style, {
      maxHeight,
      opacity: opacity.toString()
    });
  };

  const createInstance = (details, summary, content) => {
    let isAnimating = false;
    let currentAnimation = null;
    let transitionListenerId = null;
    const instanceNamespace = `${namespace}-${Date.now()}-${Math.random()}`;

    const cleanup = () => {
      if (currentAnimation) {
        cancelAnimationFrame(currentAnimation);
        currentAnimation = null;
      }
      if (transitionListenerId !== null) {
        EventManager.remove(transitionListenerId);
        transitionListenerId = null;
      }
      EventManager.removeNS(instanceNamespace);
      isAnimating = false;
    };

    const animateOpen = () => {
      details.setAttribute('open', '');
      setStyles(content, '0px', 0.3);

      currentAnimation = requestAnimationFrame(() => {
        const targetHeight = content.scrollHeight + 'px';
        setStyles(content, targetHeight, 1);

        const onTransitionEnd = () => {
          setStyles(content, 'none', 1);
          isAnimating = false;
          if (transitionListenerId !== null) {
            EventManager.remove(transitionListenerId);
            transitionListenerId = null;
          }
        };
        transitionListenerId = EventManager.add(content, 'transitionend', onTransitionEnd);
      });
    };

    const animateClose = () => {
      const currentHeight = content.scrollHeight + 'px';
      setStyles(content, currentHeight, 1);

      currentAnimation = requestAnimationFrame(() => {
        setStyles(content, '0px', 0.3);

        const onTransitionEnd = () => {
          details.removeAttribute('open');
          isAnimating = false;
          if (transitionListenerId !== null) {
            EventManager.remove(transitionListenerId);
            transitionListenerId = null;
          }
        };
        transitionListenerId = EventManager.add(content, 'transitionend', onTransitionEnd);
      });
    };

    const animate = (isOpening) => {
      if (isAnimating) return;

      isAnimating = true;
      cleanup();

      if (isOpening) {
        animateOpen();
      } else {
        animateClose();
      }
    };

    const handleClick = (e) => {
      e.preventDefault();
      if (isAnimating) return;

      const isOpen = details.hasAttribute('open');
      animate(!isOpen);
    };

    EventManager.addNS(instanceNamespace, summary, 'click', handleClick);

    return {
      animate,
      cleanup: () => {
        cleanup();
        EventManager.removeNS(instanceNamespace);
      },
      get isAnimating() {
        return isAnimating;
      },
      namespace: instanceNamespace
    };
  };

  const cleanupOrphans = () => {
    const orphanedKeys = [];

    instances.forEach((instance, details) => {
      if (!document.contains(details)) {
        instance.cleanup();
        orphanedKeys.push(details);
      }
    });

    orphanedKeys.forEach(key => instances.delete(key));

    if (instances.size === 0 && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  const startCleanupInterval = () => {
    if (cleanupInterval) return;
    if (instances.size === 0) return;

    cleanupInterval = setInterval(cleanupOrphans, 30000);
  };

  const initializeDetailsElement = (details) => {
    const summary = details.querySelector('summary');
    const content = details.querySelector('.body');

    if (!summary || !content) return;
    if (instances.has(details)) return;

    const isOpen = details.hasAttribute('open');
    Object.assign(content.style, {
      transition,
      overflow: 'hidden',
      maxHeight: isOpen ? 'none' : '0px',
      opacity: isOpen ? '1' : '0.3'
    });

    const instance = createInstance(details, summary, content);
    instances.set(details, instance);
  };

  const processDetails = () => {
    cleanupOrphans();

    document.querySelectorAll('details').forEach(details => {
      initializeDetailsElement(details);
    });

    if (instances.size > 0) {
      startCleanupInterval();
    }
  };

  const shouldProcessMutation = (mutations) => {
    for (const mutation of mutations) {
      if (mutation.addedNodes.length === 0) continue;

      for (const node of mutation.addedNodes) {
        if (node.nodeType !== 1) continue;
        if (node.tagName === 'DETAILS') return true;
        if (node.querySelector?.('details')) return true;
      }
    }
    return false;
  };

  const handleRemovedNodes = (mutations) => {
    for (const mutation of mutations) {
      if (mutation.removedNodes.length === 0) continue;

      for (const node of mutation.removedNodes) {
        if (node.nodeType !== 1) continue;

        if (node.tagName === 'DETAILS' && instances.has(node)) {
          const instance = instances.get(node);
          instance.cleanup();
          instances.delete(node);
          continue;
        }

        if (node.querySelectorAll) {
          instances.forEach((instance, details) => {
            if (node.contains(details)) {
              instance.cleanup();
              instances.delete(details);
            }
          });
        }
      }
    }
  };

  processDetails();

  observer = new MutationObserver((mutations) => {
    handleRemovedNodes(mutations);

    if (shouldProcessMutation(mutations)) {
      requestAnimationFrame(processDetails);
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });

  const destroy = () => {
    if (cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
    if (observer) {
      observer.disconnect();
      observer = null;
    }
    instances.forEach(instance => instance.cleanup());
    instances.clear();
  };

  EventManager.addNS(namespace, window, 'beforeunload', destroy);

  return {
    destroy,
    reinitialize: processDetails
  };
})();

// ========== LOG MODAL ==========
const modalManager = (() => {
  const {
    log,
    openLog,
    closeLog
  } = DOM_ELEMENTS || {};
  if (!log) {
    return {
      show: () => {},
      hide: () => {},
      destroy: () => {}
    };
  }

  const content = log.querySelector('.modal-content, .log-content, .modal-body') || log.firstElementChild;
  const duration = 280;
  const easing = 'cubic-bezier(0.25, 0.8, 0.25, 1)';
  const namespace = 'modal-manager';

  const baseStyles = {
    modal: {
      display: 'none',
      transition: `opacity ${duration}ms ${easing}, transform ${duration}ms ${easing}, backdrop-filter ${duration}ms ${easing}`,
      transformOrigin: 'center'
    },
    content: content ? {
      transition: `transform ${duration}ms ${easing}, opacity ${duration}ms ${easing}`
    } : null
  };

  Object.assign(log.style, baseStyles.modal);
  if (content) {
    Object.assign(content.style, baseStyles.content);
  }

  let isVisible = false;
  let animationId = null;
  let hideTimeout = null;

  const cleanup = () => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    if (hideTimeout) {
      clearTimeout(hideTimeout);
      hideTimeout = null;
    }
  };

  const applyHideStyles = () => {
    Object.assign(log.style, {
      opacity: '0',
      transform: 'scale(0.96)',
      backdropFilter: 'blur(0px)',
      backgroundColor: 'transparent'
    });

    if (content) {
      Object.assign(content.style, {
        transform: 'translateY(-8px) scale(0.98)',
        opacity: '0.5'
      });
    }
  };

  const applyShowStyles = () => {
    Object.assign(log.style, {
      opacity: '1',
      transform: 'scale(1)',
      backdropFilter: 'blur(6px)',
      backgroundColor: 'rgba(0, 0, 0, 0.3)'
    });

    if (content) {
      Object.assign(content.style, {
        transform: 'translateY(0) scale(1)',
        opacity: '1'
      });
    }
  };

  const hide = () => {
    if (!isVisible) return;

    isVisible = false;
    cleanup();

    applyHideStyles();

    hideTimeout = setTimeout(() => {
      if (!isVisible) {
        log.style.display = 'none';
      }
    }, duration);
  };

  const show = () => {
    if (isVisible) return;

    isVisible = true;
    cleanup();

    log.style.display = 'flex';

    animationId = requestAnimationFrame(() => {
      applyShowStyles();
    });
  };

  const handleOpen = (e) => {
    e.stopPropagation();
    show();
  };

  const handleKeydown = (e) => {
    if (e.key === 'Escape' && isVisible) {
      hide();
    }
  };

  const handleOutsideClick = (e) => {
    if (!isVisible) return;
    if (!content) return;
    if (content.contains(e.target)) return;
    if (e.target === openLog) return;

    hide();
  };

  EventManager.addNS(namespace, openLog, 'click', handleOpen);
  EventManager.addNS(namespace, closeLog, 'click', hide);
  EventManager.addNS(namespace, document, 'keydown', handleKeydown);
  EventManager.addNS(namespace, document, 'click', handleOutsideClick);

  const destroy = () => {
    cleanup();
    EventManager.removeNS(namespace);
  };

  EventManager.addNS(namespace, window, 'beforeunload', destroy);

  return {
    show,
    hide,
    destroy
  };
})();

// ========== DROPDOWN MANAGER ==========
class DropdownManager {
  constructor() {
    this.constants = {
      formKeys: ['vesperSet', 'whiteSet', 'blueSet', 'tRace', 'tAttr', 'atkType', 'wElem', 'tSize', 'tDef', 'weapon', 'pen', 'crit'],
      mobMapping: {
        'sizeMob': 'tSize',
        'raceMob': 'tRace',
        'attributeMob': 'tAttr'
      },
      disableButtons: ['resetAll', 'resetRek', 'testSpear', 'testReaper'],
      relatedFields: {
        'tSize': 'sizeEnh',
        'tRace': 'race',
        'tAttr': 'attr'
      },
      calcFields: ['dmg', 'dmgStack', 'sizeEnh', 'race', 'attr', 'elemEnh'],
      setKeys: ['blueSet', 'vesperSet', 'whiteSet']
    };

    this.config = this.buildConfig();
    this.state = {
      selectionOrder: [],
      lockStates: new Map(),
      isSwapping: false,
      updateTimer: null
    };
    this.namespace = 'dropdown-manager';
    this.isInitialized = false;
    this.init();
  }

  buildConfig() {
    return {
      ...this.constants,
      labels: {
        static: {
          blueSetLabel: "Blue SET",
          vesperSetLabel: "Vesper SET",
          whiteSetLabel: "White SET (110*3)",
          atkTypeLabel: "Attack Type",
          weaponLabel: "Weapon",
          wElemLabel: "Weapon Element",
          tSizeLabel: "Target Size",
          tRaceLabel: "Target Race",
          tAttrLabel: "Target Attribute",
          tDefLabel: "MVP/MINI",
          penLabel: "P/M PEN %",
          critLabel: "Critical DMG Bonus %",
          elemEnhLabel: "Element Enhance %",
          sizeLabel: "DMG to Size %",
          raceLabel: "Race",
          attrLabel: "Attribute",
          dmgLabel: "Final P/M Damage Bonus %",
          dmgStackLabel: "Extra: Final Damage Stack %"
        },
        dynamic: {
          vesper: {
            "48": "BRO?!",
            "56": "REALY?!",
            "64": "Wake UP!",
            "72": "STOP Dreaming!",
            "80": "F2P DETECTED!"
          },
          white: {
            "36": "Eh?",
            "42": "WOW",
            "48": "GG!!",
            "54": "Have a Nice Day!"
          }
        }
      },

      fields: {
        atkType: {
          type: 'dropdown',
          options: [{
            value: "pen",
            label: "P/M PEN"
          }, {
            value: "crit",
            label: "CRIT"
          }],
          placeholder: "Select Attack Type",
          onClear: ['pen', 'crit'],
          onUpdate: 'updateAttackTypeUI'
        },
        tSize: {
          type: 'dropdown',
          options: ["Small", "Medium", "Large"],
          placeholder: "Select Target Size"
        },
        tRace: {
          type: 'dropdown',
          options: () => RACE_TYPES,
          placeholder: "skip race",
          onClear: ['race']
        },
        tAttr: {
          type: 'dropdown',
          options: () => Object.keys(getElementCounter()),
          placeholder: "skip attribute",
          onClear: ['attr']
        },
        weapon: {
          type: 'dropdown',
          options: () => Object.keys(getWeaponSizeModifier()),
          placeholder: "Select Weapon Type"
        },
        wElem: {
          type: 'dropdown',
          options: () => Object.keys(getElementCounter()),
          placeholder: "Select Attribute"
        },
        tDef: {
          type: 'dropdown',
          options: () => Object.keys(getTargetDefenseData()),
          placeholder: "Select target",
          special: 'target'
        },
        vesperSet: {
          type: 'set',
          generator: 'vesper'
        },
        whiteSet: {
          type: 'set',
          generator: 'white'
        },
        blueSet: {
          type: 'set',
          generator: 'blue'
        },

        race: {
          type: 'conditional',
          dependsOn: 'tRace',
          active: (race) => ({
            label: `DMG to ${race}`,
            placeholder: `dmg to ${race.toLowerCase()} %`
          }),
          default: {
            label: "Race",
            placeholder: "select target race first"
          }
        },
        attr: {
          type: 'conditional',
          dependsOn: 'tAttr',
          active: (attr) => ({
            label: `DMG to ${attr} Attribute`,
            placeholder: `dmg to ${attr.toLowerCase()} attribute %`
          }),
          default: {
            label: "Attribute",
            placeholder: "select target attribute first"
          }
        },
        elemEnh: {
          type: 'conditional',
          dependsOn: 'wElem',
          active: (elem) => ({
            label: `${elem} Enhance %`,
            placeholder: `${elem.toLowerCase()} enhance`
          }),
          default: {
            label: "Element Enhance %",
            placeholder: "select weapon attribute first"
          }
        },
        sizeEnh: {
          type: 'conditional',
          dependsOn: 'tSize',
          active: (size) => ({
            label: `DMG to ${size} %`,
            placeholder: `dmg to ${size.toLowerCase()}`
          }),
          default: {
            label: "DMG to Size %",
            placeholder: "select target size first"
          }
        },
        dmg: {
          type: 'conditional',
          dependsOn: 'atkType',
          active: () => ({
            placeholder: "final p/m damage bonus"
          }),
          default: {
            placeholder: "select attack type first"
          }
        },
        dmgStack: {
          type: 'conditional',
          dependsOn: 'atkType',
          active: () => ({
            placeholder: "final damage bonus/stack %"
          }),
          default: {
            placeholder: "select attack type first"
          }
        }
      },

      setGenerators: {
        vesper: () => [{
          value: "",
          label: "skip vesper set"
        }, ...Object.entries(VESPER_SET).map(([tier, val]) => ({
          value: val,
          label: `Tier ${tier}`
        }))],
        white: () => [{
          value: "",
          label: "skip white set"
        }, ...Object.entries(WHITE_SET).map(([tier, val]) => ({
          value: val,
          label: tier
        }))],
        blue: () => [{
          value: "",
          label: "skip blue set"
        }, ...Object.entries(BLUE_SET).flatMap(([multiplier, levels]) =>
          Object.entries(levels).map(([lvl, val]) => ({
            value: val,
            label: `Level ${lvl}*${multiplier}`
          })))]
      },

      eventMap: {
        'penCritSelect': 'atkType',
        'weaponSelect': 'weapon',
        'weaponElementSelect': 'wElem',
        'targetSizeSelect': 'tSize',
        'targetRaceSelect': 'tRace',
        'targetElementSelect': 'tAttr'
      }
    };
  }

  init() {
    if (this.isInitialized) return;
    this.populateAllDropdowns();
    this.bindEvents();
    this.updateAll();
    this.syncThreeSets();
    this.isInitialized = true;
  }

  getFormData() {
    return this.config.formKeys.reduce((data, key) => {
      const el = DOM_ELEMENTS[key];
      if (el) {
        data[key] = el.value || '';
        if (el.tagName === 'SELECT' && el.selectedOptions[0]) {
          data[`${key}Text`] = el.selectedOptions[0].textContent;
        }
      }
      return data;
    }, {});
  }

  getTargetData(targetKey) {
    if (!targetKey) return null;
    const rawData = getTargetDefenseData(targetKey);
    return rawData ? {
      ...rawData,
      sizeMob: rawData.sizeMob || DOM_ELEMENTS.tSize?.value || ""
    } : null;
  }

  getCurrentTarget() {
    const targetKey = DOM_ELEMENTS.tDef?.value;
    return targetKey ? {
      key: targetKey,
      data: this.getTargetData(targetKey)
    } : null;
  }

  populateAllDropdowns() {
    Object.entries(this.config.fields).forEach(([key, config]) => {
      if (config.type !== 'dropdown' && config.type !== 'set') return;
      const el = DOM_ELEMENTS[key];
      if (!el) return;

      const options = config.generator ?
        this.config.setGenerators[config.generator]() :
        (typeof config.options === 'function' ? config.options() : config.options);

      this.populateOptions(el, options, config.placeholder);
    });
  }

  populateOptions(select, options, placeholder) {
    if (!select) return;
    const fragment = document.createDocumentFragment();

    if (placeholder) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = placeholder;
      fragment.appendChild(opt);
    }

    options.forEach(optData => {
      const opt = document.createElement('option');
      const isString = typeof optData === "string";
      opt.value = isString ? optData : optData.value;
      opt.textContent = isString ? optData : optData.label;
      if (optData.disabled) opt.disabled = true;
      fragment.appendChild(opt);
    });

    select.innerHTML = '';
    select.appendChild(fragment);
  }

  setFieldState(element, disabled, activeText = '', inactiveText = '') {
    if (!element) return;
    element.disabled = disabled;
    element.placeholder = disabled ? inactiveText : activeText;

    const wrapper = element.closest('.input-wrap');
    if (wrapper) {
      wrapper.classList.toggle('locked', disabled);
      if (!disabled) wrapper.removeAttribute('data-temp-unlocked');
    }
  }

  clearFields(fieldIds) {
    fieldIds.forEach(id => {
      const el = DOM_ELEMENTS[id];
      if (el) el.value = '';
    });
  }

  applyMobProperties(targetData, mode = 'standard', lockOverride = null) {
    if (!targetData) return;

    Object.entries(this.config.mobMapping).forEach(([mobProp, domKey]) => {
      const el = DOM_ELEMENTS[domKey];
      if (!el) return;

      const targetValue = targetData[mobProp];
      const shouldLock = this.shouldLock(domKey, targetValue, mode, lockOverride);

      el.value = targetValue || "";
      el.disabled = shouldLock;
      this.state.lockStates.set(domKey, shouldLock);

      const wrapper = el.closest('.input-wrap');
      if (wrapper) wrapper.classList.toggle('locked', shouldLock);

      if (!targetValue) {
        const relatedKey = this.config.relatedFields[domKey];
        const relatedField = relatedKey ? DOM_ELEMENTS[relatedKey] : null;
        if (relatedField) {
          relatedField.value = "";
          const relatedWrapper = relatedField.closest('.input-wrap');
          if (relatedWrapper) {
            relatedWrapper.classList.remove('locked');
            relatedWrapper.setAttribute('data-temp-unlocked', '1');
          }
        }
      }
    });
  }

  shouldLock(domKey, targetValue, mode, lockOverride) {
    if (lockOverride !== null) return lockOverride;
    const selectedKey = DOM_ELEMENTS.tDef?.value || "";
    return mode === 'swap' ? !!targetValue : (targetValue && !selectedKey.includes("Lvl."));
  }

  bindEvents() {
    EventManager.removeNS(this.namespace);

    EventManager.addNS(this.namespace, document, 'change', (e) => {
      if (AppState.get('isResultShown')) return;

      if (e.target === DOM_ELEMENTS.tDef) {
        this.handleTargetChange();
        return;
      }

      if (this.constants.setKeys.includes(e.target.id)) {
        this.recordSelection(e.target);
        this.syncThreeSets();
        this.scheduleUpdate();
        return;
      }

      const fieldKey = this.config.eventMap[e.target.id];
      if (fieldKey) {
        const fieldConfig = this.config.fields[fieldKey];
        if (fieldConfig?.onClear) this.clearFields(fieldConfig.onClear);
        if (fieldConfig?.onUpdate === 'updateAttackTypeUI') this.updateAttackTypeUI();
        this.scheduleUpdate();
      }
    });
  }

  handleTargetChange() {
    if (this.state.isSwapping) return;

    const selectedKey = DOM_ELEMENTS.tDef?.value;
    if (!selectedKey) return;

    const targetData = this.getTargetData(selectedKey);
    if (targetData) {
      this.applyMobProperties(targetData);
      this.syncBreakdownSwap(selectedKey);
      this.scheduleUpdate();
    }
  }

  recordSelection(selectEl) {
    const formData = this.getFormData();
    const wasCycleComplete = this.state.selectionOrder.length >= 3 || (formData.blueSet && (formData.blueSetText || "").includes("*8"));

    if (!selectEl?.value) {
      this.state.selectionOrder = this.state.selectionOrder.filter(el => el !== selectEl);
      return;
    }

    this.state.selectionOrder = wasCycleComplete ? [selectEl] :
      this.state.selectionOrder.includes(selectEl) ? this.state.selectionOrder : [...this.state.selectionOrder, selectEl];
  }

  syncThreeSets() {
    const setElements = this.constants.setKeys.map(k => DOM_ELEMENTS[k]).filter(Boolean);
    const formData = this.getFormData();
    const blueIs8x = (formData.blueSetText || "").includes("*8");
    const hasBlue8x = formData.blueSet && blueIs8x;

    setElements.forEach(el => Array.from(el.options).forEach(opt => opt.disabled = false));

    if (hasBlue8x) {
      [DOM_ELEMENTS.vesperSet, DOM_ELEMENTS.whiteSet].forEach(el => {
        if (el) {
          Array.from(el.options).forEach(opt => opt.disabled = !!opt.value);
          el.value = "";
        }
      });
    } else {
      if (this.state.selectionOrder.length > 0 && DOM_ELEMENTS.blueSet) {
        Array.from(DOM_ELEMENTS.blueSet.options).forEach(opt => {
          if (opt.value && opt.textContent.includes("*8")) opt.disabled = true;
        });
      }

      if (this.state.selectionOrder.length >= 2) {
        setElements.filter(el => !this.state.selectionOrder.includes(el)).forEach(el => {
          Array.from(el.options).forEach(opt => opt.disabled = !!opt.value);
          el.value = "";
        });
      }

      const blueEl = DOM_ELEMENTS.blueSet;
      if (blueEl?.value && blueEl.selectedOptions[0]?.disabled) {
        blueEl.value = "";
        this.state.selectionOrder = this.state.selectionOrder.filter(el => el !== blueEl);
      }
    }
  }

  updateAll() {
    const formData = this.getFormData();
    this.updateStaticLabels();
    this.updateDynamicLabels(formData);
    this.updateConditionalFields(formData);
    this.updateAttackTypeUI();
  }

  updateStaticLabels() {
    Object.entries(this.config.labels.static).forEach(([key, label]) => {
      const el = DOM_ELEMENTS[key];
      if (el) el.textContent = label;
    });
  }

  updateDynamicLabels(formData) {
    const vesperLabel = DOM_ELEMENTS.vesperSetLabel;
    const whiteLabel = DOM_ELEMENTS.whiteSetLabel;

    if (vesperLabel) {
      vesperLabel.textContent = this.config.labels.dynamic.vesper[formData.vesperSet] || "Vesper SET";
    }
    if (whiteLabel) {
      whiteLabel.textContent = this.config.labels.dynamic.white[formData.whiteSet] || "White SET (110*3)";
    }
  }

  updateConditionalFields(formData) {
    Object.entries(this.config.fields).forEach(([key, config]) => {
      if (config.type !== 'conditional') return;

      const input = DOM_ELEMENTS[key];
      const label = DOM_ELEMENTS[`${key}Label`];
      const conditionValue = formData[config.dependsOn];

      if (!input || !config.active || !config.default) return;

      const settings = conditionValue ? config.active(conditionValue) : config.default;
      const isActive = !!conditionValue;

      input.disabled = !isActive;
      input.placeholder = settings.placeholder;
      if (label && settings.label) label.textContent = settings.label;
    });
  }

  updateAttackTypeUI() {
    const atkType = this.getFormData().atkType;
    const penGroup = document.querySelector('.form-group.pen-group');
    const critGroup = document.querySelector('.form-group.crit-group');

    [penGroup, critGroup].forEach(group => group?.classList.add('hidden'));

    if (atkType === 'pen' && penGroup) {
      penGroup.classList.remove('hidden');
      this.setFieldState(DOM_ELEMENTS.pen, false, 'total converted raw pen + final pen...');
      this.setFieldState(DOM_ELEMENTS.crit, true);
    } else if (atkType === 'crit' && critGroup) {
      critGroup.classList.remove('hidden');
      this.setFieldState(DOM_ELEMENTS.crit, false, 'critical damage bonus...');
      this.setFieldState(DOM_ELEMENTS.pen, true);
    } else {
      this.setFieldState(DOM_ELEMENTS.pen, true);
      this.setFieldState(DOM_ELEMENTS.crit, true);
    }
  }

  scheduleUpdate() {
    if (this.state.updateTimer) clearTimeout(this.state.updateTimer);
    this.state.updateTimer = setTimeout(() => {
      this.updateAll();
      this.state.updateTimer = null;
    }, 50);
  }

  determineSwapMode(prevKey, nextKey) {
    if (!prevKey || !nextKey || nextKey === prevKey) return 'none';

    const prevData = this.getTargetData(prevKey);
    const nextData = this.getTargetData(nextKey);
    if (!prevData || !nextData) return 'manual';

    const prevRaw = getTargetDefenseData(prevKey) || {};
    const nextRaw = getTargetDefenseData(nextKey) || {};

    const currentDOM = {
      sizeMob: DOM_ELEMENTS.tSize?.value || "",
      raceMob: DOM_ELEMENTS.tRace?.value || "",
      attributeMob: DOM_ELEMENTS.tAttr?.value || ""
    };

    for (const [mobProp] of Object.entries(this.config.mobMapping)) {
      const prevValue = prevRaw[mobProp];
      const nextValue = nextRaw[mobProp];

      if (prevValue && nextValue && prevValue !== nextValue) return 'manual';
      if (!nextValue || prevValue) continue;
      if (mobProp === 'sizeMob' && currentDOM.sizeMob === nextValue) continue;

      return 'manual';
    }

    return 'auto';
  }

  executeSwap(nextKey, state, isPenMode) {
    const swapMode = this.determineSwapMode(this.getCurrentTarget()?.key, nextKey);
    if (swapMode === 'none') return;

    this.state.isSwapping = true;

    if (DOM_ELEMENTS.tDef) DOM_ELEMENTS.tDef.value = nextKey;
    this.syncBreakdownSwap(nextKey);
    this.resetGlobalStates();

    const targetData = this.getTargetData(nextKey);
    if (!targetData) {
      this.state.isSwapping = false;
      return;
    }

    if (swapMode === 'auto') {
      this.applyMobProperties(targetData, 'swap');
      typeof processMainCalculation === 'function' && processMainCalculation();
      typeof showSnackbar === 'function' && showSnackbar('Auto calc triggered!');
      this.scheduleUpdate();
    } else {
      this.unlockCalculationFields(isPenMode);
      this.applyMobProperties(targetData, 'manual', true);
      this.updateManualSwapUI(state, isPenMode);
      this.scheduleUpdate();
    }

    this.state.isSwapping = false;
  }

  unlockCalculationFields(isPenMode) {
    const fields = [...this.config.calcFields, isPenMode ? "pen" : "crit"];
    fields.forEach(fieldName => {
      const field = DOM_ELEMENTS[fieldName];
      if (!field) return;

      const wrapper = field.closest(".input-wrap");
      if (wrapper?.querySelector('input[type="number"]')) {
        wrapper.classList.remove("locked");
        wrapper.dataset.tempUnlocked = "1";
      }
      field.disabled = false;
    });

    typeof unbindInputLockGuard === 'function' && unbindInputLockGuard();
  }

  updateManualSwapUI(state, isPenMode) {
    if (DOM_ELEMENTS.submit) DOM_ELEMENTS.submit.disabled = false;

    this.config.disableButtons.forEach(btnId => {
      const btn = DOM_ELEMENTS[btnId];
      if (btn) btn.disabled = true;
    });

    if (DOM_ELEMENTS.hasil) {
      DOM_ELEMENTS.hasil.dataset.specificMode = "0";
      DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
    }
    if (DOM_ELEMENTS.rec) {
      DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';
    }

    const focusElement = isPenMode ? DOM_ELEMENTS.pen : DOM_ELEMENTS.crit;
    typeof scrollAndFocusElement === 'function' &&
      scrollAndFocusElement(focusElement, "Target swapped - please verify stats and recalculate!");

    typeof validateRequiredFields === 'function' && validateRequiredFields();
    typeof validateStatsVsTarget === 'function' && validateStatsVsTarget(state);
  }

  syncBreakdownSwap(targetKey) {
    const swapDropdown = document.querySelector('#breakdown-swap');
    if (swapDropdown && swapDropdown.value !== targetKey) swapDropdown.value = targetKey;
  }

  resetGlobalStates() {
    AppState.reset();
    ['testSpear', 'testReaper'].forEach(btnId => {
      const btn = DOM_ELEMENTS[btnId];
      if (btn) btn.classList.remove('activated');
    });
  }

  createSwapSelect(state, isPenMode) {
    const select = document.createElement("select");
    select.id = "breakdown-swap";
    select.className = "breakdown-swap";

    const pen = +(state.pen);
    const dmg = +(state.dmg);
    const currentKey = this.getCurrentTarget()?.key;
    const allTargetData = getTargetDefenseData();

    const options = Object.keys(allTargetData).map(key => {
      const data = allTargetData[key];
      const def = +(data?.def || 0);
      const dmgred = +(data?.dmgred || 0);
      const insufficient = dmg <= dmgred || (isPenMode && pen <= def);
      const swapMode = this.determineSwapMode(currentKey, key);
      const disabled = swapMode === 'auto' && insufficient;

      const text = disabled ? `${key} (cant auto calc)` : key;
      return `<option value="${key}"${disabled ? ' disabled' : ''}>${text}</option>`;
    });

    select.innerHTML = options.join('');
    select.value = state.tDefKey || "DUMMY";

    if (!select.hasAttribute('data-dropdown-bound')) {
      EventManager.addNS(this.namespace, select, 'change', () => this.executeSwap(select.value, state, isPenMode));
      select.setAttribute('data-dropdown-bound', 'true');
    }

    return select;
  }

  destroy() {
    if (this.state.updateTimer) {
      clearTimeout(this.state.updateTimer);
      this.state.updateTimer = null;
    }
    EventManager.removeNS(this.namespace);
    this.state.selectionOrder = [];
    this.state.lockStates.clear();
    this.state.isSwapping = false;
    this.isInitialized = false;
  }
}
const dropdownManager = new DropdownManager();

// ======== VALIDATION ========
class ValidationSSoT {
  constructor() {
    this.INVALID_CLASS = 'invalid-value';
    this.touchedFields = new Set();
    this.snackbarCooldowns = new Set();
    this.namespace = 'validation-ssot';
    this.isInitialized = false;
    this.autoInit();
  }

  // Element type checkers
  isPenOrDmg = (e) => ['pen', 'dmg'].includes(e?.id);
  isRelatedNumeric = (e) => ['race', 'attr'].includes(e?.id);
  isNumeric = (e) => e?.type === 'number' ||
    e?.classList.contains('numeric-input') ||
    this.isPenOrDmg(e) ||
    this.isRelatedNumeric(e);

  // Utilities
  isValidNumber = (v) => !isNaN(+v) && isFinite(+v);
  normalizeInput = (v) => String(v)
    .replace(/[^\d.,]/g, '')
    .replace(/,/g, '.')
    .replace(/\.{2,}/g, '.')
    .replace(/^\./, '0.')
    .replace(/\.$/, '');

  showMessage = (msg) => typeof showSnackbar === 'function' && showSnackbar(msg);

  canShowSnackbar(elementId) {
    if (this.snackbarCooldowns.has(elementId)) return false;

    this.snackbarCooldowns.add(elementId);
    setTimeout(() => this.snackbarCooldowns.delete(elementId), 2000);
    return true;
  }

  // Validation helpers
  getDropdownForRelated(element) {
    return element.id === 'race' ? DOM_ELEMENTS.tRace : DOM_ELEMENTS.tAttr;
  }

  validateRelatedNumeric(element, value) {
    const dropdown = this.getDropdownForRelated(element);

    if (!dropdown?.value && !value) {
      return {
        isValid: true,
        reason: 'related_empty'
      };
    }

    if (dropdown?.value && !value) {
      return {
        isValid: false,
        reason: 'related_required'
      };
    }

    return null;
  }

  validateMinValue(element, numValue, showMessages) {
    const min = element.getAttribute('min');
    if (min === null || min === '') return null;

    const minVal = +min;
    if (numValue >= minVal) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      const fieldName = element.getAttribute('data-field-name') || element.id || 'Field';
      this.showMessage(`${fieldName} must be at least ${minVal}`);
    }

    return {
      isValid: false,
      reason: 'below_min'
    };
  }

  validateMaxValue(element, numValue, showMessages) {
    const max = element.getAttribute('max');
    if (max === null || max === '') return null;

    const maxVal = +max;
    if (numValue <= maxVal) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      this.showMessage('what are you doing?');
    }

    return {
      isValid: false,
      reason: 'above_max'
    };
  }

  validateThreshold(element, numValue, showMessages) {
    if (!this.isPenOrDmg(element)) return null;

    const defData = getTargetDefenseData(DOM_ELEMENTS.tDef?.value);
    const threshold = element.id === 'pen' ? (+(defData?.def) || 0) : (+(defData?.dmgred) || 0);

    if (numValue > threshold) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      const minRequired = (threshold + 8).toFixed(2);
      const fieldType = element.id === 'pen' ? 'Final PEN' : 'Final P/M Bonus';
      const targetLabel = DOM_ELEMENTS.tDef?.options?.[DOM_ELEMENTS.tDef.selectedIndex]?.textContent || 'target';
      this.showMessage(`Need at least ${minRequired} ${fieldType} vs ${targetLabel}`);
    }

    return {
      isValid: false,
      reason: 'threshold_not_met'
    };
  }

  validateField(element, showMessages = false) {
    const value = element.value?.trim() || '';

    // Check related numeric fields first
    if (this.isRelatedNumeric(element)) {
      const result = this.validateRelatedNumeric(element, value);
      if (result) return result;
    }

    // Empty check
    if (!value) return {
      isValid: false,
      reason: 'empty'
    };

    // Number format check
    if (this.isNumeric(element) && !this.isValidNumber(value)) {
      return {
        isValid: false,
        reason: 'invalid_number'
      };
    }

    const numValue = +value;

    // Min validation
    const minResult = this.validateMinValue(element, numValue, showMessages);
    if (minResult) return minResult;

    // Max validation
    const maxResult = this.validateMaxValue(element, numValue, showMessages);
    if (maxResult) return maxResult;

    // Threshold validation (pen/dmg specific)
    const thresholdResult = this.validateThreshold(element, numValue, showMessages);
    if (thresholdResult) return thresholdResult;

    return {
      isValid: true
    };
  }

  updateFieldState(element, isValid) {
    if (!this.touchedFields.has(element.id)) return;
    element.classList.toggle(this.INVALID_CLASS, !isValid);
  }

  normalizeElement(element) {
    if (!element || !this.isNumeric(element)) return;

    const normalized = this.normalizeInput(element.value);
    if (normalized !== element.value) {
      element.value = normalized;
    }

    const result = this.validateField(element, this.touchedFields.has(element.id));
    this.updateFieldState(element, result.isValid);
  }

  // Event handlers
  createValidateHandler(element) {
    return (showMessages = false) => {
      const result = this.validateField(element, showMessages);
      this.updateFieldState(element, result.isValid);
    };
  }

  createNormalizeHandler(element) {
    return () => {
      if (!this.isNumeric(element)) return;

      const normalized = this.normalizeInput(element.value);
      if (normalized !== element.value) {
        element.value = normalized;
      }
    };
  }

  setupField(element) {
    const validateHandler = this.createValidateHandler(element);
    const normalizeHandler = this.createNormalizeHandler(element);

    EventManager.addNS(this.namespace, element, 'focus', () => {
      this.touchedFields.add(element.id);
    });

    EventManager.addNS(this.namespace, element, 'input', () => {
      normalizeHandler();
      validateHandler(false);
    });

    EventManager.addNS(this.namespace, element, 'blur', () => validateHandler(true));
    EventManager.addNS(this.namespace, element, 'change', () => validateHandler(true));

    EventManager.addNS(this.namespace, element, 'paste', () => {
      if (!this.isNumeric(element)) return;
      setTimeout(() => this.normalizeElement(element), 0);
    });
  }

  setupDefenseChangeHandler() {
    if (!DOM_ELEMENTS.tDef) return;

    EventManager.addNS(this.namespace, DOM_ELEMENTS.tDef, 'change', () => {
      [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg]
      .filter(el => el?.value.trim())
        .forEach(el => {
          const result = this.validateField(el, this.canShowSnackbar(el.id));
          this.updateFieldState(el, result.isValid);
        });
    });
  }

  checkReady = () => typeof DOM_ELEMENTS !== 'undefined' && DOM_ELEMENTS;

  init() {
    if (this.isInitialized || !this.checkReady()) return false;

    // Setup all field validations
    ['atkType', 'weapon', 'wElem', 'tDef', 'tSize', 'pen', 'crit', 'dmg',
      'elemEnh', 'sizeEnh', 'race', 'attr', 'dmgStack'
    ]
    .map(key => DOM_ELEMENTS[key])
      .filter(Boolean)
      .forEach(element => this.setupField(element));

    // Setup defense change handler
    this.setupDefenseChangeHandler();

    this.isInitialized = true;
    return true;
  }

  autoInit() {
    if (this.isInitialized) return;

    const initHandler = () => {
      if (!this.isInitialized) this.init();
    };

    if (document.readyState === 'loading' || document.readyState === 'interactive') {
      document.addEventListener('DOMContentLoaded', initHandler, {
        once: true
      });
    } else {
      this.init();
    }

    window.addEventListener('load', initHandler, {
      once: true
    });
  }

  // Field definitions
  getRequiredFields() {
    return [{
        el: DOM_ELEMENTS.atkType,
        name: 'Attack Type'
      },
      {
        el: DOM_ELEMENTS.weapon,
        name: 'Weapon Type'
      },
      {
        el: DOM_ELEMENTS.wElem,
        name: 'Weapon Attribute'
      },
      {
        el: DOM_ELEMENTS.tDef,
        name: 'Target Boss'
      },
      {
        el: DOM_ELEMENTS.tSize,
        name: 'Target Size'
      },
      {
        el: DOM_ELEMENTS.pen,
        name: 'Final P M PEN %',
        condition: () => DOM_ELEMENTS.atkType?.value === 'pen'
      },
      {
        el: DOM_ELEMENTS.crit,
        name: 'Critical DMG Bonus %',
        condition: () => DOM_ELEMENTS.atkType?.value === 'crit'
      },
      {
        el: DOM_ELEMENTS.dmg,
        name: 'Final P M DMG Bonus %'
      },
      {
        el: DOM_ELEMENTS.elemEnh,
        name: 'Element Enhance %'
      },
      {
        el: DOM_ELEMENTS.sizeEnh,
        name: 'DMG to Size %'
      },
      {
        el: DOM_ELEMENTS.race,
        name: 'DMG to Race %',
        condition: () => DOM_ELEMENTS.race && !DOM_ELEMENTS.race.disabled
      },
      {
        el: DOM_ELEMENTS.attr,
        name: 'DMG to Attribute %',
        condition: () => DOM_ELEMENTS.attr && !DOM_ELEMENTS.attr.disabled
      },
      {
        el: DOM_ELEMENTS.dmgStack,
        name: 'Final DMG Bonus %'
      }
    ];
  }

  shouldValidateField(field) {
    if (!field.el) return false;
    if (!field.condition) return true;
    return field.condition();
  }

  validateSingleField(field) {
    this.touchedFields.add(field.el.id);
    const result = this.validateField(field.el, this.canShowSnackbar(field.el.id));
    this.updateFieldState(field.el, result.isValid);

    if (!result.isValid) {
      if (typeof scrollAndFocusElement === 'function') {
        scrollAndFocusElement(field.el);
      }
      return false;
    }

    return true;
  }

  validateAllRequired() {
    const fields = this.getRequiredFields();

    for (const field of fields) {
      if (!this.shouldValidateField(field)) continue;
      if (!this.validateSingleField(field)) return false;
    }

    return true;
  }

  getStatsElements(state) {
    const elements = [];

    if (state?.atkType?.toLowerCase() === 'pen' && DOM_ELEMENTS.pen) {
      elements.push(DOM_ELEMENTS.pen);
    }

    if (DOM_ELEMENTS.dmg) {
      elements.push(DOM_ELEMENTS.dmg);
    }

    return elements;
  }

  shouldFocusElement(element, focusedElement) {
    return focusedElement === element || !focusedElement;
  }

  validateStatsElement(element, focusedElement) {
    this.touchedFields.add(element.id);
    const result = this.validateField(element, this.canShowSnackbar(element.id));
    this.updateFieldState(element, result.isValid);

    if (!result.isValid && this.shouldFocusElement(element, focusedElement)) {
      if (typeof scrollAndFocusElement === 'function') {
        scrollAndFocusElement(element);
      }
      return false;
    }

    return true;
  }

  validateStats(state, focusedElement = null) {
    const elements = this.getStatsElements(state);

    for (const element of elements) {
      if (!this.validateStatsElement(element, focusedElement)) {
        return false;
      }
    }

    return true;
  }

  destroy() {
    EventManager.removeNS(this.namespace);
    this.touchedFields.clear();
    this.snackbarCooldowns.clear();
    this.isInitialized = false;
  }
}
const ValidationSSoTInstance = new ValidationSSoT();
const normalizeNumericInput = (el, pastedValue) => {
  if (!el) return;
  if (pastedValue !== undefined) el.value = pastedValue;
  ValidationSSoTInstance.normalizeElement(el);
};
const validateRequiredFields = () => ValidationSSoTInstance.validateAllRequired();
const validateStatsVsTarget = (state, focusedElement = null) => ValidationSSoTInstance.validateStats(state, focusedElement);

// ========== INPUT LOCK SYSTEM ==========
const InputLockManager = (() => {
  const PASSIVE_SUPPORT = (() => {
    let supported = false;
    try {
      const opts = {
        get passive() {
          supported = true;
          return false;
        }
      };
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (_) {}
    return supported;
  })();

  const POINTER_SUPPORT = 'PointerEvent' in window;
  const opts = PASSIVE_SUPPORT ? {
    passive: false
  } : false;

  let cachedWrappers = null,
    cacheValid = false,
    observer = null;
  const wrapperListeners = new Map(),
    cooldowns = new WeakMap();

  const invalidateCache = () => {
    cacheValid = false;
    cachedWrappers = null;
  };

  const getCachedWrappers = () => {
    if (cacheValid && cachedWrappers) return cachedWrappers;
    cachedWrappers = Array.from(document.querySelectorAll('.input-wrap'));
    cacheValid = true;
    return cachedWrappers;
  };

  const startCacheObserver = () => {
    if (observer || typeof MutationObserver === 'undefined') return;

    observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          for (const node of [...mutation.addedNodes, ...mutation.removedNodes]) {
            if (node.nodeType === 1 && (node.classList?.contains('input-wrap') || node.querySelector?.('.input-wrap'))) {
              invalidateCache();
              return;
            }
          }
        }
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['class']
    });
  };

  const stopCacheObserver = () => {
    if (observer) observer.disconnect(), observer = null;
  };

  const showLockedMessage = (event) => {
    const target = event?.currentTarget;
    if (!target?.classList?.contains('locked')) return;

    const now = Date.now(),
      lastTime = cooldowns.get(target);
    if (lastTime && (now - lastTime) < 500) return;
    cooldowns.set(target, now);

    if (event?.cancelable) event.preventDefault(), event.stopPropagation();

    if (!window._lastSnackbarTime || (now - window._lastSnackbarTime) > 3000) {
      window._lastSnackbarTime = now;
      typeof showSnackbar === 'function' && showSnackbar("Your Stats Locked!");
    }
  };

  const bind = (wrapper) => {
    if (!wrapper?.nodeType || wrapperListeners.has(wrapper)) return;

    const ids = POINTER_SUPPORT ? [EventManager.add(wrapper, 'pointerdown', showLockedMessage, opts)] : [EventManager.add(wrapper, 'touchstart', showLockedMessage, opts), EventManager.add(wrapper, 'click', showLockedMessage, false)];

    wrapperListeners.set(wrapper, ids);
  };

  const unbind = (wrapper) => {
    if (!wrapper?.nodeType) return;
    const ids = wrapperListeners.get(wrapper);
    if (!ids) return;
    ids.forEach(id => EventManager.remove(id));
    wrapperListeners.delete(wrapper);
    cooldowns.delete(wrapper);
  };

  const lockAll = () => {
    startCacheObserver();
    const wrappers = getCachedWrappers();

    for (let i = 0; i < wrappers.length; i++) {
      const wrapper = wrappers[i];
      const elements = wrapper.querySelectorAll('input, select, textarea');
      if (!elements.length) continue;

      for (let j = 0; j < elements.length; j++) elements[j].disabled = true;
      wrapper.classList.add('locked');
      bind(wrapper);
    }
  };

  const unlockAll = () => {
    const wrappers = getCachedWrappers();

    for (let i = 0; i < wrappers.length; i++) {
      const wrapper = wrappers[i];
      const elements = wrapper.querySelectorAll('input, select, textarea');
      if (!elements.length) continue;

      for (let j = 0; j < elements.length; j++) elements[j].disabled = false;
      wrapper.classList.remove('locked');
      unbind(wrapper);
    }

    invalidateCache();
    stopCacheObserver();
  };

  const destroy = () => {
    stopCacheObserver();
    wrapperListeners.forEach((ids) => ids.forEach(id => EventManager.remove(id)));
    wrapperListeners.clear();
    invalidateCache();
  };

  return {
    bind,
    unbind,
    lockAll,
    unlockAll,
    destroy
  };
})();
const bindInputLockGuard = InputLockManager.bind;
const unbindInputLockGuard = InputLockManager.unbind;
const lockAllInputs = InputLockManager.lockAll;
const unlockAllInputs = InputLockManager.unlockAll;

// ========== STICKY ==========
class StickyHandler {
  constructor() {
    this.state = {
      isActive: false,
      isCollapsed: false,
      isMobile: false,
      animating: false
    };

    this.config = {
      MOBILE_BREAKPOINT: 480,
      BUTTON_HEIGHT: 56,
      ANIMATION_DELAY: 60,
      TRANSITION_DURATION: 300,
      DOM_REINJECT_DELAY: 50,
      OBSERVER_DEBOUNCE: 16,
      RESIZE_DEBOUNCE: 100,
      CLEANUP_DELAY: 320
    };

    this.selectors = {
      resetRek: 'resetRekomenBtn',
      resetAll: 'resetAllBtn',
      swapBoss: 'breakdown-swap',
      stickyStart: () => DOM_ELEMENTS?.hasil,
      testSpear: () => DOM_ELEMENTS?.testSpear,
      testReaper: () => DOM_ELEMENTS?.testReaper
    };

    this.buttonOrder = ['toggleBtn', 'swapBoss', 'testSpear', 'testReaper', 'resetRek', 'resetAll', 'backBtn'];
    this.textButtons = new Set(['resetRek', 'resetAll', 'testSpear', 'testReaper']);
    this.controlButtons = [{
        id: 'toggleStickyBtn',
        class: 'sticky-toggle',
        key: 'toggleBtn',
        handler: 'handleToggle'
      },
      {
        id: 'backToHasilBtn',
        class: 'sticky-back',
        key: 'backBtn',
        handler: 'handleBack'
      }
    ];

    this.elements = new Map();
    this.timeouts = new Map();
    this.boundListeners = new Map();
    this.scrollRAF = null;
    this.observer = null;
    this.unsubscribeAppState = null;
    this.initialized = false;

    this.init();
  }

  // === GUARD HELPER ===
  canOperate() {
    return this.state.isMobile && AppState.get('isResultShown') && this.state.isActive;
  }

  // === ELEMENT MANAGEMENT ===
  initElements() {
    this.elements.clear();

    for (const [key, selector] of Object.entries(this.selectors)) {
      const element = typeof selector === 'function' ? selector() : document.getElementById(selector);

      if (!element) continue;

      this.elements.set(key, element);

      if (this.textButtons.has(key) && !element.dataset.originalText) {
        element.dataset.originalText = element.textContent.trim() || '';
      }

      if (key === 'swapBoss' && this.state.isActive && this.state.isMobile) {
        element.dataset.stickyPreserve = 'true';
      }
    }

    this.createControlButtons();
  }

  createControlButtons() {
    for (const {
        id,
        class: className,
        key,
        handler
      } of this.controlButtons) {
      let button = document.getElementById(id);

      if (!button) {
        button = document.createElement('button');
        button.id = id;
        button.className = className;
        document.body.appendChild(button);
      }

      this.elements.set(key, button);

      if (!button.dataset.bound) {
        const boundHandler = (e) => this[handler](e);
        button.addEventListener('click', boundHandler);
        button.dataset.bound = 'true';
        this.boundListeners.set(`button-${key}`, {
          target: button,
          event: 'click',
          handler: boundHandler
        });
      }
    }

    const toggleBtn = this.elements.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  }

  getOrderedButtons() {
    const buttons = [];
    for (const key of this.buttonOrder) {
      const btn = this.elements.get(key);
      if (btn) buttons.push(btn);
    }
    return buttons;
  }

  // === EVENT HANDLERS ===
  handleToggle = (e) => {
    e.preventDefault();

    if (!this.canOperate() || this.state.animating) return;

    this.state.animating = true;
    this.state.isCollapsed = !this.state.isCollapsed;

    const toggleBtn = this.elements.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = String(this.state.isCollapsed);

    if (navigator.vibrate) navigator.vibrate(50);

    this.applySticky();
    this.scheduleTimeout('animationEnd', () => {
      this.state.animating = false;
    }, this.config.TRANSITION_DURATION);
  }

  handleBack = (e) => {
    e.preventDefault();
    if (!this.canOperate()) return;

    const stickyStart = this.elements.get('stickyStart');
    if (stickyStart) {
      stickyStart.scrollIntoView({
        behavior: 'smooth',
        block: 'start'
      });
    }
  }

  handleScroll = () => {
    if (!this.scrollRAF) {
      this.scrollRAF = requestAnimationFrame(() => {
        this.updateSticky();
        this.scrollRAF = null;
      });
    }
  }

  handleResize = () => {
    this.scheduleTimeout('resize', this.updateSticky.bind(this), this.config.RESIZE_DEBOUNCE);
  }

  // === TIMEOUT MANAGEMENT ===
  scheduleTimeout(key, callback, delay) {
    const existing = this.timeouts.get(key);
    if (existing) clearTimeout(existing);
    this.timeouts.set(key, setTimeout(callback, delay));
  }

  clearAllTimeouts() {
    for (const timeout of this.timeouts.values()) {
      clearTimeout(timeout);
    }
    this.timeouts.clear();
  }

  // === STICKY LOGIC ===
  updateMobileState() {
    const newIsMobile = window.innerWidth <= this.config.MOBILE_BREAKPOINT;
    const changed = newIsMobile !== this.state.isMobile;
    this.state.isMobile = newIsMobile;
    return changed;
  }

  deactivateSticky() {
    this.state.isActive = false;
    this.state.isCollapsed = false;
    this.removeSticky();
  }

  updateSticky() {
    const mobileChanged = this.updateMobileState();

    if (!this.state.isMobile) {
      if (mobileChanged || this.state.isActive) this.deactivateSticky();
      return;
    }

    if (!AppState.get('isResultShown')) {
      if (this.state.isActive) this.deactivateSticky();
      return;
    }

    const stickyStart = this.elements.get('stickyStart');
    if (!stickyStart) return;

    const shouldBeActive = stickyStart.getBoundingClientRect().top <= 0;

    if (shouldBeActive !== this.state.isActive) {
      this.state.isActive = shouldBeActive;
      shouldBeActive ? this.applySticky() : this.removeSticky();
    }
  }

  applySticky() {
    if (!this.canOperate()) return;

    const buttons = this.getOrderedButtons();
    if (buttons.length === 0) return;

    const wasSticky = buttons[0].classList.contains('sticky');
    const toggleBtn = this.elements.get('toggleBtn');

    for (let i = 0; i < buttons.length; i++) {
      const button = buttons[i];
      const isToggle = button === toggleBtn;
      const translateY = this.state.isCollapsed ? 0 : -(i * this.config.BUTTON_HEIGHT);
      const opacity = (this.state.isCollapsed && !isToggle) ? '0.4' : '1';

      button.classList.add('sticky');
      button.classList.toggle('collapsed', this.state.isCollapsed);

      if (!wasSticky) {
        this.animateButtonIn(button, i, translateY);
      } else {
        this.setButtonStyle(button, translateY, opacity);
      }
    }

    this.scheduleTimeout('textUpdate', this.updateButtonText.bind(this), 0);
  }

  animateButtonIn(button, index, translateY) {
    this.setButtonStyle(button, 50, 0, 'none');
    this.scheduleTimeout(`buttonIn-${index}`, () => {
      this.setButtonStyle(button, translateY, 1, 'all 400ms cubic-bezier(0.34, 1.56, 0.64, 1)');
    }, index * this.config.ANIMATION_DELAY);
  }

  setButtonStyle(button, translateY, opacity, transition = '') {
    button.style.cssText = `transform:translate3d(0,${translateY}px,0);opacity:${opacity};${transition ? `transition:${transition};` : ''}`;
  }

  removeSticky() {
    const buttons = this.getOrderedButtons();
    if (buttons.length === 0) return;

    for (const button of buttons) {
      if (button.classList.contains('sticky')) {
        this.setButtonStyle(button, 0, 0.3, 'transform 300ms ease,opacity 200ms ease');
      }
    }

    this.scheduleTimeout('cleanup', () => this.cleanupSticky(buttons), this.config.CLEANUP_DELAY);
  }

  cleanupSticky(buttons) {
    for (const button of buttons) {
      button.classList.remove('sticky', 'collapsed');
      button.style.cssText = '';
      if (button.dataset.originalText) {
        button.textContent = button.dataset.originalText;
      }
    }
  }

  updateButtonText() {
    for (const key of this.textButtons) {
      const button = this.elements.get(key);
      if (button) {
        button.textContent = this.state.isActive ? '' : (button.dataset.originalText || '');
      }
    }
  }

  // === STATE PRESERVATION ===
  preserveSwapState() {
    const swapElement = this.elements.get('swapBoss');
    if (!swapElement || swapElement.tagName !== 'SELECT') return null;

    const computed = window.getComputedStyle(swapElement);
    return {
      value: swapElement.value,
      transform: computed.transform,
      opacity: computed.opacity,
      isSticky: swapElement.classList.contains('sticky'),
      isCollapsed: swapElement.classList.contains('collapsed')
    };
  }

  restoreSwapState(state) {
    if (!state) return;

    const swapElement = this.elements.get('swapBoss');
    if (!swapElement || swapElement.tagName !== 'SELECT') return;

    if (state.value) swapElement.value = state.value;

    swapElement.style.cssText = `transform:${state.transform};opacity:${state.opacity};transition:none;`;
    if (state.isSticky) swapElement.classList.add('sticky');
    if (state.isCollapsed) swapElement.classList.add('collapsed');
  }

  // === EVENT LISTENERS ===
  setupEventListeners() {
    const events = [
      ['scroll', this.handleScroll],
      ['resize', this.handleResize]
    ];

    for (const [event, handler] of events) {
      const key = `window-${event}`;
      if (!this.boundListeners.has(key)) {
        window.addEventListener(event, handler, {
          passive: true
        });
        this.boundListeners.set(key, {
          target: window,
          event,
          handler
        });
      }
    }
  }

  removeEventListeners() {
    for (const {
        target,
        event,
        handler
      } of this.boundListeners.values()) {
      target.removeEventListener(event, handler);
    }
    this.boundListeners.clear();
  }

  // === DOM OBSERVER ===
  setupDOMObserver() {
    if (typeof MutationObserver === 'undefined' || this.observer) return;

    this.observer = new MutationObserver((mutations) => {
      let swapReinjected = false;

      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.id === 'breakdown-swap' || (node.nodeType === 1 && node.querySelector?.('#breakdown-swap'))) {
            swapReinjected = true;
            break;
          }
        }
        if (swapReinjected) break;
      }

      if (!swapReinjected) {
        this.scheduleTimeout('observer', this.updateSticky.bind(this), this.config.OBSERVER_DEBOUNCE);
        return;
      }

      this.scheduleTimeout('observer', () => {
        const swapState = this.preserveSwapState();
        this.initElements();

        if (this.canOperate()) {
          if (swapState) this.restoreSwapState(swapState);
          this.scheduleTimeout('domReinject', this.applySticky.bind(this), this.config.DOM_REINJECT_DELAY);
        } else {
          this.updateSticky();
        }
      }, this.config.OBSERVER_DEBOUNCE);
    });

    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  // === APP STATE SUBSCRIPTION ===
  setupAppStateSubscription() {
    this.unsubscribeAppState = AppState.subscribe((key, value) => {
      if (key === 'isResultShown') {
        if (!value && this.state.isActive) {
          this.deactivateSticky();
        } else if (value && this.state.isMobile && !this.state.isActive) {
          this.updateSticky();
        }
      }
    });
  }

  // === LIFECYCLE ===
  init() {
    const setup = () => {
      if (this.initialized) return;

      this.initElements();
      this.setupEventListeners();
      this.setupDOMObserver();
      this.setupAppStateSubscription();
      this.updateSticky();

      this.initialized = true;
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setup, {
        once: true
      });
    } else {
      setup();
    }
  }

  destroy() {
    this.clearAllTimeouts();

    if (this.scrollRAF) {
      cancelAnimationFrame(this.scrollRAF);
      this.scrollRAF = null;
    }

    this.removeEventListeners();

    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.unsubscribeAppState) {
      this.unsubscribeAppState();
      this.unsubscribeAppState = null;
    }

    this.elements.clear();
    this.boundListeners.clear();
    this.timeouts.clear();
    this.initialized = false;
  }

  static initialize() {
    if (typeof window !== 'undefined' && !window.stickyHandler) {
      window.stickyHandler = new StickyHandler();
    }
    return window.stickyHandler;
  }
}
const stickyHandler = new StickyHandler();

// ======== LIGHTBOX ========
(() => {
  const NS = 'img-lightbox';
  const els = {
    overlay: document.getElementById('img-lightbox-overlay'),
    image: document.querySelector('.img-lightbox-image'),
    loader: document.querySelector('.img-lightbox-loader'),
    closeBtn: document.querySelector('.img-lightbox-close'),
    inner: document.querySelector('.img-lightbox-inner'),
    caption: document.querySelector('.img-lightbox-caption'),
    counter: document.querySelector('.img-lightbox-counter'),
    prevBtn: document.querySelector('.img-lightbox-prev'),
    nextBtn: document.querySelector('.img-lightbox-next')
  };

  const state = {
    scale: 1,
    translateX: 0,
    translateY: 0,
    isDragging: false,
    dragStartX: 0,
    dragStartY: 0,
    pinchStart: 0,
    scaleStart: 1,
    imageLoadId: null,
    galleries: {},
    currentGallery: null,
    currentIndex: 0
  };

  const cfg = {
    MIN: 1,
    MAX: 5,
    STEP: 0.3
  };

  // Utilities
  const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
  const dist = (t1, t2) => Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
  const center = (t1, t2) => ({
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  });

  const apply = () => {
    els.image.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
  };

  const reset = () => {
    Object.assign(state, {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isDragging: false
    });
    apply();
    els.image.style.cursor = 'default';
  };

  const cleanupLoaders = () => {
    if (els.image) {
      els.image.onload = null;
      els.image.onerror = null;
    }
    state.imageLoadId = null;
  };

  const getCurrentItems = () => {
    return state.currentGallery ? state.galleries[state.currentGallery] : [];
  };

  const updateNavButtons = () => {
    const items = getCurrentItems();
    els.prevBtn.classList.toggle('disabled', state.currentIndex === 0);
    els.nextBtn.classList.toggle('disabled', state.currentIndex === items.length - 1);
  };

  const updateCounter = () => {
    const items = getCurrentItems();
    els.counter.textContent = `${state.currentIndex + 1} / ${items.length}`;
  };

  const updateCaption = () => {
    const items = getCurrentItems();
    const item = items[state.currentIndex];
    if (item && item.caption) {
      els.caption.textContent = item.caption;
      els.caption.classList.add('active');
    } else {
      els.caption.textContent = '';
      els.caption.classList.remove('active');
    }
  };

  const setActive = (active) => {
    els.overlay.classList.toggle('img-lightbox-active', active);
    document.body.style.overflow = active ? 'hidden' : '';
    if (!active) {
      cleanupLoaders();
      reset();
      state.currentGallery = null;
    }
  };

  const loadImage = (index) => {
    const items = getCurrentItems();
    if (index < 0 || index >= items.length) return;

    state.currentIndex = index;
    cleanupLoaders();

    els.loader.style.display = 'block';
    els.image.style.display = 'none';
    reset();

    const item = items[index];
    const id = Symbol();
    state.imageLoadId = id;

    els.image.onload = () => {
      if (state.imageLoadId === id) {
        els.loader.style.display = 'none';
        els.image.style.display = 'block';
        cleanupLoaders();
      }
    };

    els.image.onerror = () => {
      if (state.imageLoadId === id) {
        els.loader.style.display = 'none';
        console.error('Failed to load image');
        cleanupLoaders();
      }
    };

    els.image.src = item.src;
    updateNavButtons();
    updateCounter();
    updateCaption();
  };

  const openGallery = (galleryName, startIndex = 0) => {
    if (!state.galleries[galleryName]) return;

    state.currentGallery = galleryName;
    setActive(true);
    loadImage(startIndex);
  };

  const close = () => setActive(false);

  const prev = () => {
    if (state.currentIndex > 0) {
      loadImage(state.currentIndex - 1);
    }
  };

  const next = () => {
    const items = getCurrentItems();
    if (state.currentIndex < items.length - 1) {
      loadImage(state.currentIndex + 1);
    }
  };

  // Event Handlers
  const onWheel = (e) => {
    if (!els.overlay.classList.contains('img-lightbox-active')) return;
    e.preventDefault();

    const delta = e.deltaY < 0 ? cfg.STEP : -cfg.STEP;
    const old = state.scale;
    state.scale = clamp(state.scale + delta, cfg.MIN, cfg.MAX);

    if (state.scale !== old) {
      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
      } else {
        const ratio = state.scale / old;
        state.translateX = e.clientX - (e.clientX - state.translateX) * ratio;
        state.translateY = e.clientY - (e.clientY - state.translateY) * ratio;
      }
      apply();
      els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
    }
  };

  const onMouseDown = (e) => {
    if (state.scale <= cfg.MIN) return;
    state.isDragging = true;
    state.dragStartX = e.clientX - state.translateX;
    state.dragStartY = e.clientY - state.translateY;
    els.image.style.cursor = 'grabbing';
    e.preventDefault();
  };

  const onMouseMove = (e) => {
    if (!state.isDragging) return;
    state.translateX = e.clientX - state.dragStartX;
    state.translateY = e.clientY - state.dragStartY;
    apply();
  };

  const onMouseUp = () => {
    if (!state.isDragging) return;
    state.isDragging = false;
    els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
  };

  const onDblClick = (e) => {
    e.preventDefault();
    if (state.scale > cfg.MIN) {
      reset();
    } else {
      const rect = els.image.getBoundingClientRect();
      state.scale = 2;
      state.translateX = e.clientX - (e.clientX - rect.left) * 2;
      state.translateY = e.clientY - (e.clientY - rect.top) * 2;
      apply();
      els.image.style.cursor = 'move';
    }
  };

  const onTouchStart = (e) => {
    const t = e.touches;

    if (t.length === 1 && state.scale > cfg.MIN) {
      state.isDragging = true;
      state.dragStartX = t[0].clientX - state.translateX;
      state.dragStartY = t[0].clientY - state.translateY;
    } else if (t.length === 2) {
      e.preventDefault();
      state.isDragging = false;
      state.pinchStart = dist(t[0], t[1]);
      state.scaleStart = state.scale;
    }
  };

  const onTouchMove = (e) => {
    const t = e.touches;

    if (t.length === 1 && state.isDragging) {
      e.preventDefault();
      state.translateX = t[0].clientX - state.dragStartX;
      state.translateY = t[0].clientY - state.dragStartY;
      apply();
    } else if (t.length === 2 && state.pinchStart) {
      e.preventDefault();
      const c = center(t[0], t[1]);
      const ratio = dist(t[0], t[1]) / state.pinchStart;
      const newScale = clamp(state.scaleStart * ratio, cfg.MIN, cfg.MAX);
      const scaleRatio = newScale / state.scale;

      state.scale = newScale;
      state.translateX = c.x - (c.x - state.translateX) * scaleRatio;
      state.translateY = c.y - (c.y - state.translateY) * scaleRatio;

      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
      }

      apply();
    }
  };

  const onTouchEnd = (e) => {
    if (e.touches.length === 0) {
      state.isDragging = false;
      state.pinchStart = 0;
      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
        apply();
      }
    } else if (e.touches.length === 1 && state.scale > cfg.MIN) {
      state.isDragging = true;
      state.dragStartX = e.touches[0].clientX - state.translateX;
      state.dragStartY = e.touches[0].clientY - state.translateY;
      state.pinchStart = 0;
    }
  };

  const onKey = (e) => {
    if (!els.overlay.classList.contains('img-lightbox-active')) return;
    const actions = {
      'Escape': close,
      '0': reset,
      'ArrowLeft': prev,
      'ArrowRight': next
    };
    actions[e.key]?.();
  };

  const onVisibility = () => {
    if (document.hidden && state.isDragging) {
      state.isDragging = false;
      els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
    }
  };

  // Initialize galleries
  const initGalleries = (container = document) => {
    // Collect all gallery items
    container.querySelectorAll('[data-lightbox-item]:not([data-lb-init])').forEach(item => {
      item.setAttribute('data-lb-init', '');
      const galleryName = item.getAttribute('data-lightbox-item');
      const src = item.getAttribute('data-lightbox-image');
      const caption = item.getAttribute('data-caption') || '';

      if (!state.galleries[galleryName]) {
        state.galleries[galleryName] = [];
      }

      state.galleries[galleryName].push({
        src,
        caption
      });
    });

    // Initialize gallery triggers
    container.querySelectorAll('[data-lightbox-trigger]:not([data-lb-trigger-init])').forEach(trigger => {
      trigger.setAttribute('data-lb-trigger-init', '');
      const galleryName = trigger.getAttribute('data-lightbox-gallery');

      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        if (galleryName && state.galleries[galleryName]) {
          openGallery(galleryName, 0);
        }
      });
    });

    // Initialize single image links (backward compatibility)
    container.querySelectorAll('[data-lightbox-image]:not([data-lightbox-trigger]):not([data-lb-single-init])').forEach(link => {
      link.setAttribute('data-lb-single-init', '');
      const src = link.getAttribute('data-lightbox-image');
      const caption = link.getAttribute('data-caption') || '';

      // Create temporary gallery for single image
      const singleGalleryName = `single-${Math.random().toString(36).substr(2, 9)}`;
      state.galleries[singleGalleryName] = [{
        src,
        caption
      }];

      link.addEventListener('click', (e) => {
        e.preventDefault();
        openGallery(singleGalleryName, 0);
      });
    });
  };

  initGalleries();

  // Observer for dynamic content
  const observer = new MutationObserver((mutations) => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        if (node.nodeType === 1) {
          if (node.hasAttribute?.('data-lightbox-item') || node.hasAttribute?.('data-lightbox-trigger')) {
            initGalleries(node.parentElement);
          }
          if (node.querySelectorAll) {
            initGalleries(node);
          }
        }
      }
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });

  // Bind events
  const events = [
    [els.closeBtn, 'click', close],
    [els.prevBtn, 'click', prev],
    [els.nextBtn, 'click', next],
    [els.overlay, 'click', (e) => e.target === els.overlay && close()],
    [els.inner, 'click', (e) => e.stopPropagation()],
    [document, 'keydown', onKey],
    [document, 'visibilitychange', onVisibility],
    [els.image, 'wheel', onWheel, {
      passive: false
    }],
    [els.image, 'mousedown', onMouseDown],
    [document, 'mousemove', onMouseMove],
    [document, 'mouseup', onMouseUp],
    [els.image, 'dblclick', onDblClick],
    [els.image, 'touchstart', onTouchStart, {
      passive: false
    }],
    [els.image, 'touchmove', onTouchMove, {
      passive: false
    }],
    [els.image, 'touchend', onTouchEnd],
    [els.image, 'touchcancel', onTouchEnd]
  ];

  events.forEach(([el, type, handler, opts]) => {
    EventManager.addNS(NS, el, type, handler, opts);
  });

  // Cleanup on unload
  window.addEventListener('beforeunload', () => {
    cleanupLoaders();
    observer.disconnect();
    EventManager.removeNS(NS);
  }, {
    once: true
  });
})();

// ========== EVENT BINDING ==========
(() => {
  if (window._eventsAlreadyBound) return;
  window._eventsAlreadyBound = true;

  const buttonBindings = new Map([
    [DOM_ELEMENTS.testSpear, simulateFlash],
    [DOM_ELEMENTS.testReaper, simulateFlash],
    [DOM_ELEMENTS.submit, processMainCalculation],
    [DOM_ELEMENTS.resetRek, () => {
      regenerateRecommendations();
      showSnackbar?.("Table Refreshed!");
    }],
    [DOM_ELEMENTS.resetAll, resetAllData]
  ]);

  window._buttonListenerIds = [];

  buttonBindings.forEach((handler, element) => {
    if (element?.addEventListener) {
      const listenerId = EventManager.add(element, 'click', handler);
      window._buttonListenerIds.push(listenerId);

      if (element === DOM_ELEMENTS.testSpear || element === DOM_ELEMENTS.testReaper) {
        element.classList.remove('activated');
      }
    }
  });
})();

// ========== CLEAR CACHE ==========
function clearCache(type = null) {
  if (type) {
    cache.clear(type);
  } else {
    cache.clear();
    cache.rewarm();
    RandomGenerator.reset();
  }
}

// ========== RESET SYSTEM ==========
function resetAllData() {
  if (!confirm('Reset all data and inputs?')) return;

  const shouldClearCache = confirm('Also clear calculation cache?');

  // Clear cache if requested
  if (shouldClearCache) {
    cache.clear();
    cache.rewarm();
    RandomGenerator.reset();
  }

  // Reset AppState
  AppState.reset();

  // Clear debounce timers
  if (debounceCleanupInterval) {
    clearInterval(debounceCleanupInterval);
    debounceCleanupInterval = null;
  }
  debounceMap.forEach(data => {
    if (data?.timerId) clearTimeout(data.timerId);
  });
  debounceMap.clear();

  // Reset Dropdown Manager state
  if (typeof dropdownManager !== 'undefined') {
    dropdownManager.state.selectionOrder = [];
    dropdownManager.state.lockStates.clear();
    dropdownManager.state.isSwapping = false;
    if (dropdownManager.state.updateTimer) {
      clearTimeout(dropdownManager.state.updateTimer);
      dropdownManager.state.updateTimer = null;
    }
  }

  // Reset Sticky Handler state (synced with new structure)
  if (typeof stickyHandler !== 'undefined') {
    // Cancel RAF
    if (stickyHandler.scrollRAF) {
      cancelAnimationFrame(stickyHandler.scrollRAF);
      stickyHandler.scrollRAF = null;
    }

    // Clear all timeouts
    if (stickyHandler.clearAllTimeouts) {
      stickyHandler.clearAllTimeouts();
    }

    // Reset state
    if (stickyHandler.state) {
      stickyHandler.state.isActive = false;
      stickyHandler.state.isCollapsed = false;
      stickyHandler.state.animating = false;
    }

    // Clean up buttons
    const buttons = stickyHandler.getOrderedButtons ? stickyHandler.getOrderedButtons() : [];
    buttons.forEach(button => {
      button.classList.remove('sticky', 'collapsed');
      button.style.cssText = '';
      if (button.dataset.originalText) {
        button.textContent = button.dataset.originalText;
      }
    });

    // Reset toggle button
    const toggleBtn = stickyHandler.elements?.get('toggleBtn');
    if (toggleBtn) {
      toggleBtn.dataset.collapse = 'false';
    }
  }

  // Reset Validation state
  if (typeof ValidationSSoTInstance !== 'undefined') {
    ValidationSSoTInstance.touchedFields.clear();
    ValidationSSoTInstance.snackbarCooldowns.clear();
  }

  // Clear Snackbar keyboard listeners
  if (typeof SnackbarManager !== 'undefined' && SnackbarManager.cleanup) {
    SnackbarManager.cleanup();
  }

  // Reset all form inputs
  document.querySelectorAll('input[type="number"], input[type="text"], select, textarea').forEach(el => {
    el.value = '';
    el.disabled = false;
    el.classList.remove('invalid-value');

    const wrapper = el.closest('.input-wrap');
    if (wrapper) {
      wrapper.classList.remove('locked');
      delete wrapper.dataset.tempUnlocked;
    }
  });

  // Reset display containers
  if (DOM_ELEMENTS.hasil) {
    DOM_ELEMENTS.hasil.innerHTML = '';
    DOM_ELEMENTS.hasil.textContent = 'Input your stats to see the result...';
    delete DOM_ELEMENTS.hasil.dataset.showFullPrecision;
    delete DOM_ELEMENTS.hasil.dataset.specificMode;
  }

  if (DOM_ELEMENTS.rec) {
    DOM_ELEMENTS.rec.innerHTML = '';
    DOM_ELEMENTS.rec.textContent = 'Balancing stat recommendations for a higher output multiplier.';
  }

  // Reset button states
  if (DOM_ELEMENTS.submit) {
    DOM_ELEMENTS.submit.disabled = false;
    DOM_ELEMENTS.submit.textContent = "Calculate";
  }

  [DOM_ELEMENTS.resetRek, DOM_ELEMENTS.resetAll, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.testReaper].forEach(btn => {
    if (btn) {
      btn.disabled = true;
      btn.classList.remove('activated');
    }
  });

  // Remove all sticky states from DOM (fallback cleanup)
  document.querySelectorAll('.sticky').forEach(el => {
    el.classList.remove('sticky', 'collapsed');
    el.style.cssText = '';
    if (el.dataset.originalText) {
      el.textContent = el.dataset.originalText;
    }
  });

  // Reset toggle button (fallback)
  const toggleBtn = document.getElementById('toggleStickyBtn');
  if (toggleBtn) {
    toggleBtn.dataset.collapse = 'false';
  }

  // Reset snackbar
  if (DOM_ELEMENTS.snackbar) {
    DOM_ELEMENTS.snackbar.classList.remove('show');
    DOM_ELEMENTS.snackbar.style.cssText = '';
  }

  // Clear global timestamps
  delete window._lastSnackbarTime;

  // Reinitialize components
  if (typeof dropdownManager !== 'undefined' && dropdownManager.init) {
    dropdownManager.populateAllDropdowns();
    dropdownManager.updateAll();
    dropdownManager.syncThreeSets();
  }

  if (typeof ValidationSSoTInstance !== 'undefined' && ValidationSSoTInstance.init) {
    ValidationSSoTInstance.init();
  }

  if (typeof stickyHandler !== 'undefined' && stickyHandler.updateSticky) {
    stickyHandler.updateSticky();
  }

  // Scroll to top
  const message = shouldClearCache ? 'All data and cache cleared!' : 'All data reset!';

  if (DOM_ELEMENTS.topOfPage) {
    const offsetTop = DOM_ELEMENTS.topOfPage.getBoundingClientRect().top + window.pageYOffset - 80;
    window.scrollTo({
      top: offsetTop,
      behavior: 'smooth'
    });
  } else {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  }

  if (typeof showSnackbar === 'function') {
    setTimeout(() => showSnackbar(message), 300);
  }
}

// ========== CLEANUP ==========
const cleanupAll = () => {
  // Clear debounce
  if (debounceCleanupInterval) {
    clearInterval(debounceCleanupInterval);
    debounceCleanupInterval = null;
  }
  debounceMap.forEach(data => {
    if (data?.timerId) clearTimeout(data.timerId);
  });
  debounceMap.clear();

  // Force cleanup EventManager
  if (typeof EventManager !== 'undefined') {
    EventManager.forceCleanup?.();
    EventManager.removeAll?.();
  }

  // Clear AppState listeners
  if (typeof AppState !== 'undefined') {
    AppState.clearListeners?.();
  }

  // Destroy managers (proper order - UI first, then data)
  ValidationSSoTInstance?.destroy();
  TooltipManager?.destroyAll();
  SnackbarManager?.destroy();
  dropdownManager?.destroy();
  stickyHandler?.destroy();
  accordionManager?.destroy();
  modalManager?.destroy();

  // Clear cache
  if (typeof cache !== 'undefined') {
    cache.clear();
  }
  if (typeof RandomGenerator !== 'undefined') {
    RandomGenerator.reset();
  }

  // Clear window debounce
  if (window.debounceMap) {
    window.debounceMap.forEach(t => clearTimeout(t));
    window.debounceMap.clear();
  }

  // Remove button listeners
  if (window._buttonListenerIds && typeof EventManager !== 'undefined') {
    window._buttonListenerIds.forEach(id => EventManager.remove?.(id));
    window._buttonListenerIds = [];
  }

  // Clear flags
  delete window._eventsAlreadyBound;
  delete window._lastSnackbarTime;
};

EventManager.add(window, 'beforeunload', cleanupAll);
if (typeof window !== 'undefined') window.__forceCleanup = cleanupAll;
