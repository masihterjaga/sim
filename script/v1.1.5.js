/**
 * I don’t care how long this code is or whether it’s efficient, it was all generated by AI anyway. Even this line generated by AI too.
*/

// ========== DOM CACHE ==========
const DOM_ELEMENTS = {
  topOfPage: document.getElementById('top'),
  altSim: document.getElementById('altsim'),
  atkType: document.getElementById('penCritSelect'),
  weapon: document.getElementById('weaponSelect'),
  wElem: document.getElementById('weaponElementSelect'),
  tSize: document.getElementById('targetSizeSelect'),
  tRace: document.getElementById('targetRaceSelect'),
  tAttr: document.getElementById('targetElementSelect'),
  tDef: document.getElementById('targetDefSelect'),
  blueSet: document.getElementById("blueSet"),
  blueSetLabel: document.getElementById("blueSetLabel"),
  vesperSet: document.getElementById("vesperSet"),
  vesperSetLabel: document.getElementById("vesperSetLabel"),
  whiteSet: document.getElementById("whiteSet"),
  whiteSetLabel: document.getElementById("whiteSetLabel"),
  tDefLabel: document.getElementById('tDefLabel'),
  atkTypeLabel: document.getElementById('atkTypeLabel'),
  weaponLabel: document.getElementById('weaponLabel'),
  wElemLabel: document.getElementById('wElemLabel'),
  tSizeLabel: document.getElementById('tSizeLabel'),
  tRaceLabel: document.getElementById('tRaceLabel'),
  tAttrLabel: document.getElementById('tAttrLabel'),
  attack: document.getElementById('attack'),
  // experimental
  flatDmgBns: document.getElementById('flatDmgBns'),
  percentageDmgBns: document.getElementById('percentageDmgBns'),
  pen: document.getElementById('pen'),
  crit: document.getElementById('crit'),
  dmgStack: document.getElementById('dmgStack'),
  dmgStackTips: document.getElementById('dmgStackTips'),
  dmg: document.getElementById('dmg'),
  elemEnh: document.getElementById('elemEnhance'),
  sizeEnh: document.getElementById('sizeEnhance'),
  race: document.getElementById('race'),
  attr: document.getElementById('attr'),
  penLabel: document.getElementById('penLabel'),
  critLabel: document.getElementById('critLabel'),
  atkLabel: document.getElementById('atkLabel'),
  flatDmgBnsLabel: document.getElementById('flatDmgBnsLabel'),
  percentageDmgBnsLabel: document.getElementById('percentageDmgBnsLabel'),
  dmgLabel: document.getElementById('dmgLabel'),
  elemEnhLabel: document.getElementById('elemEnhLabel'),
  sizeEnhLabel: document.getElementById('sizeLabel'),
  raceLabel: document.getElementById('raceLabel'),
  attrLabel: document.getElementById('attrLabel'),
  hasil: document.getElementById('hasil'),
  rec: document.getElementById('recommendations'),
  submit: document.getElementById('submitBtn'),
  edit: document.getElementById('editBtn'),
  resetRek: document.getElementById('resetRekomenBtn'),
  cacheBtn: document.getElementById('cacheBtn'),
  resetAll: document.getElementById('resetAllBtn'),
  checkUpdateBtn: document.getElementById('checkBtn'),
  testSpear: document.getElementById('testSpear'),
  testReaper: document.getElementById('testReaper'),
  snackbar: document.getElementById('snackbar'),
  log: document.getElementById("log"),
  openLog: document.getElementById("openLog"),
  closeLog: document.getElementById("closeLog"),
  stickyStart: document.getElementById("stickyStart")
};

// ========== DATA CONSTANTS ==========
const VESPER_SET = {
  0: 8,
  1: 16,
  2: 24,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64,
  8: 72,
  9: 80
};
const BLUE_SET = {
  3: {
    30: 5,
    40: 7.5,
    50: 10,
    60: 12.5,
    70: 15,
    80: 17.5,
    90: 20,
    100: 22.5,
    110: 25,
    120: 27.5,
    130: 30,
    140: 32.5,
    150: 35
  },
  8: {
    30: 5,
    40: 10,
    50: 15,
    60: 20,
    70: 25,
    80: 30,
    90: 35,
    100: 40,
    110: 45,
    120: 50,
    130: 55,
    140: 60,
    150: 65

  }
};
const WHITE_SET = {
  "Tier 0": 30,
  "Tier 1": 36,
  "Tier 2": 42,
  "Tier 3": 48,
  "Tier 4": 54
};
const ELEMENT_COUNTER_TABLE = {
  Neutral: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 1,
    Shadow: 1,
    Ghost: 0.70,
    Undead: 1
  },
  Fire: {
    Neutral: 1,
    Fire: 0.25,
    Water: 1,
    Earth: 1.25,
    Wind: 1,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1.125
  },
  Water: {
    Neutral: 1,
    Fire: 1.25,
    Water: 0.25,
    Earth: 1,
    Wind: 0.90,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Earth: {
    Neutral: 1,
    Fire: 0.90,
    Water: 1,
    Earth: 0.25,
    Wind: 1.25,
    Poison: 1,
    Holy: 0.75,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Wind: {
    Neutral: 1,
    Fire: 1,
    Water: 1.375,
    Earth: 0.90,
    Wind: 0.25,
    Poison: 1,
    Holy: 0.70,
    Shadow: 1,
    Ghost: 1,
    Undead: 1
  },
  Poison: {
    Neutral: 1,
    Fire: 1.125,
    Water: 1,
    Earth: 1.125,
    Wind: 1.125,
    Poison: 0,
    Holy: 0.75,
    Shadow: 0.50,
    Ghost: 1,
    Undead: -0.25
  },
  Holy: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 0,
    Shadow: 1.375,
    Ghost: 1,
    Undead: 1.375
  },
  Shadow: {
    Neutral: 1.125,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 0.50,
    Holy: 1.375,
    Shadow: 0,
    Ghost: 1,
    Undead: -0.25
  },
  Ghost: {
    Neutral: 0.90,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 1,
    Holy: 0.75,
    Shadow: 0.75,
    Ghost: 1.375,
    Undead: 1
  },
  Undead: {
    Neutral: 1,
    Fire: 1,
    Water: 1,
    Earth: 1,
    Wind: 1,
    Poison: 0.50,
    Holy: 1.375,
    Shadow: 0,
    Ghost: 1.25,
    Undead: 0
  }
};
const WEAPON_SIZE_MODIFIER_TABLE = {
  "Empty Handed": {
    Large: 0.5,
    Medium: 0.5,
    Small: 0.5
  },
  "One-Handed Sword": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Two-Handed Sword": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Two-Handed Spear": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Dagger": {
    Large: 0.75,
    Medium: 0.75,
    Small: 1
  },
  "Katar": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Light Knuckle": {
    Large: 0.75,
    Medium: 0.75,
    Small: 1
  },
  "Heavy Knuckle": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "GS": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Ninja Sword": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Huuma Shuriken": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Tome": {
    Large: 0.75,
    Medium: 1,
    Small: 1
  },
  "Book": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Two-Handed Staff": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "One-Handed Staff": {
    Large: 1,
    Medium: 1,
    Small: 1
  },
  "Mace": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "One-Handed Axe": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Two-Handed Axe": {
    Large: 1,
    Medium: 0.75,
    Small: 0.75
  },
  "Bow": {
    Large: 0.75,
    Medium: 1,
    Small: 1
  },
  "Instrument": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  },
  "Whip": {
    Large: 0.75,
    Medium: 1,
    Small: 0.75
  }
};
const RACE_TYPES = [
  "Angel", 
  "Demon", 
  "Formless", 
  "Insect", 
  "Fish", 
  "Demi-Human", 
  "Undead", 
  "Dragon", 
  "Plant", 
  "Brute"
];
// Defense Stats From Nila
const DEFENSE_TABLE = {
  "DUMMY Lvl.0 (0 DEF)": {
    def: 0,
    dmgred: 0
  },
  "Avg. MVP Lvl.130": {
    def: 182.27,
    dmgred: 148.10
  },
  "Avg. MINI Lvl.130": {
    def: 206.45,
    dmgred: 165.52
  },
  "Avg. MVP MINI Lvl.130": {
    def: 194.36,
    dmgred: 156.81
  },
  "Avg. MVP Lvl.140": {
    def: 155.32,
    dmgred: 191.35
  },
  "Avg. MINI Lvl.140": {
    def: 161.41,
    dmgred: 233.48
  },
  "Avg. MVP MINI Lvl.140": {
    def: 158.37,
    dmgred: 212.41
  },
  "Avg. MVP Lvl.150": {
    def: 191.03,
    dmgred: 283.92
  },
  "Avg. MINI Lvl.150": {
    def: 198.53,
    dmgred: 324.23
  },
  "Avg. MVP MINI Lvl.150": {
    def: 194.78,
    dmgred: 304.08
  },
  "Avg. Small MVP Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small"
  },
  "Avg. Medium MVP Lv.140": {
    def: 199.62,
    dmgred: 195.88,
    sizeMob: "Medium"
  },
  "Avg. Large MVP Lv.140": {
    def: 143.05,
    dmgred: 184.84,
    sizeMob: "Large"
  },
  "Avg. Small MINI Lv.140": {
    def: 161.12,
    dmgred: 225.97,
    sizeMob: "Small"
  },
  "Avg. Medium MINI Lv.140": {
    def: 148.23,
    dmgred: 212.13,
    sizeMob: "Medium"
  },
  "Avg. Large MINI Lv.140": {
    def: 178.61,
    dmgred: 267.37,
    sizeMob: "Large"
  },
  "Avg. Small MVP Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small"
  },
  "Avg. Medium MVP Lv.150": {
    def: 240.07,
    dmgred: 273.72,
    sizeMob: "Medium"
  },
  "Avg. Large MVP Lv.150": {
    def: 177.51,
    dmgred: 282.29,
    sizeMob: "Large"
  },
  "Avg. Small MINI Lv.150": {
    def: 198.01,
    dmgred: 312.15,
    sizeMob: "Small"
  },
  "Avg. Medium MINI Lv.150": {
    def: 182.88,
    dmgred: 304.72,
    sizeMob: "Medium"
  },
  "Avg. Large MINI Lv.150": {
    def: 219.08,
    dmgred: 359.67,
    sizeMob: "Large"
  },
  "Phreeoni Lv.140": {
    def: 106.98,//106.98,
    dmgred: 204.60,//204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mistress Lv.140": {
    def: 130.18,//130.18,
    dmgred: 272.8023999999994,//272.80,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eddga Lv.140": {
    def: 106.98040000000002,//106.98,
    dmgred: 204.60080000000002,//204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Kraken Lv.140": {
    def: 130.18360000000013,//130.18,
    dmgred: 272.8001,//272.80,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Maya Lv.140": {
    def: 98.97150000000005,//98.97,
    dmgred: 136.4031000000001,//136.40,
    sizeMob: "Large",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Orc Hero Lv.140": {
    def: 82.47030000000001,//82.47,
    dmgred: 136.40400000000014,//136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Pharaoh Lv.140": {
    def: 98.97380000000013,//98.97,
    dmgred: 136.40120000000005,//136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Shadow"
  },
  "Orc Lord Lv.140": {
    def: 82.47030000000001,//82.47,
    dmgred: 136.40400000000014,//136.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Doppelganger Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Amon Ra Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Morroc Lv.140": {
    def: 131.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Time Holder Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Tao Gunka Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Lost Dragon Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Fallen Bishop Lv.140": {
    def: 164.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Lord of the Dead Lv.140": {
    def: 131.97,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Arc Angeling Lv.140": {
    def: 164.9684,//164.97,
    dmgred: 136.4008000000001,//136.40,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Gioia Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Wind"
  },
  "RSX-0806 Lv.140": {
    def: 238.66,
    dmgred: 202.00,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Neutral"
  },
  "Nidhoggr's Shadow Lv.140": {
    def: 181.21,
    dmgred: 134.00,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Gloom Under Night Lv.140": {
    def: 306.00,
    dmgred: 300.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Ghost"
  },
  "Retribution Lv.140": {
    def: 256.50,
    dmgred: 300.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Shadow"
  },
  "Dragon Fly Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eclipse Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Small",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mastering Lv.140": {
    def: 130.18,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Plant",
    attributeMob: "Water"
  },
  "Ghostring Lv.140": {
    def: 106.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Toad Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Small",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "King Dramoh Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Angeling Lv.140": {
    def: 98.97,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Deviling Lv.140": {
    def: 82.47,
    dmgred: 136.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Dark Priest Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Undead"
  },
  "Vagabond Wolf Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Medium",
    raceMob: "Brute",
    attributeMob: "Earth"
  },
  "Chimera Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Mysteltainn Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Ogretooth Lv.140": {
    def: 212.68,
    dmgred: 306.35,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Necromancer Lv.140": {
    def: 131.97,
    dmgred: 150.75,
    sizeMob: "Medium",
    raceMob: "Undead",
    attributeMob: "Undead"
  },
  "Coelacanth Lv.140": {
    def: 139.98,
    dmgred: 204.60,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Naght Sieger Lv.140": {
    def: 212.68,
    dmgred: 272.80,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Observation Lv.140": {
    def: 146.68,
    dmgred: 272.80,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Neutral"
  },
  "Skeggiold Lv.140": {
    def: 172.98,
    dmgred: 204.60,
    sizeMob: "Small",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Queen Scaraba Lv.140": {
    def: 212.30,
    dmgred: 268.70,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Faceworm Queen Lv.140": {
    def: 245.30,
    dmgred: 268.70,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Poison"
  },
  "Ktullanux Lv.140": {
    def: 256.50,
    dmgred: 542.27,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Water"
  },
  "Shelter Lv.140": {
    def: 251.18,
    dmgred: 258.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Phreeoni Lv.150": {
    def: 136.61930000000004,//136.62,
    dmgred: 311.1982999999999,//311.20019999999994,//311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mistress Lv.150": {
    def: 161.9804,//161.98,
    dmgred: 361.0001,//361.00,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eddga Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Kraken Lv.150": {
    def: 161.98029000000008,//161.98,
    dmgred: 361.00016999999957,//361.00,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Maya Lv.150": {
    def: 118.76800000000033,//118.76,
    dmgred: 186.69310000000044,//186.70,
    sizeMob: "Large",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Orc Hero Lv.150": {
    def: 110.66980000000007,//110.67,
    dmgred: 261.3984999999999,//261.40,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Pharaoh Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Shadow"
  },
  "Orc Lord Lv.150": {
    def: 110.66980000000007, //110.67,
    dmgred: 261.3984999999999, //261.40,    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Doppelganger Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Amon Ra Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Demi-Human",
    attributeMob: "Earth"
  },
  "Morroc Lv.150": {
    def: 169.17,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Time Holder Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Tao Gunka Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Neutral"
  },
  "Lost Dragon Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Fallen Bishop Lv.150": {
    def: 196.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Lord of the Dead Lv.150": {
    def: 169.17,
    dmgred: 261.40,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Arc Angeling Lv.150": {
    def: 196.75721000000007,//196.76,
    dmgred: 186.697,//186.70,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Gioia Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Wind"
  },
  "RSX-0806 Lv.150": {
    def: 293.16,
    dmgred: 317.00,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Neutral"
  },
  "Nidhoggr's Shadow Lv.150": {
    def: 228.13,
    dmgred: 266.00,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Shadow"
  },
  "Gloom Under Night Lv.150": {
    def: 357.57,
    dmgred: 367.00,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Ghost"
  },
  "Retribution Lv.150": {
    def: 299.07,
    dmgred: 367.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Shadow"
  },
  "Dragon Fly Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Wind"
  },
  "Eclipse Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Small",
    raceMob: "Brute",
    attributeMob: "Neutral"
  },
  "Mastering Lv.150": {
    def: 161.98,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Plant",
    attributeMob: "Water"
  },
  "Ghostring Lv.150": {
    def: 136.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Toad Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Small",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "King Dramoh Lv.150": {
    def: 110.66960000000016,//110.67,
    dmgred: 261.37909999975295,//261.40,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Angeling Lv.150": {
    def: 118.76,
    dmgred: 186.70,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Deviling Lv.150": {
    def: 110.66,
    dmgred: 261.40,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Shadow"
  },
  "Dark Priest Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Demon",
    attributeMob: "Undead"
  },
  "Vagabond Wolf Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Medium",
    raceMob: "Brute",
    attributeMob: "Earth"
  },
  "Chimera Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Brute",
    attributeMob: "Fire"
  },
  "Mysteltainn Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Ogretooth Lv.150": {
    def: 259.48,
    dmgred: 385.89,
    sizeMob: "Medium",
    raceMob: "Formless",
    attributeMob: "Shadow"
  },
  "Necromancer Lv.150": {
    def: 169.17,
    dmgred: 272.00,
    sizeMob: "Medium",
    raceMob: "Undead",
    attributeMob: "Undead"
  },
  "Coelacanth Lv.150": {
    def: 175.62,
    dmgred: 311.20,
    sizeMob: "Large",
    raceMob: "Fish",
    attributeMob: "Water"
  },
  "Naght Sieger Lv.150": {
    def: 259.48,
    dmgred: 361.00,
    sizeMob: "Large",
    raceMob: "Demon",
    attributeMob: "Ghost"
  },
  "Observation Lv.150": {
    def: 181.48,
    dmgred: 361.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Neutral"
  },
  "Skeggiold Lv.150": {
    def: 214.62,
    dmgred: 311.20,
    sizeMob: "Small",
    raceMob: "Angel",
    attributeMob: "Holy"
  },
  "Queen Scaraba Lv.150": {
    def: 258.55,
    dmgred: 351.40,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Earth"
  },
  "Faceworm Queen Lv.150": {
    def: 297.55,
    dmgred: 351.40,
    sizeMob: "Small",
    raceMob: "Insect",
    attributeMob: "Poison"
  },
  "Ktullanux Lv.150": {
    def: 299.07,
    dmgred: 575.77,
    sizeMob: "Large",
    raceMob: "Dragon",
    attributeMob: "Water"
  },
  "Shelter Lv.150": {
    def: 293.16,
    dmgred: 317.00,
    sizeMob: "Medium",
    raceMob: "Angel",
    attributeMob: "Holy"
  }
};

// ========== CENTRALIZED STATE ==========
const AppState = (() => {
  const state = {
    isResultShown: false,
    isTestReaperActive: false,
    isTestSpearActive: false,
    isFlashActive: false,
    currentAnimatingWeapon: null
  };
  const listeners = new Set();
  let cleanupInterval = null;

  const toggleCleanup = (start) => {
    if (start && !cleanupInterval) {
      cleanupInterval = setInterval(() => listeners.size === 0 && (clearInterval(cleanupInterval), cleanupInterval = null), 60000);
    } else if (!start && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  return {
    get: (key) => state[key],
    set: (key, value) => {
      if (state[key] === value) return false;
      const old = state[key];
      state[key] = value;
      listeners.forEach(fn => {
        try {
          fn(key, value, old);
        } catch {
          listeners.delete(fn);
        }
      });
      return true;
    },
    reset: () => Object.keys(state).forEach(k => state[k] = typeof state[k] === 'boolean' ? false : null),
    subscribe: (fn) => {
      if (typeof fn !== 'function') return () => {};
      listeners.add(fn);
      listeners.size === 1 && toggleCleanup(true);
      return () => (listeners.delete(fn), listeners.size === 0 && toggleCleanup(false));
    },
    clearListeners: () => (listeners.clear(), toggleCleanup(false)),
    getListenerCount: () => listeners.size
  };
})();

// ========== EVENT MANAGER ==========
const EventManager = (() => {
  const listenersByElement = new WeakMap();
  const listenersById = new Map();
  const namespaces = new Map();
  let id = 0,
    cleanupInterval = null;

  const toggleCleanup = (start) => {
    if (start && !cleanupInterval) {
      cleanupInterval = setInterval(() => {
        Array.from(listenersById.entries())
          .filter(([, l]) => !l?.el || !(l.el instanceof Node) || !document.contains(l.el))
          .forEach(([listenerId]) => remove(listenerId));
      }, 30000);
    } else if (!start && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };

  const add = (el, evt, handler, opts = false) => {
    if (!el?.addEventListener) return null;
    const listenerId = ++id;
    el.addEventListener(evt, handler, opts);
    listenersById.set(listenerId, {
      el,
      evt,
      handler,
      opts
    });

    if (!listenersByElement.has(el)) listenersByElement.set(el, new Set());
    listenersByElement.get(el).add(listenerId);
    listenersById.size === 1 && toggleCleanup(true);
    return listenerId;
  };

  const remove = (listenerId) => {
    const listener = listenersById.get(listenerId);
    if (!listener) return false;

    const {
      el,
      evt,
      handler,
      opts
    } = listener;
    try {
      el?.removeEventListener?.(evt, handler, opts);
    } catch {}
    listenersById.delete(listenerId);

    try {
      const elementListeners = listenersByElement.get(el);
      elementListeners?.delete(listenerId);
      elementListeners?.size === 0 && listenersByElement.delete(el);
    } catch {}

    listenersById.size === 0 && toggleCleanup(false);
    return true;
  };

  const removeFromElement = (el) => {
    if (!el) return 0;
    try {
      const elementListeners = listenersByElement.get(el);
      if (!elementListeners) return 0;
      return Array.from(elementListeners).reduce((count, id) => count + (remove(id) ? 1 : 0), 0);
    } catch {
      return 0;
    }
  };

  const addNS = (namespace, el, evt, handler, opts = false) => {
    const listenerId = add(el, evt, handler, opts);
    if (!listenerId) return null;
    if (!namespaces.has(namespace)) namespaces.set(namespace, new Set());
    namespaces.get(namespace).add(listenerId);
    return listenerId;
  };

  const removeNS = (namespace) => {
    const nsListeners = namespaces.get(namespace);
    if (!nsListeners) return 0;
    const count = Array.from(nsListeners).reduce((c, id) => c + (remove(id) ? 1 : 0), 0);
    namespaces.delete(namespace);
    return count;
  };

  const removeAll = () => {
    toggleCleanup(false);
    listenersById.forEach(({
      el,
      evt,
      handler,
      opts
    }) => {
      try {
        el?.removeEventListener?.(evt, handler, opts);
      } catch {}
    });
    listenersById.clear();
    namespaces.clear();
  };

  const forceCleanup = () => {
    const toRemove = Array.from(listenersById.entries())
      .filter(([, l]) => !l?.el || !(l.el instanceof Node) || !document.contains(l.el))
      .map(([id]) => id);
    toRemove.forEach(remove);
    return toRemove.length;
  };

  return {
    add,
    remove,
    removeFromElement,
    addNS,
    removeNS,
    removeAll,
    forceCleanup
  };
})();

// ========== CALCULATION CORE ==========
const getWeaponSizeModifier = (weapon, size) => {
  if (weapon === 'all' || !weapon) return WEAPON_SIZE_MODIFIER_TABLE;
  return WEAPON_SIZE_MODIFIER_TABLE[weapon]?.[size] ?? 1.0;
};
const getElementCounter = (weaponElem, targetElem) => {
  if (weaponElem === 'all' || !weaponElem) return ELEMENT_COUNTER_TABLE;
  return ELEMENT_COUNTER_TABLE[weaponElem]?.[targetElem || 'Neutral'] ?? 1.0;
};
const getTargetDefenseData = (key) => {
  if (!key) return DEFENSE_TABLE;
  return DEFENSE_TABLE[key] || DEFENSE_TABLE["DUMMY Lvl.0 (0 DEF)"];
};

// ======== CALCULATION  ========
const processMainCalculation = (() => {
  let timeoutId = null;
  let calculationRAF = null;
  let isProcessing = false;
  let executionId = 0;

  const updateUIState = (disabled, text) => {
    DOM_ELEMENTS.submit.disabled = disabled;
    DOM_ELEMENTS.submit.textContent = text;
  };

  const cleanup = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
    if (calculationRAF !== null) {
      cancelAnimationFrame(calculationRAF);
      calculationRAF = null;
    }
  };

  const enableResultButtons = () => {
    [DOM_ELEMENTS.testReaper, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.resetRek].forEach(btn => {
      if (btn) btn.disabled = false;
    });
  };

  const performCalculation = (calculationState) => {
    AppState.set('isResultShown', true);
    lockAllInputs();
    bindInputLockGuard();
    renderMultiplierBreakdown(calculationState);
    generateRecommendationTable(calculationState);
    enableResultButtons();
  };

  const handleCalculationError = (error) => {
    console.error('Calculation error:', error);
    updateUIState(false, "Calculate");
    typeof showSnackbar === 'function' && showSnackbar('Calculation failed. Please check your inputs.');
  };

  return () => {
    if (isProcessing) return;

    cleanup();

    if (!validateRequiredFields()) {
      updateUIState(false, "Calculate");
      return;
    }

    isProcessing = true;
    executionId++;
    const currentId = executionId;

    updateUIState(true, "Calculating...");

    timeoutId = setTimeout(() => {
      timeoutId = null;
      if (currentId !== executionId) return;

      calculationRAF = requestAnimationFrame(() => {
        calculationRAF = null;
        if (currentId !== executionId) return;

        try {
          const calculationState = getCurrentCalculationState();

          if (!validateStatsVsTarget(calculationState)) {
            updateUIState(false, "Calculate");
            return;
          }

          performCalculation(calculationState);
          updateUIState(true, "Calculate");

        } catch (error) {
          handleCalculationError(error);
        } finally {
          if (currentId === executionId) {
            isProcessing = false;
          }
        }
      });
    }, 300);
  };
})();
function getCurrentCalculationState() {
  const safeNum = (el) => el ? (Number(el.value) || 0) : 0;
  const safeStr = (el) => el?.value || '';
  
  const { vesperSet, blueSet, whiteSet, wElem, tAttr } = DOM_ELEMENTS;
  const selectedOption = blueSet.options[blueSet.selectedIndex];
  const blueValue = safeNum(blueSet);
  const optionText = (selectedOption.textContent || '').trim();
  
  const isReaperActive = AppState.get('isTestReaperActive');
  const isSpearActive = AppState.get('isTestSpearActive');
  
  const wElemValue = safeStr(wElem);
  const tAttrValue = safeStr(tAttr);
  
  const state = {
    atkType: safeStr(DOM_ELEMENTS.atkType),
    weapon: safeStr(DOM_ELEMENTS.weapon),
    wElem: wElemValue,
    tDefKey: safeStr(DOM_ELEMENTS.tDef),
    tSize: safeStr(DOM_ELEMENTS.tSize),
    tRace: safeStr(DOM_ELEMENTS.tRace),
    tAttr: tAttrValue,
    vesper: safeNum(vesperSet),
    blue3: optionText.includes('*3') ? blueValue : 0,
    blue8: optionText.includes('*8') ? blueValue : 0,
    white: safeNum(whiteSet),
    baseAttack: safeNum(DOM_ELEMENTS.attack),
    flatDmg: safeNum(DOM_ELEMENTS.flatDmgBns),
    percentageDmg: safeNum(DOM_ELEMENTS.percentageDmgBns),
    pen: safeNum(DOM_ELEMENTS.pen),
    crit: safeNum(DOM_ELEMENTS.crit),
    dmg: safeNum(DOM_ELEMENTS.dmg),
    elemEnh: safeNum(DOM_ELEMENTS.elemEnh),
    sizeEnh: safeNum(DOM_ELEMENTS.sizeEnh),
    race: safeNum(DOM_ELEMENTS.race),
    attr: safeNum(DOM_ELEMENTS.attr),
    dmgStack: safeNum(DOM_ELEMENTS.dmgStack),
    reaperValue: isReaperActive ? ((wElemValue === tAttrValue) || (wElemValue === "Neutral" && !tAttrValue) ? 84 : 28) : 0,
    spearValue: isSpearActive ? 84 : 0
  };
  
  const result = calculateMultiplier(state);
  
  return { ...state, ...result };
};
function calculateMultiplier(state) {
  const {
    atkType = '',
      weapon = '',
      wElem = '',
      tDefKey = '',
      tSize = '',
      tRace = '',
      tAttr = '',
      baseAttack = 0,
      flatDmg = 0,
      percentageDmg = 0,
      pen = 0,
      crit = 0,
      dmg = 0,
      elemEnh = 0,
      sizeEnh = 0,
      race = 0,
      attr = 0,
      vesper = 0,
      blue3 = 0,
      blue8 = 0,
      white = 0,
      dmgStack = 0,
      reaperValue = 0,
      spearValue = 0
  } = state;
  
  const toPercent = (val) => val / 100;
  
  const EXTRA_LABELS = {
    vesper: 'Vesper',
    blue3: 'BlueGroup3',
    white: 'White',
    dmgStack: 'Final DMG Bonus',
    reaperValue: 'Reaper',
    spearValue: 'Spear',
    blue8: 'BlueGroup8'
  };
  
  const { def, dmgred } = getTargetDefenseData(tDefKey);
  const isPenMode = atkType === 'pen';
  
  const calculateAttackFactor = () => {
    if (atkType === 'crit') return toPercent(crit);
    
    if (isPenMode) {
      const rawPen = pen - def;
      if (rawPen > 0) {
        return 1 + toPercent(rawPen >= 150 ? (rawPen * 2 - 150) : rawPen);
      }
    }
    
    return 0;
  };
  
  const atkF = calculateAttackFactor();
  const effDmgVal = dmg - dmgred;
  const sizeMod = getWeaponSizeModifier(weapon, tSize);
  const elemCtr = getElementCounter(wElem, tAttr);
  
  const pctSpearVal = toPercent(spearValue);
  const pctReaperVal = toPercent(reaperValue);
  
  const processExtras = (extrasMap, type) => {
    const items = [];
    const rawValues = [];
    
    Object.entries(extrasMap).forEach(([key, value]) => {
      if (value > 0) {
        const normalized = toPercent(value);
        items.push({
          key: EXTRA_LABELS[key],
          type,
          value: normalized
        });
        rawValues.push(normalized);
      }
    });
    
    const sum = rawValues.reduce((acc, val) => acc + val, 0);
    return { items, sum, factor: 1 + sum };
  };
  
  const extra1 = processExtras({ vesper, blue3, white, dmgStack, reaperValue }, 'extra1');
  const extra2 = processExtras({ spearValue }, 'extra2');
  const extra3 = processExtras({ blue8 }, 'extra3');
  
  const step1 = baseAttack * atkF + (flatDmg * (percentageDmg ? 1 + toPercent(percentageDmg) : 1));
  const step2 = step1 * (1 + toPercent(effDmgVal));
  
  const calcSteps = (e1Factor, e2Factor, e3Factor) => {
    const s3 = step2 * (elemCtr + toPercent(elemEnh));
    const s4 = s3 * (1 + (tAttr ? toPercent(attr) : 0));
    const s5 = s4 * (1 + (tRace ? toPercent(race) : 0));
    const s6 = s5 * e1Factor;
    const s7 = s6 * e2Factor;
    const s8 = s7 * e3Factor;
    return s8 * (sizeMod + toPercent(sizeEnh));
  };
  
  const mult = calcSteps(extra1.factor, extra2.factor, extra3.factor);
  
  const extra1FactorNoReaper = 1 + (extra1.sum - pctReaperVal);
  const extra2FactorNoSpear = 1 + (extra2.sum - pctSpearVal);
  
  const multNoSpear = calcSteps(extra1.factor, extra2FactorNoSpear, extra3.factor);
  const multNoReaper = calcSteps(extra1FactorNoReaper, extra2.factor, extra3.factor);
  const multNoReaperSpear = calcSteps(extra1FactorNoReaper, extra2FactorNoSpear, extra3.factor);
  
  const calculatePct = (base, comparison) =>
    comparison > 0 ? ((base - comparison) / comparison * 100) : 0;
  
  const pctSpear = calculatePct(mult, multNoSpear);
  const pctReaper = calculatePct(mult, multNoReaper);
  const pctReaperSpear = calculatePct(mult, multNoReaperSpear);
  
  const resultGroups = [];
  [extra1, extra2, extra3].forEach((extra) => {
    resultGroups.push(...extra.items);
    if (extra.sum > 0) {
      resultGroups.push({ type: extra.items[0]?.type, sum: extra.sum, factor: extra.factor });
    }
  });
  
  const includeRace = !!(tRace && race > 0);
  const includeAttr = !!(tAttr && attr > 0);
  const includeExtra = extra1.sum > 0;
  const includeExtraTwo = extra2.sum > 0;
  const includeExtraThree = extra3.sum > 0;
  
  const buildFactorItem = (key, label, val, mult, options = {}) => ({
    key,
    label,
    val,
    mult,
    ...options
  });
  
  const factorList = [
    buildFactorItem('attackAndType', isPenMode ? 'Attack + Type (PEN)' : 'Attack + Type (CRIT)', { baseAttack, flatDmg, percentageDmg, typeVal: isPenMode ? pen : crit, atkF, def }, step1, { isPenMode }),
    buildFactorItem('dmg', 'Final P/M DMG BNS', dmg, 1 + toPercent(effDmgVal)),
    buildFactorItem('elem', 'Element', elemEnh, elemCtr + toPercent(elemEnh), { extra: `counter ${elemCtr}` }),
    buildFactorItem('size', 'Size', sizeEnh, sizeMod + toPercent(sizeEnh), { extra: `mod ${sizeMod}` }),
    buildFactorItem('attr', 'Attribute', attr, 1 + toPercent(attr), { show: includeAttr }),
    buildFactorItem('race', 'Race', race, 1 + toPercent(race), { show: includeRace }),
    buildFactorItem('extra', 'Extra#1', extra1.sum, extra1.factor, { show: includeExtra }),
    buildFactorItem('extraTwo', 'Extra#2', extra2.sum, extra2.factor, { show: includeExtraTwo }),
    buildFactorItem('extraThree', 'Extra#3', extra3.sum, extra3.factor, { show: includeExtraThree }),
    buildFactorItem('contribution', 'Flash Contribution', undefined, undefined, { show: pctSpear > 0 || pctReaper > 0 })
  ];
  
  
  return {
    mult,
    pctSpear,
    pctReaper,
    pctReaperSpear,
    def,
    dmgred,
    effDmgVal,
    atkF,
    sizeModifier: sizeMod,
    elementCounter: elemCtr,
    breakdownData: {
      factorList,
      isPenMode,
      includeRace,
      includeAttr,
      includeExtra,
      includeExtraTwo,
      includeExtraThree
    },
    parts: {
      baseMult: mult,
      extraGroups: resultGroups,
      extra1Factor: extra1.factor,
      extra2Factor: extra2.factor,
      extra3Factor: extra3.factor,
      extra1Sum: extra1.sum,
      extra2Sum: extra2.sum,
      extra3Sum: extra3.sum
    }
  };
};

// ======== BREAKDOWN ========
const NumberFormatter = {
  format(n, showFullPrecision) {
    const num = Number(n) || 0;
    const absNum = Math.abs(num);
    const isInteger = num % 1 === 0;
    
    if (showFullPrecision) {
      if (isInteger || absNum >= 99999) return num.toString();
      return num.toFixed(6).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
    }
    
    if (absNum > 99999) {
      const divisor = absNum >= 1e6 ? 1e6 : 1e3;
      return `${Math.floor(num / divisor)}${divisor === 1e6 ? 'M' : 'K'}`;
    }
    
    return isInteger ? num.toString() : (Math.floor(num * 100) / 100).toString();
  }
};
const PrecisionToggle = {
  formatters: {
    basic: (n, showFull) => NumberFormatter.format(n, showFull),
    withData: (n, showFull) => `<span data-raw-value="${n}">${NumberFormatter.format(n, showFull)}</span>`,
    withBase: (n, showFull) => {
      const display = showFull ? NumberFormatter.format(n, showFull) : Math.floor(n).toString();
      return `<span data-raw-value="${n}" data-is-base="true">${display}</span>`;
    },
    withMult: (n, showFull) => `<span data-raw-mult="${n}">${NumberFormatter.format(n, showFull)}</span>`,
    finalMult: (n, showFull) => {
      const display = showFull ? Math.floor(n).toString() : NumberFormatter.format(n, showFull);
      return `<span data-raw-mult="${n}" data-is-final="true">${display}</span>`;
    }
  },

  create(resultContainer, onToggleCallback) {
    const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";
    const btn = document.createElement('button');
    btn.className = 'toggle-precision job-sim';
    btn.type = 'button';
    btn.textContent = showFullPrecision ? "hide" : "shown";

    const listenerId = EventManager.add(btn, 'click', (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (!resultContainer?.dataset) return;

      const newState = resultContainer.dataset.showFullPrecision === "1" ? "0" : "1";
      const isPrecise = newState === "1";

      resultContainer.dataset.showFullPrecision = newState;
      btn.textContent = isPrecise ? "hide" : "shown";
      onToggleCallback(isPrecise);

      if (typeof showSnackbar === 'function') {
        showSnackbar(`${isPrecise ? "Precise" : "Rounded"} numbers displayed`);
      }
    });

    btn.dataset.listenerId = listenerId;
    return btn;
  },

  refreshNumbers(container, showFullPrecision) {
    if (!container) return;
    
    container.querySelectorAll('[data-raw-value]').forEach(el => {
      const rawVal = parseFloat(el.dataset.rawValue);
      el.textContent = el.dataset.isBase === "true" && !showFullPrecision ?
        Math.floor(rawVal).toString() :
        NumberFormatter.format(rawVal, showFullPrecision);
    });
    
    container.querySelectorAll('[data-raw-mult]').forEach(el => {
      const rawVal = parseFloat(el.dataset.rawMult);
      const isFinal = el.dataset.isFinal === "true";
      
      el.textContent = isFinal && showFullPrecision ?
        Math.floor(rawVal).toString() :
        NumberFormatter.format(rawVal, showFullPrecision);
    });
  }
};
function renderMultiplierBreakdown(calculationState) {
  if (!AppState.get('isResultShown')) return;

  const resultContainer = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";
  const fmt = PrecisionToggle.formatters;
  const wrapCode = (content) => `<code>${content}</code>`;
  const buildFormula = (parts, result) => `${parts} → ${wrapCode(result)}`;

  const {
    mult, def, dmgred, wElem, tAttr, tSize, weapon, tRace, vesper, blue3, blue8, white,
    tDefKey, elementCounter, sizeModifier, percentageDmg, flatDmg, baseAttack,
    parts = {}, breakdownData = {}
  } = calculationState;

  const { extraGroups = [], extra1Factor = 1, extra2Factor = 1, extra3Factor = 1 } = parts;
  const { factorList = [], isPenMode = false } = breakdownData;

  const LABELS = {
    'Vesper': 'Vesper SET',
    'BlueGroup3': 'Blue SET (Ferocity)',
    'BlueGroup8': 'Blue SET',
    'White': 'White SET (110*3)',
    'Reaper': 'Reaper Scythe',
    'Spear': 'Divinity#1 Flash: Spear of Eternity'
  };

  const extras = {
    extra1: { items: [], factor: extra1Factor },
    extra2: { items: [], factor: extra2Factor },
    extra3: { items: [], factor: extra3Factor }
  };

  extraGroups.forEach(group => {
    const type = group.type;
    if ('sum' in group && 'factor' in group) {
      extras[type].factor = group.factor;
    } else if ('key' in group && 'value' in group) {
      extras[type].items.push(group);
    }
  });

  const isNote = (text) =>
    text.includes('Tools assume') || text.includes('uptime') ||
    text.includes('Elements') || text.includes('This bonus');

  const buildLines = (lines) =>
    lines.map(line => `<li${isNote(line) ? ' class="note"' : ''}>${line}</li>`).join('');

  const buildExtraSection = (extraType, title) => {
    const extraData = extras[extraType];
    const lines = [];
    const values = [];

    extraData.items.forEach(item => {
      const label = LABELS[item.key] || item.key;
      const valPercent = fmt.withData(item.value * 100, showFullPrecision);

      if (item.key === 'Reaper') {
        lines.push(
          `${label}: ${wElem} vs ${tAttr || 'Neutral'} <button type="button" id="reaperTips" class="tooltip-button"></button>`,
          `${valPercent} / 100`
        );
      } else if (item.key === 'Spear') {
        lines.push(
          `${LABELS[item.key]} <button type="button" id="spearTips" class="tooltip-button"></button>`,
          `${valPercent} / 100`
        );
      } else {
        let display = `${label}: ${valPercent}`;

        switch (item.key) {
          case 'Vesper':
            if (vesper) display = `${label}: Tier ${(vesper-8)/8}`;
            break;
          case 'BlueGroup3':
            if (blue3) display = `${label}: Level ${4*blue3+10}*3`;
            break;
          case 'White':
            if (white) display = `${label}: Tier ${(white-30)/6}`;
            break;
          case 'BlueGroup8':
            if (blue8) display = `${label}: Level ${2*blue8+20}*8`;
            break;
        }

        lines.push(display, `${valPercent} / 100`);
      }
      values.push(fmt.withData(item.value, showFullPrecision));
    });

    lines.push(buildFormula(`1 + ${values.join(' + ')}`, `×${fmt.withMult(extraData.factor, showFullPrecision)}`));
    return { title, lines };
  };

  const buildFactor = (factor) => {
    if (factor.show === false) return { html: null, raw: null };

    let factorData = null;

    switch (factor.key) {
      case 'attackAndType': {
        const { baseAttack, flatDmg, percentageDmg, typeVal, atkF, def } = factor.val;
        const lines = [];
        
        if (baseAttack > 0) lines.push(`Attack: ${baseAttack}`);
        if (flatDmg > 0) {
          lines.push(`Raw Damage Bonus: ${fmt.withData(flatDmg, showFullPrecision)}`);
          if (percentageDmg > 0) lines.push(`Percentage DMG Bonus: ${fmt.withData(percentageDmg, showFullPrecision)}`);
        }
        
        if (isPenMode) {
          lines.push(
            `Raw PEN + Final PEN: ${fmt.withData(typeVal, showFullPrecision)}`,
            `Target DEF: ${fmt.withData(def, showFullPrecision)}`
          );
        } else {
          lines.push(`Crit DMG: ${fmt.withData(typeVal, showFullPrecision)}`);
        }
        
        const baseCalc = baseAttack || 0;
        const flatCalc = flatDmg || 0;
        const pctCalc = percentageDmg || 0;
        const formulaParts = [];
        
        if (baseCalc > 0 || atkF > 0) {
          if (isPenMode) {
            const rawBasePen = typeVal - def;
            if (rawBasePen >= 150) {
              formulaParts.push(
                `${baseCalc} × [ 1 + [ ( ${fmt.withData(typeVal, showFullPrecision)} - ${fmt.withData(def, showFullPrecision)} ) × 2 - 150 ] / 100 ]`
              );
            } else if (rawBasePen > 0) {
              formulaParts.push(
                `${baseCalc} × [ 1 + ( ${fmt.withData(typeVal, showFullPrecision)} - ${fmt.withData(def, showFullPrecision)} ) / 100 ]`
              );
            } else {
              formulaParts.push(`${baseCalc}`);
            }
          } else {
            formulaParts.push(`${baseCalc} × [ ${fmt.withData(typeVal, showFullPrecision)} / 100 ]`);
          }
        }
        
        if (flatCalc > 0) {
          formulaParts.push(pctCalc > 0
            ? `${fmt.withData(flatCalc, showFullPrecision)} × [ 1 + ( ${fmt.withData(pctCalc, showFullPrecision)} / 100 ) ]`
            : `${fmt.withData(flatCalc, showFullPrecision)}`);
        }
        
        lines.push(buildFormula(formulaParts.join(' + '), fmt.withBase(factor.mult, showFullPrecision)));
        factorData = {
          title: isPenMode ? `Attack Type (PEN) vs ${tDefKey}` : `Attack + Type (CRIT) vs ${tDefKey}`,
          lines
        };
        break;
      }

      case 'dmg':
        factorData = {
          title: 'Final P/M Damage Bonus',
          lines: [
            `P/M BO: ${fmt.withData(calculationState.dmg, showFullPrecision)}`,
            `Target Reduction: ${fmt.withData(dmgred, showFullPrecision)}`,
            buildFormula(
              `1 + ( ${fmt.withData(calculationState.dmg, showFullPrecision)} - ${fmt.withData(dmgred, showFullPrecision)} ) / 100`,
              `×${fmt.withMult(factor.mult, showFullPrecision)}`
            )
          ]
        };
        break;

      case 'elem':
        factorData = {
          title: `Element: ${wElem} vs ${tAttr || "Neutral<button type='button' id='elemCtrTips' class='tooltip-button'></button>"}`,
          lines: [
            `Counter: ${fmt.withData(elementCounter, showFullPrecision)}`,
            `${wElem} Enhance: ${fmt.withData(factor.val, showFullPrecision)}`,
            buildFormula(
              `${fmt.withData(elementCounter, showFullPrecision)} + ${fmt.withData(factor.val, showFullPrecision)} / 100`,
              `×${fmt.withMult(factor.mult, showFullPrecision)}`
            )
          ]
        };
        break;

      case 'size':
        factorData = {
          title: `Size: ${weapon} vs ${tSize}`,
          lines: [
            `Modifier: ${fmt.withData(sizeModifier, showFullPrecision)}`,
            `${tSize} Enhance: ${fmt.withData(factor.val, showFullPrecision)}`,
            buildFormula(
              `${fmt.withData(sizeModifier, showFullPrecision)} + ${fmt.withData(factor.val, showFullPrecision)} / 100`,
              `×${fmt.withMult(factor.mult, showFullPrecision)}`
            )
          ]
        };
        break;

      case 'race':
        factorData = {
          title: `Race: ${tRace}`,
          lines: [
            `DMG to ${tRace}: ${fmt.withData(factor.val, showFullPrecision)}`,
            buildFormula(
              `1 + ${fmt.withData(factor.val, showFullPrecision)} / 100`,
              `×${fmt.withMult(factor.mult, showFullPrecision)}`
            )
          ]
        };
        break;

      case 'attr':
        factorData = {
          title: `Attribute: ${tAttr}`,
          lines: [
            `DMG to ${tAttr} Attribute: ${fmt.withData(factor.val, showFullPrecision)}`,
            buildFormula(
              `1 + ${fmt.withData(factor.val, showFullPrecision)} / 100`,
              `×${fmt.withMult(factor.mult, showFullPrecision)}`
            )
          ]
        };
        break;

      case 'extra':
        factorData = buildExtraSection('extra1', 'Final DMG Bonus');
        break;

      case 'extraTwo':
        factorData = buildExtraSection('extra2', 'Bonus DMG to Normal Monster, MVP/MINI, and BOS');
        break;

      case 'extraThree':
        factorData = buildExtraSection('extra3', 'Bonus DMG to MVP/MINI, and BOS');
        break;

      case 'contribution': {
        const hasSpear = calculationState.pctSpear > 0;
        const hasReaper = calculationState.pctReaper > 0;

        if (!hasSpear && !hasReaper) return { html: '', raw: null };

        const formatBoost = (value) => `<code>≈${Math.trunc(value/2)}%</code>`;
        const createLine = (label, value) => `${label}: ${formatBoost(value)}`;
        const lines = [];

        if (hasSpear && hasReaper) {
          lines.push(
            createLine('Spear Flash', calculationState.pctSpear) + ' damage boost.',
            createLine('Reaper Flash', calculationState.pctReaper) + ' damage boost.',
            `Both flashes gives you ${formatBoost(calculationState.pctReaperSpear)} total damage increase.`
          );
        } else if (hasSpear) {
          lines.push(`Spear Flash boost: ${formatBoost(calculationState.pctSpear)}`);
        } else {
          lines.push(`Reaper Flash boost: ${formatBoost(calculationState.pctReaper)}`);
        }

        factorData = {
          title: "How Much Flash Boosts Your Damage<button type='button' id='flashTips' class='tooltip-button'></button>",
          lines
        };
        break;
      }

      default:
        return {
          html: `<li>${factor.label}: ${fmt.withData(factor.val, showFullPrecision)} → ${wrapCode(`×${fmt.withMult(factor.mult, showFullPrecision)}`)}</li>`,
          raw: factor.mult
        };
    }

    return {
      html: `<li>${factorData.title}<ul>${buildLines(factorData.lines)}</ul></li>`,
      raw: factor.mult
    };
  };

  const factorHTML = [];
  let baseValue = null;
  const multipliers = [];

  factorList.forEach((factor) => {
    const result = buildFactor(factor);
    factorHTML.push(result.html);
    
    if (factor.show === false || factor.key === 'contribution') return;
    
    if (factor.key === 'attackAndType') {
      baseValue = factor.mult;
    } else {
      multipliers.push(factor.mult);
    }
  });

  const displayParts = [];
  if (baseValue !== null) displayParts.push(fmt.withBase(baseValue, showFullPrecision));
  multipliers.forEach(m => displayParts.push(`× ${fmt.withMult(m, showFullPrecision)}`));
  
  const targetInfo = [tSize, tRace, tAttr].filter(Boolean).join(" + ");
  const bq1Text = `By default, every factor starts at ×1.00<button type='button' id='breakdownTips' class='tooltip-button'></button>\nNumbers`;
  const bq1Suffix = document.createTextNode(" how it changes with your stats.");

  const precisionBtn = PrecisionToggle.create(
    resultContainer,
    (showFullPrecision) => {
      PrecisionToggle.refreshNumbers(resultContainer, showFullPrecision);
      PrecisionToggle.refreshNumbers(DOM_ELEMENTS.rec, showFullPrecision);
    }
  );

  const swapSelect = dropdownManager.createSwapSelect(calculationState, isPenMode);

  resultContainer.querySelectorAll('[data-listener-id]').forEach(el => {
    const id = el.dataset.listenerId;
    if (id) EventManager.remove(parseInt(id));
  });

  resultContainer.innerHTML = `
    <div class="multiplier-breakdown" id="multiplier-breakdown">
      <blockquote class="noted">${bq1Text.replace(/\n/g, '<br>')}</blockquote>
      <ul class="factor-breakdown">${factorHTML.join('')}</ul>
      <hr class="separ">
      <div class="breakdown-swap-wrapper" id="swap-wrapper"></div>
      <p class="sum-head">Your basic attack to <i>${targetInfo} (${tDefKey})</i></p>
      <div class="last-calc">${displayParts.join(" ")}<br>≈${wrapCode(fmt.finalMult(mult, showFullPrecision))}<button type="button" id="attackTips" class="calcTips tooltip-button"></button></div>
      <blockquote class="noted">Real output depends on class, skills, buffs (vesper, blue, or white stack), and more. More accurate? Just use <a class="job-sim" target="_blank" href="//discord.com/channels/784407151342256148/909016309218561568/1407521807459811328">job sim!</a></blockquote>
    </div>`;

  const bq1 = resultContainer.querySelector('.noted');
  bq1.appendChild(precisionBtn);
  bq1.appendChild(bq1Suffix);
  resultContainer.querySelector('#swap-wrapper').appendChild(swapSelect);
};

// ======== RECOMMENDATION ========
const RandomGenerator = (() => {
  const SIZE = 500;
  let cache = new Float64Array(SIZE);
  let idx = 0;
  
  const refill = () => {
    for (let i = 0; i < SIZE; i++) cache[i] = Math.random();
    idx = 0;
  };
  
  refill();
  
  return {
    get: () => (idx >= SIZE && refill(), cache[idx++]),
    reset: refill
  };
})();
const RECOMMENDATION_CONFIG = {
  randomMode: 'clamp',
  maxAttempts: 500,
  centerScale: 0.25,
  jitter: 0.12,
  jitterStep: 0.025,
  jitterStepEvery: 35,
  jitterMax: 0.50,
  clampMaxFraction: 3.5,
  clampMaxAbsolute: 0.20,
  upDownThreshold: 3,
  raceAttrCap: 310,
  raceAttrSoloCap: 250,
  raceAttrTol: 6,
  smallThreshold: 115,
  smallMin: 85,
  smallExp: 0.75,
  ratioMin: 0.32,
  ratioMax: 0.64,
  ratioNoise: 0.12,
  bias: { main: 1.0, dmg: 0.95, elem: 0.90, size: 0.90, race: 0.72, attr: 0.72 },
  cats: [
    { label: '6-12%', min: 1.06, max: 1.12 },
    { label: '18-24%', min: 1.18, max: 1.24 },
    { label: '32-48%', min: 1.32, max: 1.48 },
    { label: '64-128%', min: 1.64, max: 2.28 }
  ],
  forSmallCats: [
    { label: '84-168%', min: 1.84, max: 2.68 },
    { label: '180-270%', min: 2.80, max: 3.70 },
    { label: '320-480%', min: 4.32, max: 5.80 },
    { label: '510-720%', min: 6.10, max: 8.20 }
  ]
};
const calculateRecommendationWeights = (params) => {
  if (!AppState.get('isResultShown')) return;
  
  const { includeRace, includeAttr, baseMain, baseDmg, baseElem, baseSize, baseRace, baseAttr } = params;
  const { bias, smallExp, smallMin, raceAttrCap } = RECOMMENDATION_CONFIG;
  
  const weights = [
    baseMain * bias.main,
    baseDmg * bias.dmg,
    baseElem * bias.elem,
    baseSize * bias.size
  ];
  
  const maxWeight = Math.max(...weights, 1);
  const coreSum = Math.max(weights.reduce((sum, w) => sum + w / maxWeight, 0), 0.0001);
  const hasAdditional = includeRace || includeAttr;
  const coreShare = hasAdditional ? 0.75 : 1.0;
  
  const finalWeights = {
    main: (weights[0] / maxWeight / coreSum) * coreShare,
    dmg: (weights[1] / maxWeight / coreSum) * coreShare,
    elem: (weights[2] / maxWeight / coreSum) * coreShare,
    size: (weights[3] / maxWeight / coreSum) * coreShare,
    race: 0,
    attr: 0
  };
  
  if (!hasAdditional) {
    const totalSum = Object.values(finalWeights).reduce((a, b) => a + b, 0);
    Object.keys(finalWeights).forEach(k => finalWeights[k] /= totalSum);
    return finalWeights;
  }
  
  const additionalShare = 1 - coreShare;
  const effectiveRace = includeRace ? Math.max(Math.pow(baseRace, smallExp), smallMin) : 0;
  const effectiveAttr = includeAttr ? Math.max(Math.pow(baseAttr, smallExp), smallMin) : 0;
  const raceAvailable = includeRace && effectiveRace > 0 && effectiveRace < raceAttrCap;
  const attrAvailable = includeAttr && effectiveAttr > 0 && effectiveAttr < raceAttrCap;
  
  if (raceAvailable && attrAvailable) {
    const combinedSum = effectiveRace + effectiveAttr;
    finalWeights.race = (effectiveRace / combinedSum) * additionalShare;
    finalWeights.attr = (effectiveAttr / combinedSum) * additionalShare;
  } else if (raceAvailable) {
    finalWeights.race = additionalShare;
  } else if (attrAvailable) {
    finalWeights.attr = additionalShare;
  } else {
    const redistribution = additionalShare * 0.25;
    ['main', 'dmg', 'elem', 'size'].forEach(k => finalWeights[k] += redistribution);
  }
  
  const totalSum = Object.values(finalWeights).reduce((a, b) => a + b, 0);
  Object.keys(finalWeights).forEach(k => finalWeights[k] /= totalSum);
  
  return finalWeights;
};
function generateRecommendationTable(gameState) {
  if (!AppState.get('isResultShown')) return;

  const cfg = RECOMMENDATION_CONFIG;
  const resultContainer = DOM_ELEMENTS.hasil;
  const showFullPrecision = resultContainer?.dataset?.showFullPrecision === "1";
  const fmt = PrecisionToggle.formatters;

  const generateRandomValue = (baseValue, jitter = cfg.jitter) => {
    const { randomMode, clampMaxFraction, clampMaxAbsolute } = cfg;

    if (randomMode === 'clamp') {
      const delta = (RandomGenerator.get() * 2 - 1) * jitter;
      const maxClamp = Math.min(clampMaxFraction * jitter, clampMaxAbsolute);
      const clampedDelta = Math.max(Math.min(delta, maxClamp), -maxClamp);
      return Math.max(0, baseValue * (1 + clampedDelta));
    }

    if (randomMode === 'normal') {
      let u1 = 0, u2 = 0;
      while (u1 === 0) u1 = RandomGenerator.get();
      while (u2 === 0) u2 = RandomGenerator.get();
      const normalValue = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return Math.max(0, baseValue * (1 + normalValue * jitter * 0.5));
    }

    //return Math.max(0, baseValue * (1 + (RandomGenerator.get() * 2 - 1) * jitter));
  };

  const applySmallValueAdjustment = (value, raceValue, attrValue) => {
    const combinedTotal = raceValue + attrValue;
    return (combinedTotal > 0 && combinedTotal < cfg.smallThreshold) ?
      Math.max(Math.pow(value, cfg.smallExp), cfg.smallMin) : value;
  };

  const getMaxAllowedValue = (userValue, capLimit, tolerance, isSmall) =>
    userValue >= capLimit ? (isSmall ? capLimit + tolerance : userValue + tolerance) : capLimit;

  const avoidCapLimit = (value, capLimit) =>
    value < capLimit ? value : capLimit - (capLimit * (0.01 + RandomGenerator.get() * 0.02));

  const avoidRoundTen = (value) => {
    const rounded = Math.round(value);
    return rounded % 10 === 0 ? rounded + 1 : rounded;
  };

  const getCellClass = (currentValue, baseValue) => {
    const diff = Math.round(+currentValue || 0) - Math.round(+baseValue || 0);
    return diff >= cfg.upDownThreshold ? 'up' : diff <= -cfg.upDownThreshold ? 'down' : 'neutral';
  };

  const isPenMode = gameState.atkType === 'pen';
  const { tRace, tAttr } = gameState;
  const raceVal = +gameState.race || 0;
  const attrVal = +gameState.attr || 0;
  const shouldIncludeRace = !!(tRace && raceVal > 0);
  const shouldIncludeAttr = !!(tAttr && attrVal > 0);
  const originalMult = +gameState.mult || 1;

  const userStats = {
    main: isPenMode ? (+gameState.pen || 0) : (+gameState.crit || 0),
    dmg: +gameState.dmg || 0,
    size: +gameState.sizeEnh || 0,
    elem: +gameState.elemEnh || 0,
    attr: shouldIncludeAttr ? attrVal : 0,
    race: shouldIncludeRace ? raceVal : 0
  };

  const statWeights = calculateRecommendationWeights({
    includeRace: shouldIncludeRace,
    includeAttr: shouldIncludeAttr,
    baseMain: userStats.main,
    baseDmg: userStats.dmg,
    baseElem: userStats.elem,
    baseSize: userStats.size,
    baseRace: userStats.race,
    baseAttr: userStats.attr
  });

  const centeredValues = {
    main: userStats.main * (1 + statWeights.main * cfg.centerScale),
    dmg: userStats.dmg * (1 + statWeights.dmg * cfg.centerScale),
    elem: userStats.elem * (1 + statWeights.elem * cfg.centerScale),
    size: userStats.size * (1 + statWeights.size * cfg.centerScale)
  };

  const raceAttrSum = userStats.race + userStats.attr;
  const adjustedRace = shouldIncludeRace ? applySmallValueAdjustment(userStats.race, userStats.race, userStats.attr) : 0;
  const adjustedAttr = shouldIncludeAttr ? applySmallValueAdjustment(userStats.attr, userStats.race, userStats.attr) : 0;

  const raceAttrValues = {
    race: shouldIncludeRace ? Math.min(adjustedRace * (1 + statWeights.race * cfg.centerScale), cfg.raceAttrCap) : 0,
    attr: shouldIncludeAttr ? Math.min(adjustedAttr * (1 + statWeights.attr * cfg.centerScale), cfg.raceAttrCap) : 0,
    adjustedRace,
    adjustedAttr
  };

  const hasSmallCombined = shouldIncludeRace && shouldIncludeAttr && raceAttrSum > 0 && raceAttrSum < cfg.smallThreshold;
  const categories = hasSmallCombined ? cfg.forSmallCats : cfg.cats;

  const mainStatLabel = isPenMode ? 'PEN' : 'CRIT';
  const columnHeaders = ['STAT', mainStatLabel, 'P/M BO', 'Element', 'Size'];
  if (shouldIncludeRace) columnHeaders.push('Race');
  if (shouldIncludeAttr) columnHeaders.push('Attribute');
  columnHeaders.push('Result', '\u2206');

  const tablesHTML = [];
  const headerRow = columnHeaders.map(h => `<th>${h}</th>`).join('');

  const userTotal = userStats.race + userStats.attr;
  const boostedTotal = raceAttrValues.adjustedRace + raceAttrValues.adjustedAttr;
  const isSmallTotal = userTotal > 0 && userTotal < cfg.smallThreshold;
  const maxTotal = shouldIncludeRace && shouldIncludeAttr ? getMaxAllowedValue(userTotal, cfg.raceAttrCap, cfg.raceAttrTol, isSmallTotal) : 0;

  const userSingle = shouldIncludeRace ? userStats.race : userStats.attr;
  const boostedSingle = shouldIncludeRace ? raceAttrValues.adjustedRace : raceAttrValues.adjustedAttr;
  const isSmallSingle = userSingle > 0 && userSingle < cfg.smallThreshold;
  const maxSingle = (shouldIncludeRace || shouldIncludeAttr) && !(shouldIncludeRace && shouldIncludeAttr) ?
    getMaxAllowedValue(userSingle, cfg.raceAttrSoloCap, cfg.raceAttrTol, isSmallSingle) : 0;

  const calcParams = {
    baseAttack: +gameState.baseAttack || 1,
    flatDmg: +gameState.flatDmg || 0,
    percentageDmg: +gameState.percentageDmg || 0,
    atkType: isPenMode ? 'pen' : 'crit',
    weapon: gameState.weapon || '',
    tSize: gameState.tSize || '',
    wElem: gameState.wElem || '',
    tAttr: tAttr || '',
    tRace: tRace || '',
    tDefKey: gameState.tDefKey || '',
    vesper: +gameState.vesper || 0,
    blue3: +gameState.blue3 || 0,
    blue8: +gameState.blue8 || 0,
    white: +gameState.white || 0,
    dmgStack: +gameState.dmgStack || 0,
    reaperValue: +gameState.reaperValue || 0,
    spearValue: +gameState.spearValue || 0
  };

  for (let catIdx = 0, catLen = categories.length; catIdx < catLen; catIdx++) {
    const category = categories[catIdx];
    const uniqueKeys = new Set();
    const uniqueDeltas = new Set();
    const uniqueComposites = new Set();
    const acceptedRows = [];
    let attempts = 0;
    let currentJitter = cfg.jitter;

    while (acceptedRows.length < 5 && attempts < cfg.maxAttempts) {
      attempts++;

      const statValues = {
        pen: +gameState.pen || 0,
        crit: +gameState.crit || 0,
        dmg: generateRandomValue(centeredValues.dmg, currentJitter),
        elemEnh: generateRandomValue(centeredValues.elem, currentJitter),
        sizeEnh: generateRandomValue(centeredValues.size, currentJitter)
      };

      statValues[isPenMode ? 'pen' : 'crit'] = generateRandomValue(centeredValues.main, currentJitter);

      let raceValue = 0, attrValue = 0;

      if (shouldIncludeAttr && shouldIncludeRace) {
        const randomTotal = avoidCapLimit(Math.min(generateRandomValue(boostedTotal, currentJitter), maxTotal), maxTotal);
        const ratio = cfg.ratioMin + RandomGenerator.get() * (cfg.ratioMax - cfg.ratioMin);
        raceValue = randomTotal * ratio;
        attrValue = randomTotal * (1 - ratio);

        const actualSum = raceValue + attrValue;
        if (actualSum > maxTotal) {
          const scale = avoidCapLimit(maxTotal, maxTotal) / actualSum;
          raceValue *= scale;
          attrValue *= scale;
        }
      } else if (shouldIncludeRace || shouldIncludeAttr) {
        const generatedValue = avoidCapLimit(Math.min(generateRandomValue(boostedSingle, currentJitter), maxSingle), maxSingle);
        if (shouldIncludeRace) raceValue = generatedValue;
        else attrValue = generatedValue;
      }

      const { mult: calculatedMult } = calculateMultiplier({
        ...calcParams,
        pen: +statValues.pen || 0,
        crit: +statValues.crit || 0,
        dmg: +statValues.dmg || 0,
        sizeEnh: +statValues.sizeEnh || 0,
        elemEnh: +statValues.elemEnh || 0,
        race: +raceValue || 0,
        attr: +attrValue || 0
      });

      const ratio = calculatedMult / originalMult;
      if (calculatedMult <= originalMult || ratio < category.min || ratio > category.max) continue;

      const mainVal = avoidRoundTen(isPenMode ? statValues.pen : statValues.crit);
      const dmgVal = avoidRoundTen(statValues.dmg);
      const elemVal = avoidRoundTen(statValues.elemEnh);
      const sizeVal = avoidRoundTen(statValues.sizeEnh);
      const rVal = shouldIncludeRace ? avoidRoundTen(raceValue) : null;
      const aVal = shouldIncludeAttr ? avoidRoundTen(attrValue) : null;

      const rStr = rVal || '-';
      const aStr = aVal || '-';
      const rowKey = `${mainVal}|${dmgVal}|${elemVal}|${sizeVal}|${rStr}|${aStr}`;
      const compositeKey = `${mainVal}|${dmgVal}|${elemVal}|${sizeVal}|${rVal}|${aVal}`;

      if (uniqueKeys.has(rowKey) || uniqueComposites.has(compositeKey)) continue;

      const deltaPercent = ((calculatedMult - originalMult) / originalMult) * 100;
      const roundedDelta = Number(deltaPercent.toFixed(1));
      if (uniqueDeltas.has(roundedDelta)) continue;

      if (mainVal > userStats.main && dmgVal > userStats.dmg && elemVal > userStats.elem && sizeVal > userStats.size &&
        (!shouldIncludeRace || rVal > userStats.race) && (!shouldIncludeAttr || aVal > userStats.attr)) continue;

      uniqueKeys.add(rowKey);
      uniqueDeltas.add(roundedDelta);
      uniqueComposites.add(compositeKey);

      acceptedRows.push({
        main: mainVal,
        dmg: dmgVal,
        elem: elemVal,
        size: sizeVal,
        attr: aVal,
        race: rVal,
        newMultiplier: calculatedMult,
        deltaPercent
      });

      if (acceptedRows.length < 5 && attempts % cfg.jitterStepEvery === 0) {
        currentJitter = Math.min(currentJitter + cfg.jitterStep, cfg.jitterMax);
      }
    }

    if (acceptedRows.length === 0) continue;

    acceptedRows.sort((a, b) =>
      b.deltaPercent - a.deltaPercent || b.newMultiplier - a.newMultiplier || b.main - a.main
    );

    const tableRows = acceptedRows.map((row, i) => {
      const cells = [
        `<td class="build">BUILD#${i + 1}</td>`,
        `<td><span class="${getCellClass(row.main, userStats.main)}">${row.main}</span></td>`,
        `<td><span class="${getCellClass(row.dmg, userStats.dmg)}">${row.dmg}</span></td>`,
        `<td><span class="${getCellClass(row.elem, userStats.elem)}">${row.elem}</span></td>`,
        `<td><span class="${getCellClass(row.size, userStats.size)}">${row.size}</span></td>`
      ];

      if (shouldIncludeRace) cells.push(`<td><span class="${getCellClass(row.race, userStats.race)}">${row.race}</span></td>`);
      if (shouldIncludeAttr) cells.push(`<td><span class="${getCellClass(row.attr, userStats.attr)}">${row.attr}</span></td>`);

      cells.push(
        `<td class="mult">${fmt.finalMult(row.newMultiplier, showFullPrecision)}</td>`,
        `<td class="delta">+${row.deltaPercent.toFixed(1)}%</td>`
      );

      return `<tr>${cells.join('')}</tr>`;
    }).join('');

    const yourStatsCells = [
      '<td class="yours-label">YOURS</td>',
      `<td><span>${userStats.main}</span></td>`,
      `<td><span>${userStats.dmg}</span></td>`,
      `<td><span>${userStats.elem}</span></td>`,
      `<td><span>${userStats.size}</span></td>`
    ];

    if (shouldIncludeRace) yourStatsCells.push(`<td><span>${userStats.race}</span></td>`);
    if (shouldIncludeAttr) yourStatsCells.push(`<td><span>${userStats.attr}</span></td>`);

    yourStatsCells.push(
      `<td class="mult current-mult">${fmt.finalMult(gameState.mult, showFullPrecision)}</td>`,
      `<td id="table-help" class="delta current-delta"><button type='button' id='tableTips' class='tooltip-button'></button></td>`
    );

    const yourStatsRow = `<tr class="your-stats-values">${yourStatsCells.join('')}</tr>`;

    tablesHTML.push(
      `<div class="table-wrapper"><table class="recommend-table"><caption>Increase ${category.label}</caption><tr>${headerRow}</tr><tbody>${tableRows}${yourStatsRow}</tbody></table></div>`
    );
  }

  DOM_ELEMENTS.rec.innerHTML = tablesHTML.join('');
};
const regenerateRecommendations = () => {
  if (AppState.get('isResultShown')) {
    generateRecommendationTable(getCurrentCalculationState());
    if (typeof showSnackbar === 'function') showSnackbar("Table Refreshed!");
  }
};

// ========== DROPDOWN ==========
class DropdownManager {
  constructor() {
    this.constants = {
      formKeys: ['vesperSet', 'whiteSet', 'blueSet', 'tRace', 'tAttr', 'atkType', 'wElem', 'tSize', 'tDef', 'weapon', 'pen', 'crit', 'attack', 'flatDmgBns', 'percentageDmgBns'],
      mobMapping: { sizeMob: 'tSize', raceMob: 'tRace', attributeMob: 'tAttr' },
      disableButtons: ['resetRek', 'testSpear', 'testReaper'],
      calcFields: ['attack','flatDmgBns','percentageDmgBns','dmg', 'dmgStack', 'sizeEnh', 'race', 'attr', 'elemEnh'],
      setKeys: ['blueSet', 'vesperSet', 'whiteSet'],
      dependencyChain: {
        'atkType': ['pen', 'crit', 'attack', 'dmg', 'dmgStack'],
        'attack': ['flatDmgBns'],
        'flatDmgBns': ['percentageDmgBns'],
        'tRace': ['race'],
        'tAttr': ['attr'],
        'tSize': ['sizeEnh'],
        'wElem': ['elemEnh']
      }
    };

    this.config = this.buildConfig();
    this.state = {
      selectionOrder: [],
      lockStates: new Map(),
      isSwapping: false,
      updateTimer: null
    };
    this.namespace = 'dropdown-manager';
    this.isInitialized = false;
    this.init();
  }

  buildConfig() {
    const labelMap = (labels) => Object.fromEntries(labels.map(([k,v]) => [k,v]));
    
    return {
      ...this.constants,
      labels: {
        static: labelMap([
          ['blueSetLabel', "Blue SET"],
          ['vesperSetLabel', "Vesper SET"],
          ['whiteSetLabel', "White SET (110*3)"],
          ['atkTypeLabel', "Attack Type"],
          ['weaponLabel', "Weapon"],
          ['wElemLabel', "Weapon Element"],
          ['tSizeLabel', "Target Size"],
          ['tRaceLabel', "Target Race"],
          ['tAttrLabel', "Target Attribute"],
          ['tDefLabel', "MVP/MINI"],
          ['penLabel', "Final P/M. PEN %"],
          ['critLabel', "Critical DMG Bonus %"],
          ['atkLabel', "P/M. Attack"],
          ['flatDmgBnsLabel', "P/M. Damage Bonus %"],
          ['percentageDmgBnsLabel', "Percentage P/M. Damage Bonus"],
          ['elemEnhLabel', "Element Enhance %"],
          ['sizeLabel', "DMG to Size %"],
          ['raceLabel', "DMG to Race"],
          ['attrLabel', "DMG to Attribute"],
          ['dmgLabel', "Final P/M. Damage Bonus %"],
          ['dmgStackLabel', "Extra: Final Damage Stack %"]
        ]),
        dynamic: {
          vesper: { 48: "BRO?!", 56: "REALLY?!", 64: "Wake UP!", 72: "STOP Dreaming!", 80: "F2P DETECTED!" },
          white: { 36: "Eh?", 42: "WOW", 48: "GG!!", 54: "Have a Nice Day!" }
        }
      },

      fields: {
        atkType: {
          type: 'dropdown',
          options: [{ value: "pen", label: "P/M PEN" }, { value: "crit", label: "CRIT" }],
          placeholder: "Select Attack Type",
          onUpdate: 'updateAttackTypeUI'
        },
        tSize: { type: 'dropdown', options: ["Small", "Medium", "Large"], placeholder: "Select Target Size" },
        tRace: { type: 'dropdown', options: () => RACE_TYPES, placeholder: "skip race" },
        tAttr: { type: 'dropdown', options: () => Object.keys(getElementCounter()), placeholder: "skip attribute" },
        weapon: { type: 'dropdown', options: () => Object.keys(getWeaponSizeModifier()), placeholder: "Select Weapon Type" },
        wElem: { type: 'dropdown', options: () => Object.keys(getElementCounter()), placeholder: "Select Attribute" },
        tDef: { type: 'dropdown', options: () => Object.keys(getTargetDefenseData()), placeholder: "Select target", special: 'target' },
        vesperSet: { type: 'set', generator: 'vesper' },
        whiteSet: { type: 'set', generator: 'white' },
        blueSet: { type: 'set', generator: 'blue' },
        attack: {
          type: 'nested-conditional',
          dependsOn: 'atkType',
          active: () => ({ label: 'P/M. Attack', placeholder: 'physical/magical attack...' }),
          default: { label: "P/M. Attack", placeholder: "select attack type first" }
        },
        flatDmgBns: {
          type: 'nested-conditional',
          dependsOn: 'attack',
          active: () => ({ label: 'P/M. Damage Bonus', placeholder: 'flat damage bonus...' }),
          default: { label: "P/M. Damage Bonus", placeholder: "select attack type and fill attack first" }
        },
        percentageDmgBns: {
          type: 'nested-conditional',
          dependsOn: 'flatDmgBns',
          active: () => ({ label: 'Percentage P/M. Damage Bonus', placeholder: 'percentage p/m damage bonus...' }),
          default: { label: "Percentage P/M. Damage Bonus", placeholder: "select attack type and fill flat damage first" }
        },
        race: {
          type: 'conditional', dependsOn: 'tRace',
          active: (race) => ({ label: `DMG to ${race}`, placeholder: `dmg to ${race.toLowerCase()} %` }),
          default: { label: "DMG to Race", placeholder: "select target race first" }
        },
        attr: {
          type: 'conditional', dependsOn: 'tAttr',
          active: (attr) => ({ label: `DMG to ${attr} Attribute`, placeholder: `dmg to ${attr.toLowerCase()} attribute %` }),
          default: { label: "DMG to Attribute", placeholder: "select target attribute first" }
        },
        elemEnh: {
          type: 'conditional', dependsOn: 'wElem',
          active: (elem) => ({ label: `${elem} Enhance %`, placeholder: `${elem.toLowerCase()} enhance` }),
          default: { label: "Element Enhance %", placeholder: "select weapon attribute first" }
        },
        sizeEnh: {
          type: 'conditional', dependsOn: 'tSize',
          active: (size) => ({ label: `DMG to ${size} %`, placeholder: `dmg to ${size.toLowerCase()}` }),
          default: { label: "DMG to Size %", placeholder: "select target size first" }
        },
        dmg: {
          type: 'conditional', dependsOn: 'atkType',
          active: () => ({ placeholder: "final p/m damage bonus" }),
          default: { placeholder: "select attack type first" }
        },
        dmgStack: {
          type: 'conditional', dependsOn: 'atkType',
          active: () => ({ placeholder: "final damage bonus/stack %" }),
          default: { placeholder: "select attack type first" }
        }
      },

      setGenerators: {
        vesper: () => [{ value: "", label: "skip vesper set" }, 
          ...Object.entries(VESPER_SET).map(([tier, val]) => ({ value: val, label: `Tier ${tier}` }))],
        white: () => [{ value: "", label: "skip white set" }, 
          ...Object.entries(WHITE_SET).map(([tier, val]) => ({ value: val, label: tier }))],
        blue: () => [{ value: "", label: "skip blue set" }, 
          ...Object.entries(BLUE_SET).flatMap(([multiplier, levels]) =>
            Object.entries(levels).map(([lvl, val]) => ({ value: val, label: `Level ${lvl}*${multiplier}` })))]
      },

      eventMap: {
        penCritSelect: 'atkType',
        weaponSelect: 'weapon',
        weaponElementSelect: 'wElem',
        targetSizeSelect: 'tSize',
        targetRaceSelect: 'tRace',
        targetElementSelect: 'tAttr'
      }
    };
  }

  getElement(key) { return DOM_ELEMENTS[key] || null; }

  safeElementOp(key, callback) {
    const el = this.getElement(key);
    if (el) callback(el);
  }

  updateWrapperState(element, locked, tempUnlocked = false) {
    const wrapper = element?.closest('.input-wrap');
    if (!wrapper) return;
    wrapper.classList.toggle('locked', locked);
    wrapper.toggleAttribute('data-temp-unlocked', tempUnlocked);
  }

  createOption(optData) {
    const opt = document.createElement('option');
    const isString = typeof optData === "string";
    opt.value = isString ? optData : optData.value;
    opt.textContent = isString ? optData : optData.label;
    if (optData.disabled) opt.disabled = true;
    return opt;
  }

  setButtonStates(buttonIds, disabled) {
    buttonIds.forEach(id => this.safeElementOp(id, btn => btn.disabled = disabled));
  }

  init() {
    if (this.isInitialized) return;
    this.populateAllDropdowns();
    this.bindEvents();
    this.updateAll();
    this.syncThreeSets();
    this.isInitialized = true;
  }

  getFormData() {
    return this.constants.formKeys.reduce((acc, key) => {
      const el = this.getElement(key);
      if (!el) return acc;
      acc[key] = el.value || '';
      if (el.tagName === 'SELECT' && el.selectedOptions[0]) {
        acc[`${key}Text`] = el.selectedOptions[0].textContent;
      }
      return acc;
    }, {});
  }

  getTargetData(targetKey) {
    if (!targetKey) return null;
    const rawData = getTargetDefenseData(targetKey);
    return rawData ? { ...rawData, sizeMob: rawData.sizeMob || this.getElement('tSize')?.value || "" } : null;
  }

  getCurrentTarget() {
    const targetKey = this.getElement('tDef')?.value;
    return targetKey ? { key: targetKey, data: this.getTargetData(targetKey) } : null;
  }

  populateAllDropdowns() {
    Object.entries(this.config.fields).forEach(([key, config]) => {
      if (config.type !== 'dropdown' && config.type !== 'set') return;
      const el = this.getElement(key);
      if (!el) return;
      const options = config.generator ? this.config.setGenerators[config.generator]() :
        (typeof config.options === 'function' ? config.options() : config.options);
      this.populateOptions(el, options, config.placeholder);
    });
  }

  populateOptions(select, options, placeholder) {
    if (!select) return;
    const fragment = document.createDocumentFragment();
    if (placeholder) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = placeholder;
      fragment.appendChild(opt);
    }
    options.forEach(optData => fragment.appendChild(this.createOption(optData)));
    select.innerHTML = '';
    select.appendChild(fragment);
  }

  setFieldState(element, disabled, activeText = '', inactiveText = '') {
    if (!element) return;
    element.disabled = disabled;
    element.placeholder = disabled ? inactiveText : activeText;
    this.updateWrapperState(element, disabled);
  }

  clearFields(fieldIds) {
    fieldIds.forEach(id => this.safeElementOp(id, el => {
      el.value = '';
      const wrapper = el.closest('.input-wrap');
      if (wrapper) {
        wrapper.classList.remove('locked');
        wrapper.removeAttribute('data-temp-unlocked');
      }
    }));
  }

  clearDependentFields(parentKey) {
    const dependents = this.constants.dependencyChain[parentKey];
    if (!dependents?.length) return;
    
    dependents.forEach(fieldKey => {
      const el = this.getElement(fieldKey);
      if (!el) return;
      
      if (el.value?.trim()) el.value = '';
      
      const fieldConfig = this.config.fields[fieldKey];
      const isConditional = fieldConfig?.type === 'nested-conditional' || fieldConfig?.type === 'conditional';
      
      if (isConditional && fieldConfig.default) {
        el.disabled = true;
        el.placeholder = fieldConfig.default.placeholder;
        const label = this.getElement(`${fieldKey}Label`);
        if (label && fieldConfig.default.label) label.textContent = fieldConfig.default.label;
        this.updateWrapperState(el, true);
      }
      
      if (this.constants.dependencyChain[fieldKey]) this.clearDependentFields(fieldKey);
    });
  }

  applyMobProperties(targetData, mode = 'standard', lockOverride = null) {
    if (!targetData) return;
    Object.entries(this.constants.mobMapping).forEach(([mobProp, domKey]) => {
      const el = this.getElement(domKey);
      if (!el) return;
      const targetValue = targetData[mobProp];
      const shouldLock = this.shouldLock(domKey, targetValue, mode, lockOverride);
      el.value = targetValue || "";
      el.disabled = shouldLock;
      this.state.lockStates.set(domKey, shouldLock);
      this.updateWrapperState(el, shouldLock);
      if (targetValue || !this.constants.dependencyChain[domKey]) return;
      this.clearDependentFields(domKey);
    });
  }

  shouldLock(domKey, targetValue, mode, lockOverride) {
    if (lockOverride !== null) return lockOverride;
    const selectedKey = this.getElement('tDef')?.value || "";
    if (mode === 'swap') return !!targetValue;
    return targetValue && !selectedKey.includes("Lvl.");
  }

  bindEvents() {
    EventManager.removeNS(this.namespace);
    
    const handleChange = (e) => {
      if (AppState.get('isResultShown')) return;
      
      const target = e.target;
      const targetEl = this.getElement('tDef');
      
      if (target === targetEl) {
        this.handleTargetChange();
        return;
      }
      
      if (this.constants.setKeys.includes(target.id)) {
        this.recordSelection(target);
        this.syncThreeSets();
        this.scheduleUpdate();
        return;
      }
      
      const fieldKey = this.config.eventMap[target.id];
      if (fieldKey) {
        if (this.config.fields[fieldKey]?.onUpdate === 'updateAttackTypeUI') {
          this.updateAttackTypeUI(this.getFormData());
        }
        this.clearDependentFields(fieldKey);
        this.scheduleUpdate();
      }
    };
    
    const handleInput = (e) => {
      if (AppState.get('isResultShown')) return;
      
      const cascadeFields = ['attack', 'flatDmgBns', 'percentageDmgBns'];
      if (cascadeFields.includes(e.target.id)) {
        const numValue = parseFloat(e.target.value);
        if (!e.target.value?.trim() || numValue === 0 || isNaN(numValue)) {
          this.clearDependentFields(e.target.id);
        }
        this.updateAll();
      }
    };
    
    EventManager.addNS(this.namespace, document, 'change', handleChange);
    EventManager.addNS(this.namespace, document, 'input', handleInput);
  }

  handleTargetChange() {
    if (this.state.isSwapping) return;
    const selectedKey = this.getElement('tDef')?.value;
    if (!selectedKey) return;
    const targetData = this.getTargetData(selectedKey);
    if (!targetData) return;
    this.applyMobProperties(targetData);
    this.syncBreakdownSwap(selectedKey);
    this.scheduleUpdate();
  }

  recordSelection(selectEl) {
    const formData = this.getFormData();
    const wasCycleComplete = this.state.selectionOrder.length >= 3 || 
      (formData.blueSet && (formData.blueSetText || "").includes("*8"));
    if (!selectEl?.value) {
      this.state.selectionOrder = this.state.selectionOrder.filter(el => el !== selectEl);
      return;
    }
    if (wasCycleComplete) {
      this.state.selectionOrder = [selectEl];
      return;
    }
    if (!this.state.selectionOrder.includes(selectEl)) {
      this.state.selectionOrder = [...this.state.selectionOrder, selectEl];
    }
  }

  syncThreeSets() {
    const setElements = this.constants.setKeys.map(k => this.getElement(k)).filter(Boolean);
    const formData = this.getFormData();
    const hasBlue8x = formData.blueSet && (formData.blueSetText || "").includes("*8");
    
    const disableAllOptions = (el) => {
      Array.from(el.options).forEach(opt => opt.disabled = !!opt.value);
      el.value = "";
    };
    
    setElements.forEach(el => Array.from(el.options).forEach(opt => opt.disabled = false));
    
    if (hasBlue8x) {
      [this.getElement('vesperSet'), this.getElement('whiteSet')].forEach(el => {
        if (el) disableAllOptions(el);
      });
      return;
    }
    
    const blueEl = this.getElement('blueSet');
    if (this.state.selectionOrder.length > 0 && blueEl) {
      Array.from(blueEl.options).forEach(opt => {
        if (opt.value && opt.textContent.includes("*8")) opt.disabled = true;
      });
    }
    
    if (this.state.selectionOrder.length >= 2) {
      setElements.filter(el => !this.state.selectionOrder.includes(el)).forEach(disableAllOptions);
    }
    
    if (blueEl?.value && blueEl.selectedOptions[0]?.disabled) {
      blueEl.value = "";
      this.state.selectionOrder = this.state.selectionOrder.filter(el => el !== blueEl);
    }
  }

  updateAll() {
    const formData = this.getFormData();
    this.updateStaticLabels();
    this.updateDynamicLabels(formData);
    this.updateConditionalFields(formData);
    this.updateAttackTypeUI(formData);
  }

  updateStaticLabels() {
    Object.entries(this.config.labels.static).forEach(([key, label]) => {
      this.safeElementOp(key, el => el.textContent = label);
    });
  }

  updateDynamicLabels(formData) {
    this.safeElementOp('vesperSetLabel', el => {
      el.textContent = this.config.labels.dynamic.vesper[formData.vesperSet] || "Vesper SET";
    });
    this.safeElementOp('whiteSetLabel', el => {
      el.textContent = this.config.labels.dynamic.white[formData.whiteSet] || "White SET (110*3)";
    });
  }

  updateConditionalFields(formData) {
    const validateNumericInput = (value) => {
      const num = parseFloat(value);
      return value?.trim() && !isNaN(num) && num > 0;
    };
    
    Object.entries(this.config.fields).forEach(([key, config]) => {
      if (config.type !== 'conditional' && config.type !== 'nested-conditional') return;
      
      const input = this.getElement(key);
      const label = this.getElement(`${key}Label`);
      if (!input || !config.active || !config.default) return;
      
      let isActive = false;
      let settings = config.default;
      
      if (config.type === 'nested-conditional') {
        const { dependsOn } = config;
        const atkTypeValid = !!(formData.atkType || '').trim();
        
        if (dependsOn === 'atkType') {
          isActive = atkTypeValid;
        } else if (dependsOn === 'attack') {
          isActive = atkTypeValid && validateNumericInput(formData.attack);
        } else if (dependsOn === 'flatDmgBns') {
          isActive = atkTypeValid && 
                     validateNumericInput(formData.attack) && 
                     validateNumericInput(formData.flatDmgBns);
        }
        
        settings = isActive ? config.active() : config.default;
      } else {
        const conditionValue = formData[config.dependsOn];
        isActive = !!conditionValue;
        settings = isActive ? config.active(conditionValue) : config.default;
      }
      
      input.disabled = !isActive;
      input.placeholder = settings.placeholder;
      if (label && settings.label) label.textContent = settings.label;
      this.updateWrapperState(input, !isActive);
    });
  }

  updateAttackTypeUI(formData) {
    const { atkType } = formData;
    const groups = { 
      pen: document.querySelector('.form-group.pen-group'), 
      crit: document.querySelector('.form-group.crit-group') 
    };
    
    Object.values(groups).forEach(g => g?.classList.add('hidden'));
    
    const penEl = this.getElement('pen');
    const critEl = this.getElement('crit');
    const clearValue = (el) => { if (el?.value) el.value = ''; };
    
    if (atkType === 'pen') {
      groups.pen?.classList.remove('hidden');
      this.setFieldState(penEl, false, 'total converted raw pen + final pen...');
      this.setFieldState(critEl, true);
      clearValue(critEl);
    } else if (atkType === 'crit') {
      groups.crit?.classList.remove('hidden');
      this.setFieldState(critEl, false, 'critical damage bonus...');
      this.setFieldState(penEl, true);
      clearValue(penEl);
    } else {
      this.setFieldState(penEl, true);
      this.setFieldState(critEl, true);
      clearValue(penEl);
      clearValue(critEl);
    }
  }

  scheduleUpdate() {
    if (this.state.updateTimer) clearTimeout(this.state.updateTimer);
    this.state.updateTimer = setTimeout(() => {
      this.updateAll();
      this.state.updateTimer = null;
    }, 50);
  }

  determineSwapMode(prevKey, nextKey) {
    if (!prevKey || !nextKey || nextKey === prevKey) return 'none';
    const prevData = this.getTargetData(prevKey);
    const nextData = this.getTargetData(nextKey);
    if (!prevData || !nextData) return 'manual';
    
    const prevRaw = getTargetDefenseData(prevKey) || {};
    const nextRaw = getTargetDefenseData(nextKey) || {};
    const currentDOM = {
      sizeMob: this.getElement('tSize')?.value || "",
      raceMob: this.getElement('tRace')?.value || "",
      attributeMob: this.getElement('tAttr')?.value || ""
    };
    
    for (const [mobProp] of Object.entries(this.constants.mobMapping)) {
      const prevValue = prevRaw[mobProp];
      const nextValue = nextRaw[mobProp];
      if (prevValue && nextValue && prevValue !== nextValue) return 'manual';
      if (!nextValue || prevValue) continue;
      if (mobProp === 'sizeMob' && currentDOM.sizeMob === nextValue) continue;
      return 'manual';
    }
    return 'auto';
  }

  executeSwap(nextKey, state, isPenMode) {
    const swapMode = this.determineSwapMode(this.getCurrentTarget()?.key, nextKey);
    if (swapMode === 'none') return;
    
    this.state.isSwapping = true;
    const tDefEl = this.getElement('tDef');
    if (tDefEl) tDefEl.value = nextKey;
    this.syncBreakdownSwap(nextKey);
    this.resetGlobalStates();
    
    const targetData = this.getTargetData(nextKey);
    if (!targetData) {
      this.state.isSwapping = false;
      return;
    }
    
    if (swapMode === 'auto') {
      this.applyMobProperties(targetData, 'swap');
      if (typeof processMainCalculation === 'function') processMainCalculation();
      if (typeof showSnackbar === 'function') showSnackbar('Auto calc triggered!');
      this.scheduleUpdate();
    } else {
      this.unlockCalculationFields(isPenMode);
      this.applyMobProperties(targetData, 'manual', true);
      this.updateManualSwapUI(state, isPenMode);
      this.scheduleUpdate();
    }
    this.state.isSwapping = false;
  }

  unlockCalculationFields(isPenMode) {
    const fields = [...this.config.calcFields, isPenMode ? "pen" : "crit"];
    fields.forEach(fieldName => {
      const field = this.getElement(fieldName);
      if (!field) return;
      const wrapper = field.closest(".input-wrap");
      if (!wrapper?.querySelector('input[type="number"]')) return;
      wrapper.classList.remove("locked");
      wrapper.dataset.tempUnlocked = "1";
      field.disabled = false;
    });
    if (typeof unbindInputLockGuard === 'function') unbindInputLockGuard();
  }

  updateManualSwapUI(state, isPenMode) {
    this.safeElementOp('submit', btn => btn.disabled = false);
    this.setButtonStates(this.config.disableButtons, true);
    this.safeElementOp('hasil', el => {
      el.dataset.specificMode = "0";
      el.textContent = 'Input your stats to see the result...';
    });
    this.safeElementOp('rec', el => {
      el.textContent = 'Balancing stat recommendations for a higher output multiplier.';
    });
    
    const focusElement = isPenMode ? this.getElement('pen') : this.getElement('crit');
    if (typeof scrollAndFocusElement === 'function') {
      scrollAndFocusElement(focusElement, "Target swapped - please verify stats and recalculate!");
    }
    if (typeof validateRequiredFields === 'function') validateRequiredFields();
    if (typeof validateStatsVsTarget === 'function') validateStatsVsTarget(state);
  }

  syncBreakdownSwap(targetKey) {
    const swapDropdown = document.querySelector('#breakdown-swap');
    if (swapDropdown && swapDropdown.value !== targetKey) swapDropdown.value = targetKey;
  }

  resetGlobalStates() {
    AppState.reset();
    const testButtons = ['testSpear', 'testReaper'];
    testButtons.forEach(btnId => {
      this.safeElementOp(btnId, btn => btn.classList.remove('activated'));
    });
  }

  createSwapSelect(state, isPenMode) {
    const select = document.createElement("select");
    select.id = "breakdown-swap";
    select.className = "breakdown-swap";
    
    const pen = +(state.pen);
    const dmg = +(state.dmg);
    const currentKey = this.getCurrentTarget()?.key;
    const allTargetData = getTargetDefenseData();
    
    const options = Object.keys(allTargetData).map(key => {
      const data = allTargetData[key];
      const def = +(data?.def || 0);
      const dmgred = +(data?.dmgred || 0);
      const insufficient = dmg <= dmgred || (isPenMode && pen <= def);
      const swapMode = this.determineSwapMode(currentKey, key);
      const disabled = swapMode === 'auto' && insufficient;
      const text = disabled ? `${key} (cant auto calc)` : key;
      return `<option value="${key}"${disabled ? ' disabled' : ''}>${text}</option>`;
    });
    
    select.innerHTML = options.join('');
    select.value = state.tDefKey || "DUMMY Lvl.0 (0 DEF)";
    
    if (!select.hasAttribute('data-dropdown-bound')) {
      EventManager.addNS(this.namespace, select, 'change', () => {
        this.executeSwap(select.value, state, isPenMode);
      });
      select.setAttribute('data-dropdown-bound', 'true');
    }
    return select;
  }

  destroy() {
    if (this.state.updateTimer) {
      clearTimeout(this.state.updateTimer);
      this.state.updateTimer = null;
    }
    EventManager.removeNS(this.namespace);
    this.state.selectionOrder = [];
    this.state.lockStates.clear();
    this.state.isSwapping = false;
    this.isInitialized = false;
  }
};
const dropdownManager = new DropdownManager();

// ======== VALIDATION ========
class ValidationSSoT {
  constructor() {
    this.INVALID_CLASS = 'invalid-value';
    this.SNACKBAR_COOLDOWN = 2000;
    this.WATCH_INTERVAL = 200;
    this.touchedFields = new Set();
    this.snackbarCooldowns = new Set();
    this.fieldLastValues = new Map();
    this.namespace = 'validation-ssot';
    this.isInitialized = false;
    this.autoInit();
  }

  isPenOrDmg = (e) => ['pen', 'dmg'].includes(e?.id);
  isRelatedNumeric = (e) => ['race', 'attr'].includes(e?.id);
  isNumeric = (e) => e?.type === 'number' ||
    e?.classList.contains('numeric-input') ||
    this.isPenOrDmg(e) ||
    this.isRelatedNumeric(e);

  isValidNumber = (v) => !isNaN(+v) && isFinite(+v);
  
  normalizeInput = (v) => String(v)
    .replace(/[^\d.,]/g, '')
    .replace(/,/g, '.')
    .replace(/\.{2,}/g, '.')
    .replace(/^\./, '0.')
    .replace(/\.$/, '');

  showMessage = (msg) => typeof showSnackbar === 'function' && showSnackbar(msg);

  canShowSnackbar(elementId) {
    if (this.snackbarCooldowns.has(elementId)) return false;
    this.snackbarCooldowns.add(elementId);
    setTimeout(() => this.snackbarCooldowns.delete(elementId), this.SNACKBAR_COOLDOWN);
    return true;
  }

  getDropdownForRelated(element) {
    return element.id === 'race' ? DOM_ELEMENTS.tRace : DOM_ELEMENTS.tAttr;
  }

  validateRelatedNumeric(element, value) {
    const dropdown = this.getDropdownForRelated(element);
    if (!dropdown?.value && !value) return { isValid: true, reason: 'related_empty' };
    if (dropdown?.value && !value) return { isValid: false, reason: 'related_required' };
    return null;
  }

  validateBoundary(element, numValue, showMessages, boundType) {
    const bound = element.getAttribute(boundType);
    if (bound === null || bound === '') return null;

    const boundVal = +bound;
    const isMin = boundType === 'min';
    const isValid = isMin ? numValue >= boundVal : numValue <= boundVal;
    
    if (isValid) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      const message = isMin 
        ? `${element.getAttribute('data-field-name') || element.id || 'Field'} must be at least ${boundVal}`
        : 'what are you doing?';
      this.showMessage(message);
    }

    return { isValid: false, reason: isMin ? 'below_min' : 'above_max' };
  }

  validateThreshold(element, numValue, showMessages) {
    if (!this.isPenOrDmg(element)) return null;

    const defData = getTargetDefenseData(DOM_ELEMENTS.tDef?.value);
    const threshold = element.id === 'pen' ? (+(defData?.def) || 0) : (+(defData?.dmgred) || 0);

    if (numValue > threshold) return null;

    if (showMessages && this.canShowSnackbar(element.id)) {
      const minRequired = (threshold + 8).toFixed(2);
      const fieldType = element.id === 'pen' ? 'Final PEN' : 'Final P/M Bonus';
      const targetLabel = DOM_ELEMENTS.tDef?.options?.[DOM_ELEMENTS.tDef.selectedIndex]?.textContent || 'target';
      this.showMessage(`Need at least ${minRequired} ${fieldType} vs ${targetLabel}`);
    }

    return { isValid: false, reason: 'threshold_not_met' };
  }

  validateField(element, showMessages = false) {
    const value = element.value?.trim() || '';

    if (this.isRelatedNumeric(element)) {
      const result = this.validateRelatedNumeric(element, value);
      if (result) return result;
    }

    if (!value) return { isValid: false, reason: 'empty' };

    if (this.isNumeric(element) && !this.isValidNumber(value)) {
      return { isValid: false, reason: 'invalid_number' };
    }

    const numValue = +value;
    const validators = [
      () => this.validateBoundary(element, numValue, showMessages, 'min'),
      () => this.validateBoundary(element, numValue, showMessages, 'max'),
      () => this.validateThreshold(element, numValue, showMessages)
    ];

    for (const validator of validators) {
      const result = validator();
      if (result) return result;
    }

    return { isValid: true };
  }

  updateFieldState(element, isValid, force = false) {
    if (!force && !this.touchedFields.has(element.id)) return;
    element.classList.toggle(this.INVALID_CLASS, !isValid);
  }

  normalizeElement(element) {
    if (!element || !this.isNumeric(element)) return;

    const normalized = this.normalizeInput(element.value);
    if (normalized !== element.value) element.value = normalized;

    const result = this.validateField(element, this.touchedFields.has(element.id));
    this.updateFieldState(element, result.isValid, true);
  }

  createEventHandlers(element) {
    const validateHandler = (showMessages = false) => {
      const result = this.validateField(element, showMessages);
      this.updateFieldState(element, result.isValid);
    };

    const normalizeHandler = () => {
      if (!this.isNumeric(element)) return;
      const normalized = this.normalizeInput(element.value);
      if (normalized !== element.value) element.value = normalized;
    };

    return {
      focus: () => this.touchedFields.add(element.id),
      input: () => { normalizeHandler(); validateHandler(false); },
      blur: () => validateHandler(true),
      change: () => validateHandler(true),
      paste: () => this.isNumeric(element) && setTimeout(() => this.normalizeElement(element), 0)
    };
  }

  setupField(element) {
    this.fieldLastValues.set(element.id, element.value);
    const handlers = this.createEventHandlers(element);
    
    Object.entries(handlers).forEach(([event, handler]) => {
      EventManager.addNS(this.namespace, element, event, handler);
    });
  }

  setupDefenseChangeHandler() {
    if (!DOM_ELEMENTS.tDef) return;

    const validatePenDmgFields = () => {
      [DOM_ELEMENTS.pen, DOM_ELEMENTS.dmg]
        .filter(el => el?.value.trim())
        .forEach(el => {
          const result = this.validateField(el, this.canShowSnackbar(el.id));
          this.updateFieldState(el, result.isValid);
        });
    };

    EventManager.addNS(this.namespace, DOM_ELEMENTS.tDef, 'change', validatePenDmgFields);
  }

  startWatchingTouchedFields() {
    const el = DOM_ELEMENTS.tSize;
    if (!el) return;

    const checkFieldChange = () => {
      if (!this.touchedFields.has(el.id) || !el.classList.contains(this.INVALID_CLASS)) return;

      const lastValue = this.fieldLastValues.get(el.id);
      const currentValue = el.value;

      if (lastValue === currentValue) return;

      this.fieldLastValues.set(el.id, currentValue);
      const result = this.validateField(el, false);
      this.updateFieldState(el, result.isValid, true);
    };

    setInterval(checkFieldChange, this.WATCH_INTERVAL);
  }

  checkReady = () => typeof DOM_ELEMENTS !== 'undefined' && DOM_ELEMENTS;

  getFieldKeys() {
    return ['atkType', 'weapon', 'wElem', 'tDef', 'tSize', 'pen', 'crit', 'attack',
      'flatDmgBns', 'percentageDmgBns', 'dmg', 'elemEnh', 'sizeEnh', 'race', 'attr', 'dmgStack'];
  }

  init() {
    if (this.isInitialized || !this.checkReady()) return false;

    this.getFieldKeys()
      .map(key => DOM_ELEMENTS[key])
      .filter(Boolean)
      .forEach(element => this.setupField(element));

    this.setupDefenseChangeHandler();
    this.startWatchingTouchedFields();

    this.isInitialized = true;
    return true;
  }

  autoInit() {
    if (this.isInitialized) return;

    const initHandler = () => !this.isInitialized && this.init();
    const isDomLoading = document.readyState === 'loading' || document.readyState === 'interactive';

    if (isDomLoading) {
      document.addEventListener('DOMContentLoaded', initHandler, { once: true });
    } else {
      this.init();
    }

    window.addEventListener('load', initHandler, { once: true });
  }

  getRequiredFields() {
    const createField = (key, name, condition = null) => ({ 
      el: DOM_ELEMENTS[key], 
      name, 
      ...(condition && { condition }) 
    });

    return [
      createField('atkType', 'Attack Type'),
      createField('weapon', 'Weapon Type'),
      createField('wElem', 'Weapon Attribute'),
      createField('tDef', 'Target Boss'),
      createField('tSize', 'Target Size'),
      createField('attack', 'Attack', () => DOM_ELEMENTS.attack && !DOM_ELEMENTS.attack.disabled),
      createField('flatDmgBns', 'Flat Damage', () => DOM_ELEMENTS.flatDmgBns && !DOM_ELEMENTS.flatDmgBns.disabled),
      createField('percentageDmgBns', 'Percentage Damage', () => DOM_ELEMENTS.percentageDmgBns && !DOM_ELEMENTS.percentageDmgBns.disabled),
      createField('pen', 'Final P/M. PEN %', () => DOM_ELEMENTS.atkType?.value === 'pen'),
      createField('crit', 'Critical DMG Bonus %', () => DOM_ELEMENTS.atkType?.value === 'crit'),
      createField('dmg', 'Final P/M. Damage Bonus %'),
      createField('elemEnh', 'Element Enhance %'),
      createField('sizeEnh', 'DMG to Size %'),
      createField('race', 'DMG to Race %', () => DOM_ELEMENTS.race && !DOM_ELEMENTS.race.disabled),
      createField('attr', 'DMG to Attribute %', () => DOM_ELEMENTS.attr && !DOM_ELEMENTS.attr.disabled),
      createField('dmgStack', 'Final DMG Bonus %')
    ];
  }

  shouldValidateField(field) {
    return field.el && (!field.condition || field.condition());
  }

  processFieldValidation(field, shouldScroll = true) {
    this.touchedFields.add(field.el.id);
    const result = this.validateField(field.el, this.canShowSnackbar(field.el.id));
    this.updateFieldState(field.el, result.isValid, true);

    if (!result.isValid && shouldScroll && typeof scrollAndFocusElement === 'function') {
      scrollAndFocusElement(field.el);
    }

    return result.isValid;
  }

  validateAllRequired() {
    const fields = this.getRequiredFields();

    for (const field of fields) {
      if (!this.shouldValidateField(field)) continue;
      if (!this.processFieldValidation(field)) return false;
    }

    return true;
  }

  getStatsElements(state) {
    const elements = [];
    if (state?.atkType?.toLowerCase() === 'pen' && DOM_ELEMENTS.pen) {
      elements.push(DOM_ELEMENTS.pen);
    }
    if (DOM_ELEMENTS.dmg) elements.push(DOM_ELEMENTS.dmg);
    return elements;
  }

  validateStats(state, focusedElement = null) {
    const elements = this.getStatsElements(state);

    for (const element of elements) {
      const shouldScroll = focusedElement === element || !focusedElement;
      const fieldObject = { el: element };
      
      if (!this.processFieldValidation(fieldObject, shouldScroll)) return false;
    }

    return true;
  }

  destroy() {
    EventManager.removeNS(this.namespace);
    this.touchedFields.clear();
    this.snackbarCooldowns.clear();
    this.fieldLastValues.clear();
    this.isInitialized = false;
  }
};
const ValidationSSoTInstance = new ValidationSSoT();
const normalizeNumericInput = (el, pastedValue) => {
  if (!el) return;
  if (pastedValue !== undefined) el.value = pastedValue;
  ValidationSSoTInstance.normalizeElement(el);
};
const validateRequiredFields = () => ValidationSSoTInstance.validateAllRequired();
const validateStatsVsTarget = (state, focusedElement = null) => ValidationSSoTInstance.validateStats(state, focusedElement);

// ========== INPUT LOCK SYSTEM ==========
const InputLockManager = (() => {
  const PASSIVE_SUPPORT = (() => {
    let supported = false;
    try {
      const opts = {
        get passive() {
          supported = true;
          return false;
        }
      };
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (_) {}
    return supported;
  })();

  const POINTER_SUPPORT = 'PointerEvent' in window;
  const opts = PASSIVE_SUPPORT ? {
    passive: false
  } : false;

  let cachedWrappers = null,
    cacheValid = false,
    observer = null;
  const wrapperListeners = new Map(),
    cooldowns = new WeakMap();

  const invalidateCache = () => {
    cacheValid = false;
    cachedWrappers = null;
  };

  const getCachedWrappers = () => {
    if (cacheValid && cachedWrappers) return cachedWrappers;
    cachedWrappers = Array.from(document.querySelectorAll('.input-wrap'));
    cacheValid = true;
    return cachedWrappers;
  };

  const startCacheObserver = () => {
    if (observer || typeof MutationObserver === 'undefined') return;

    observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          for (const node of [...mutation.addedNodes, ...mutation.removedNodes]) {
            if (node.nodeType === 1 && (node.classList?.contains('input-wrap') || node.querySelector?.('.input-wrap'))) {
              invalidateCache();
              return;
            }
          }
        }
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['class']
    });
  };

  const stopCacheObserver = () => {
    if (observer) observer.disconnect(), observer = null;
  };

  const showLockedMessage = (event) => {
    const target = event?.currentTarget;
    if (!target?.classList?.contains('locked')) return;

    const now = Date.now(),
      lastTime = cooldowns.get(target);
    if (lastTime && (now - lastTime) < 500) return;
    cooldowns.set(target, now);

    if (event?.cancelable) event.preventDefault(), event.stopPropagation();

    if (!window._lastSnackbarTime || (now - window._lastSnackbarTime) > 3000) {
      window._lastSnackbarTime = now;
      typeof showSnackbar === 'function' && showSnackbar("Your Stats Locked!");
    }
  };

  const bind = (wrapper) => {
    if (!wrapper?.nodeType || wrapperListeners.has(wrapper)) return;

    const ids = POINTER_SUPPORT ? [EventManager.add(wrapper, 'pointerdown', showLockedMessage, opts)] : [EventManager.add(wrapper, 'touchstart', showLockedMessage, opts), EventManager.add(wrapper, 'click', showLockedMessage, false)];

    wrapperListeners.set(wrapper, ids);
  };

  const unbind = (wrapper) => {
    if (!wrapper?.nodeType) return;
    const ids = wrapperListeners.get(wrapper);
    if (!ids) return;
    ids.forEach(id => EventManager.remove(id));
    wrapperListeners.delete(wrapper);
    cooldowns.delete(wrapper);
  };

  const lockAll = () => {
    startCacheObserver();
    const wrappers = getCachedWrappers();

    for (let i = 0; i < wrappers.length; i++) {
      const wrapper = wrappers[i];
      const elements = wrapper.querySelectorAll('input, select, textarea');
      if (!elements.length) continue;

      for (let j = 0; j < elements.length; j++) elements[j].disabled = true;
      wrapper.classList.add('locked');
      bind(wrapper);
    }
  };

  const unlockAll = () => {
    const wrappers = getCachedWrappers();

    for (let i = 0; i < wrappers.length; i++) {
      const wrapper = wrappers[i];
      const elements = wrapper.querySelectorAll('input, select, textarea');
      if (!elements.length) continue;

      for (let j = 0; j < elements.length; j++) elements[j].disabled = false;
      wrapper.classList.remove('locked');
      unbind(wrapper);
    }

    invalidateCache();
    stopCacheObserver();
  };

  const destroy = () => {
    stopCacheObserver();
    wrapperListeners.forEach((ids) => ids.forEach(id => EventManager.remove(id)));
    wrapperListeners.clear();
    invalidateCache();
  };

  return {
    bind,
    unbind,
    lockAll,
    unlockAll,
    destroy
  };
})();
const bindInputLockGuard = InputLockManager.bind;
const unbindInputLockGuard = InputLockManager.unbind;
const lockAllInputs = InputLockManager.lockAll;
const unlockAllInputs = InputLockManager.unlockAll;

// ========== STICKY ==========
class StickyHandler {
  constructor() {
    this.state = {
      isActive: false,
      isCollapsed: false,
      isMobile: false,
      animating: false
    };

    this.config = {
      MOBILE_BREAKPOINT: 480,
      BUTTON_HEIGHT: 56,
      ANIMATION_DELAY: 60,
      TRANSITION_DURATION: 300,
      DOM_REINJECT_DELAY: 50,
      OBSERVER_DEBOUNCE: 16,
      RESIZE_DEBOUNCE: 100,
      CLEANUP_DELAY: 320
    };

    this.selectors = {
      resetRek: 'resetRekomenBtn',
      edit: 'editBtn',
      swapBoss: 'breakdown-swap',
      stickyStart: () => DOM_ELEMENTS?.stickyStart,
      testSpear: () => DOM_ELEMENTS?.testSpear,
      testReaper: () => DOM_ELEMENTS?.testReaper
    };

    this.buttonOrder = ['toggleBtn', 'swapBoss', 'testSpear', 'testReaper', 'resetRek', 'edit', 'backBtn'];
    this.textButtons = new Set(['resetRek', 'edit', 'testSpear', 'testReaper']);
    this.controlButtons = [{
        id: 'toggleStickyBtn',
        class: 'sticky-toggle',
        key: 'toggleBtn',
        handler: 'handleToggle'
      },
      {
        id: 'backToHasilBtn',
        class: 'sticky-back',
        key: 'backBtn',
        handler: 'handleBack'
      }
    ];

    this.elements = new Map();
    this.timeouts = new Map();
    this.boundListeners = new Map();
    this.scrollRAF = null;
    this.observer = null;
    this.unsubscribeAppState = null;
    this.initialized = false;

    this.init();
  }

  canOperate() {
    return this.state.isMobile && AppState.get('isResultShown') && this.state.isActive;
  }

  initElements() {
    this.elements.clear();

    for (const [key, selector] of Object.entries(this.selectors)) {
      const element = typeof selector === 'function' ? selector() : document.getElementById(selector);

      if (!element) continue;

      this.elements.set(key, element);

      if (this.textButtons.has(key) && !element.dataset.originalText) {
        element.dataset.originalText = element.textContent.trim() || '';
      }

      if (key === 'swapBoss' && this.state.isActive && this.state.isMobile) {
        element.dataset.stickyPreserve = 'true';
      }
    }

    this.createControlButtons();
  }

  createControlButtons() {
    for (const {
        id,
        class: className,
        key,
        handler
      } of this.controlButtons) {
      let button = document.getElementById(id);

      if (!button) {
        button = document.createElement('button');
        button.id = id;
        button.className = className;
        document.body.appendChild(button);
      }

      this.elements.set(key, button);

      if (!button.dataset.bound) {
        const boundHandler = (e) => this[handler](e);
        button.addEventListener('click', boundHandler);
        button.dataset.bound = 'true';
        this.boundListeners.set(`button-${key}`, {
          target: button,
          event: 'click',
          handler: boundHandler
        });
      }
    }

    const toggleBtn = this.elements.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  }

  getOrderedButtons() {
    const buttons = [];
    for (const key of this.buttonOrder) {
      const btn = this.elements.get(key);
      if (btn) buttons.push(btn);
    }
    return buttons;
  }

  handleToggle = (e) => {
    e.preventDefault();

    if (!this.canOperate() || this.state.animating) return;

    this.state.animating = true;
    this.state.isCollapsed = !this.state.isCollapsed;

    const toggleBtn = this.elements.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = String(this.state.isCollapsed);

    this.applySticky();
    this.scheduleTimeout('animationEnd', () => {
      this.state.animating = false;
    }, this.config.TRANSITION_DURATION);
  }

  handleBack = (e) => {
    e.preventDefault();
    if (!this.canOperate()) return;

    const stickyStart = this.elements.get('stickyStart');
    if (stickyStart) {
      stickyStart.scrollIntoView({
        behavior: 'smooth',
        block: 'start'
      });
    }
  }

  handleScroll = () => {
    if (!this.scrollRAF) {
      this.scrollRAF = requestAnimationFrame(() => {
        this.updateSticky();
        this.scrollRAF = null;
      });
    }
  }

  handleResize = () => {
    this.scheduleTimeout('resize', this.updateSticky.bind(this), this.config.RESIZE_DEBOUNCE);
  }

  scheduleTimeout(key, callback, delay) {
    const existing = this.timeouts.get(key);
    if (existing) clearTimeout(existing);
    this.timeouts.set(key, setTimeout(callback, delay));
  }

  clearAllTimeouts() {
    for (const timeout of this.timeouts.values()) {
      clearTimeout(timeout);
    }
    this.timeouts.clear();
  }

  updateMobileState() {
    const newIsMobile = window.innerWidth <= this.config.MOBILE_BREAKPOINT;
    const changed = newIsMobile !== this.state.isMobile;
    this.state.isMobile = newIsMobile;
    return changed;
  }

  deactivateSticky() {
    this.state.isActive = false;
    this.state.isCollapsed = false;
    this.removeSticky();
  }

  updateSticky() {
    const mobileChanged = this.updateMobileState();

    if (!this.state.isMobile) {
      if (mobileChanged || this.state.isActive) this.deactivateSticky();
      return;
    }

    if (!AppState.get('isResultShown')) {
      if (this.state.isActive) this.deactivateSticky();
      return;
    }

    const stickyStart = this.elements.get('stickyStart');
    if (!stickyStart) return;

    const shouldBeActive = stickyStart.getBoundingClientRect().top <= 0;

    if (shouldBeActive !== this.state.isActive) {
      this.state.isActive = shouldBeActive;
      shouldBeActive ? this.applySticky() : this.removeSticky();
    }
  }

  applySticky() {
    if (!this.canOperate()) return;

    const buttons = this.getOrderedButtons();
    if (buttons.length === 0) return;

    const wasSticky = buttons[0].classList.contains('sticky');
    const toggleBtn = this.elements.get('toggleBtn');

    for (let i = 0; i < buttons.length; i++) {
      const button = buttons[i];
      const isToggle = button === toggleBtn;
      const translateY = this.state.isCollapsed ? 0 : -(i * this.config.BUTTON_HEIGHT);
      const opacity = (this.state.isCollapsed && !isToggle) ? '0.4' : '1';

      button.classList.add('sticky');
      button.classList.toggle('collapsed', this.state.isCollapsed);

      if (!wasSticky) {
        this.animateButtonIn(button, i, translateY);
      } else {
        this.setButtonStyle(button, translateY, opacity);
      }
    }

    this.scheduleTimeout('textUpdate', this.updateButtonText.bind(this), 0);
  }

  animateButtonIn(button, index, translateY) {
    this.setButtonStyle(button, 50, 0, 'none');
    this.scheduleTimeout(`buttonIn-${index}`, () => {
      this.setButtonStyle(button, translateY, 1, 'all 400ms cubic-bezier(0.34, 1.56, 0.64, 1)');
    }, index * this.config.ANIMATION_DELAY);
  }

  setButtonStyle(button, translateY, opacity, transition = '') {
    button.style.cssText = `transform:translate3d(0,${translateY}px,0);opacity:${opacity};${transition ? `transition:${transition};` : ''}`;
  }

  removeSticky() {
    const buttons = this.getOrderedButtons();
    if (buttons.length === 0) return;

    for (const button of buttons) {
      if (button.classList.contains('sticky')) {
        this.setButtonStyle(button, 0, 0.3, 'transform 300ms ease,opacity 200ms ease');
      }
    }

    this.scheduleTimeout('cleanup', () => this.cleanupSticky(buttons), this.config.CLEANUP_DELAY);
  }

  cleanupSticky(buttons) {
    for (const button of buttons) {
      button.classList.remove('sticky', 'collapsed');
      button.style.cssText = '';
      if (button.dataset.originalText) {
        button.textContent = button.dataset.originalText;
      }
    }
  }

  updateButtonText() {
    for (const key of this.textButtons) {
      const button = this.elements.get(key);
      if (button) {
        button.textContent = this.state.isActive ? '' : (button.dataset.originalText || '');
      }
    }
  }

  preserveSwapState() {
    const swapElement = this.elements.get('swapBoss');
    if (!swapElement || swapElement.tagName !== 'SELECT') return null;

    const computed = window.getComputedStyle(swapElement);
    return {
      value: swapElement.value,
      transform: computed.transform,
      opacity: computed.opacity,
      isSticky: swapElement.classList.contains('sticky'),
      isCollapsed: swapElement.classList.contains('collapsed')
    };
  }

  restoreSwapState(state) {
    if (!state) return;

    const swapElement = this.elements.get('swapBoss');
    if (!swapElement || swapElement.tagName !== 'SELECT') return;

    if (state.value) swapElement.value = state.value;

    swapElement.style.cssText = `transform:${state.transform};opacity:${state.opacity};transition:none;`;
    if (state.isSticky) swapElement.classList.add('sticky');
    if (state.isCollapsed) swapElement.classList.add('collapsed');
  }

  // === EVENT LISTENERS ===
  setupEventListeners() {
    const events = [
      ['scroll', this.handleScroll],
      ['resize', this.handleResize]
    ];

    for (const [event, handler] of events) {
      const key = `window-${event}`;
      if (!this.boundListeners.has(key)) {
        window.addEventListener(event, handler, {
          passive: true
        });
        this.boundListeners.set(key, {
          target: window,
          event,
          handler
        });
      }
    }
  }

  removeEventListeners() {
    for (const {
        target,
        event,
        handler
      } of this.boundListeners.values()) {
      target.removeEventListener(event, handler);
    }
    this.boundListeners.clear();
  }

  setupDOMObserver() {
    if (typeof MutationObserver === 'undefined' || this.observer) return;
    const hasilContainer = DOM_ELEMENTS?.hasil;
    if (!hasilContainer) return;

    this.observer = new MutationObserver((mutations) => {
      const hasAddedNodes = mutations.some(m => m.addedNodes.length > 0);
      if (!hasAddedNodes) return;

      let swapReinjected = false;

      for (const mutation of mutations) {
        if (mutation.type !== 'childList') continue;

        for (const node of mutation.addedNodes) {
          if (node.nodeType !== 1) continue;
          if (node.id === 'breakdown-swap' || (node.querySelector?.('#breakdown-swap'))) {
            swapReinjected = true;
            break;
          }
        }
        if (swapReinjected) break;
      }

      if (!swapReinjected) {
        this.scheduleTimeout('observer', this.updateSticky.bind(this), this.config.OBSERVER_DEBOUNCE);
        return;
      }

      this.scheduleTimeout('observer', () => {
        const swapState = this.preserveSwapState();
        this.initElements();

        if (this.canOperate()) {
          if (swapState) this.restoreSwapState(swapState);
          this.scheduleTimeout('domReinject', this.applySticky.bind(this), this.config.DOM_REINJECT_DELAY);
        } else {
          this.updateSticky();
        }
      }, this.config.OBSERVER_DEBOUNCE);
    });

    this.observer.observe(hasilContainer, {
      childList: true,
      subtree: true
    });
  }

  // === APP STATE SUBSCRIPTION ===
  setupAppStateSubscription() {
    this.unsubscribeAppState = AppState.subscribe((key, value) => {
      if (key === 'isResultShown') {
        if (!value && this.state.isActive) {
          this.deactivateSticky();
        } else if (value && this.state.isMobile && !this.state.isActive) {
          this.updateSticky();
        }
      }
    });
  }

  init() {
    const setup = () => {
      if (this.initialized) return;

      this.initElements();
      this.setupEventListeners();
      this.setupDOMObserver();
      this.setupAppStateSubscription();
      this.updateSticky();

      this.initialized = true;
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setup, {
        once: true
      });
    } else {
      setup();
    }
  }

  destroy() {
    this.clearAllTimeouts();

    if (this.scrollRAF) {
      cancelAnimationFrame(this.scrollRAF);
      this.scrollRAF = null;
    }

    this.removeEventListeners();

    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.unsubscribeAppState) {
      this.unsubscribeAppState();
      this.unsubscribeAppState = null;
    }

    this.elements.clear();
    this.boundListeners.clear();
    this.timeouts.clear();
    this.initialized = false;
  }

  static initialize() {
    if (typeof window !== 'undefined' && !window.stickyHandler) {
      window.stickyHandler = new StickyHandler();
    }
    return window.stickyHandler;
  }
};
const stickyHandler = new StickyHandler();

// ========== FLASH SYSTEM ==========
const isMobile = () => window.innerWidth < 480;
const debounceMap = new Map();
let debounceCleanupInterval = null;
const startDebounceCleanup = () => {
  if (debounceCleanupInterval) return;
  
  debounceCleanupInterval = setInterval(() => {
    const now = Date.now();
    
    for (const [key, data] of debounceMap.entries()) {
      if (!data || (data.timestamp && now - data.timestamp > 10000)) {
        if (data?.timerId) clearTimeout(data.timerId);
        debounceMap.delete(key);
      }
    }
    
    if (debounceMap.size === 0) {
      clearInterval(debounceCleanupInterval);
      debounceCleanupInterval = null;
    }
  }, 5000);
};
const smoothDebounce = (fn, delay, key) => {
  const existing = debounceMap.get(key);
  
  if (existing?.timerId) clearTimeout(existing.timerId);
  if (existing?.running) return;
  
  const timerId = setTimeout(() => {
    const data = debounceMap.get(key);
    if (data) {
      debounceMap.set(key, { ...data, running: true, timestamp: Date.now() });
    }
    fn();
    debounceMap.delete(key);
  }, delay);
  
  debounceMap.set(key, { timerId, running: false, timestamp: Date.now() });
};
const simulateFlash = (() => {
  const TIMING = {
    buttonCooldown: 1600,
    flashTrigger: 150,
    calculationDelayOn: 950,
    calculationDelayOff: 100,
    animationDuration: 1800,
    emergencyCleanup: 2200,
    weaponAnimationBuffer: 100
  };
  
  const flashPool = {
    template: null,
    
    getElement() {
      if (!this.template) {
        const flash = document.createElement('div');
        const lightning = document.createElement('div');
        flash.className = 'lightning-flash-overlay';
        lightning.className = 'lightning-icon';
        flash.appendChild(lightning);
        this.template = flash;
      }
      return this.template.cloneNode(true);
    }
  };
  
  const triggerPulseFlash = () => {
    if (!AppState.get('isResultShown') || !isMobile() || AppState.get('isFlashActive')) return;
    
    AppState.set('isFlashActive', true);
    
    const flash = flashPool.getElement();
    const container = DOM_ELEMENTS.altSim;
    
    const cleanup = () => {
      if (flash.parentNode === container) {
        container.removeChild(flash);
      }
      AppState.set('isFlashActive', false);
    };
    
    const safeCleanup = () => {
      try {
        cleanup();
      } catch (e) {
        console.warn('Flash cleanup failed', e);
        AppState.set('isFlashActive', false);
      }
    };
    
    requestAnimationFrame(() => {
      try {
        container.appendChild(flash);
        setTimeout(safeCleanup, TIMING.animationDuration);
        setTimeout(() => {
          if (AppState.get('isFlashActive') && flash.parentNode === container) {
            safeCleanup();
          }
        }, TIMING.emergencyCleanup);
      } catch (e) {
        console.warn('Flash DOM insertion failed', e);
        AppState.set('isFlashActive', false);
      }
    });
  };
  
  return function simulateFlash(event) {
    if (!AppState.get('isResultShown')) return;
    
    const btn = event?.currentTarget;
    if (!btn || btn.disabled) return;
    
    btn.disabled = true;
    setTimeout(() => btn.disabled = false, TIMING.buttonCooldown);
    
    const isReaper = btn === DOM_ELEMENTS.testReaper;
    const prefix = isReaper ? 'reaper' : 'spear';
    const oppositePrefix = isReaper ? 'spear' : 'reaper';
    const stateKey = isReaper ? 'isTestReaperActive' : 'isTestSpearActive';
    
    const wasActive = AppState.get(stateKey);
    const isNowActive = !wasActive;
    
    AppState.set(stateKey, isNowActive);
    btn.classList.toggle('activated', isNowActive);
    
    const isTransitionToOn = !wasActive && isNowActive;
    
    if (isTransitionToOn && AppState.get('currentAnimatingWeapon') &&
      AppState.get('currentAnimatingWeapon') !== prefix) {
      for (const type of ['flash', 'calc']) {
        const key = `${oppositePrefix}-${type}`;
        const timeout = debounceMap.get(key);
        if (timeout?.timerId) {
          clearTimeout(timeout.timerId);
          debounceMap.delete(key);
        }
      }
    }
    
    if (isTransitionToOn) {
      AppState.set('currentAnimatingWeapon', prefix);
      setTimeout(() => {
        if (AppState.get('currentAnimatingWeapon') === prefix) {
          AppState.set('currentAnimatingWeapon', null);
        }
      }, TIMING.calculationDelayOn + TIMING.weaponAnimationBuffer);
      
      smoothDebounce(triggerPulseFlash, TIMING.flashTrigger, `${prefix}-flash`);
      DOM_ELEMENTS.submit.textContent = "Calculating...";
    }
    
    const calcDelay = isTransitionToOn ?
      TIMING.calculationDelayOn :
      TIMING.calculationDelayOff;
    
    smoothDebounce(() => {
      if (typeof processMainCalculation === 'function') {
        processMainCalculation();
      }
    }, calcDelay, `${prefix}-calc`);
    
    const weaponName = isReaper ? 'Reaper' : 'Spear';
    const statusText = isNowActive ? 'Flash Active' : 'Off';
    
    if (typeof showSnackbar === 'function') {
      showSnackbar(`${weaponName} ${statusText}`);
    }
  };
})();

// ======== SNACKBAR ========
const SnackbarManager = (() => {
  let hideTimer = null;
  let trackingKeyboard = false;
  let lastBottom = -1;
  let viewportChangeTimer = null;
  
  const NS = 'snackbar';
  
  const CONFIG = {
    MOBILE_MAX_WIDTH: 480,
    KEYBOARD_MIN: 100,
    BASE_OFFSET: 20,
    SHOW_DURATION: 3000,
    HIDE_ANIMATION: 300,
    RESIZE_DEBOUNCE: 150
  };
  
  const isMobileView = () => window.innerWidth <= CONFIG.MOBILE_MAX_WIDTH;
  
  const calcKeyboardHeight = () => {
    const vp = window.visualViewport;
    if (!vp) return 0;
    
    const gap = window.innerHeight - vp.height;
    return (gap > 50 && gap < window.innerHeight * 0.7) ? gap : 0;
  };

  const clearTimer = (timer) => {
    if (timer) clearTimeout(timer);
    return null;
  };
  
  const updatePosition = () => {
    const el = DOM_ELEMENTS?.snackbar;
    if (!el?.classList.contains('show') || !isMobileView() || !window.visualViewport) return;
    
    const kbHeight = calcKeyboardHeight();
    const bottom = (kbHeight > CONFIG.KEYBOARD_MIN ? kbHeight : 0) 
                   + CONFIG.BASE_OFFSET 
                   - window.visualViewport.offsetTop;
    
    if (bottom === lastBottom) return;
    
    lastBottom = bottom;
    el.style.bottom = `${bottom}px`;
  };
  
  const toggleTracking = (enable) => {
    if (trackingKeyboard === enable) return;
    
    const vp = window.visualViewport;
    if (!vp) return;
    
    trackingKeyboard = enable;
    lastBottom = -1;
    
    if (enable) {
      const passiveOpt = { passive: true };
      EventManager.addNS(`${NS}_viewport`, vp, 'resize', updatePosition, passiveOpt);
      EventManager.addNS(`${NS}_viewport`, vp, 'scroll', updatePosition, passiveOpt);
    } else {
      EventManager.removeNS(`${NS}_viewport`);
      const el = DOM_ELEMENTS?.snackbar;
      if (el) el.style.bottom = '';
    }
  };
  
  const show = (message) => {
    const el = DOM_ELEMENTS?.snackbar;
    if (!el || !message) return;
    
    hideTimer = clearTimer(hideTimer);
    
    el.textContent = message;
    el.classList.remove('show');
    void el.offsetHeight;
    el.classList.add('show');
    
    if (isMobileView()) {
      lastBottom = -1;
      updatePosition();
      toggleTracking(true);
    } else {
      el.style.bottom = `${CONFIG.BASE_OFFSET}px`;
    }
    
    hideTimer = setTimeout(() => {
      el.classList.remove('show');
      setTimeout(() => {
        if (!el.classList.contains('show')) toggleTracking(false);
      }, CONFIG.HIDE_ANIMATION);
      hideTimer = null;
    }, CONFIG.SHOW_DURATION);
  };
  
  const handleWindowResize = () => {
    viewportChangeTimer = clearTimer(viewportChangeTimer);
    
    viewportChangeTimer = setTimeout(() => {
      const el = DOM_ELEMENTS?.snackbar;
      if (!el?.classList.contains('show')) {
        viewportChangeTimer = null;
        return;
      }
      
      if (isMobileView()) {
        if (!trackingKeyboard) {
          lastBottom = -1;
          toggleTracking(true);
          updatePosition();
        }
      } else {
        toggleTracking(false);
        el.style.bottom = `${CONFIG.BASE_OFFSET}px`;
      }
      
      viewportChangeTimer = null;
    }, CONFIG.RESIZE_DEBOUNCE);
  };
  
  EventManager.addNS(NS, window, 'resize', handleWindowResize, { passive: true });
  
  return {
    show,
    cleanup: () => {
      hideTimer = clearTimer(hideTimer);
      viewportChangeTimer = clearTimer(viewportChangeTimer);
      
      EventManager.removeNS(NS);
      EventManager.removeNS(`${NS}_viewport`);
      EventManager.forceCleanup();
      
      trackingKeyboard = false;
      lastBottom = -1;
      
      const el = DOM_ELEMENTS?.snackbar;
      if (el) {
        el.style.bottom = '';
        el.classList.remove('show');
      }
    }
  };
})();
const showSnackbar = SnackbarManager.show;
const scrollAndFocusElement = (el, msg) => {
  if (msg) showSnackbar(msg);

  const offsetTop = el.getBoundingClientRect().top + window.pageYOffset - 80;
  window.scrollTo({
    top: offsetTop,
    behavior: 'smooth'
  });

  if (!el.disabled) {
    el.focus({ preventScroll: true });
  }

  return false;
};

// ========== TOOLTIP SYSTEM ==========
const TooltipManager = (() => {
  const activeTooltips = new Map();
  const lazyTooltips = new Map();
  let orphanObserver = null;
  let autoInitObserver = null;
  let tooltipConfig = {};

  const CONFIG = {
    HIDE_DELAY: 300,
    MARGIN: 16,
    OFFSET: 12,
    TRANSITION_DURATION: 200,
    TRANSITION_TIMING: 'cubic-bezier(0.25, 0.8, 0.25, 1)'
  };

  const SVG_ICON = `<svg xmlns="http://www.w3.org/2000/svg" height="70" fill="#dcddde" viewBox="0 -960 960 960" width="70"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>`;

  const forceReflow = (element) => void element.offsetHeight;

  const cleanupTooltipData = (map, node) => {
    const data = map.get(node);
    if (!data) return;

    if (data.cleanup) data.cleanup();
    if (data.listenerIds) {
      data.listenerIds.forEach(id => EventManager.remove(id));
    }
    map.delete(node);
  };

  const cleanupOrphanedTooltip = (node) => {
    cleanupTooltipData(activeTooltips, node);
    cleanupTooltipData(lazyTooltips, node);
  };

  const cleanupChildTooltips = (node) => {
    if (!node.querySelectorAll) return;

    [activeTooltips, lazyTooltips].forEach(map => {
      map.forEach((data, el) => {
        if (el !== node && node.contains(el)) {
          if (data.cleanup) data.cleanup();
          if (data.listenerIds) {
            data.listenerIds.forEach(id => EventManager.remove(id));
          }
          map.delete(el);
        }
      });
    });
  };

  const createObserver = (callback, shouldObserve) => {
    if (!shouldObserve || typeof MutationObserver === 'undefined') return null;

    const observer = new MutationObserver(callback);
    observer.observe(document.body, { childList: true, subtree: true });
    return observer;
  };

  const startOrphanDetection = () => {
    if (orphanObserver) return;

    orphanObserver = createObserver((mutations) => {
      const elementsToCheck = new Set();

      mutations.forEach(mutation => {
        mutation.removedNodes.forEach(node => {
          if (node.nodeType === 1) elementsToCheck.add(node);
        });
      });

      elementsToCheck.forEach(node => {
        cleanupOrphanedTooltip(node);
        cleanupChildTooltips(node);
      });
    }, true);
  };

  const matchesSelector = (element, selector) => {
    if (selector.startsWith('#')) return element.id === selector.slice(1);
    if (selector.startsWith('.')) return element.classList.contains(selector.slice(1));
    if (selector.startsWith('[')) {
      const attrMatch = selector.match(/\[([^\]]+)\]/);
      if (attrMatch) {
        const [attrName, attrValue] = attrMatch[1].split('=');
        return attrValue 
          ? element.getAttribute(attrName) === attrValue.replace(/['"]/g, '')
          : element.hasAttribute(attrName);
      }
    }
    return element.matches(selector);
  };

  const injectSVG = (element) => {
    if (element.classList.contains('tooltip-button') && !element.querySelector('svg')) {
      element.innerHTML = SVG_ICON;
    }
  };

  const initializeElement = (element) => {
    if (lazyTooltips.has(element)) return;

    injectSVG(element);

    Object.entries(tooltipConfig).forEach(([selector, content]) => {
      try {
        if (matchesSelector(element, selector)) {
          registerLazyTooltip(element, content);
        }
      } catch (e) {}
    });
  };

  const startAutoInit = () => {
    if (autoInitObserver || Object.keys(tooltipConfig).length === 0) return;

    autoInitObserver = createObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType !== 1) return;

          initializeElement(node);

          if (node.querySelectorAll) {
            Object.keys(tooltipConfig).forEach(selector => {
              try {
                node.querySelectorAll(selector).forEach(el => initializeElement(el));
              } catch (e) {}
            });
          }
        });
      });
    }, true);
  };

  const stopObserver = (observer) => {
    if (!observer) return null;
    observer.disconnect();
    return null;
  };

  const stopAutoInit = () => {
    autoInitObserver = stopObserver(autoInitObserver);
  };

  const stopOrphanDetection = () => {
    orphanObserver = stopObserver(orphanObserver);
  };

  const calculateTooltipSize = (tooltip) => {
    tooltip.style.cssText = 'visibility:hidden;display:block';
    const size = { width: tooltip.offsetWidth, height: tooltip.offsetHeight };
    tooltip.style.cssText = '';
    return size;
  };

  const calculatePosition = (rect, scrollX, scrollY, tooltipWidth, tooltipHeight) => {
    const centerX = rect.left + scrollX + (rect.width / 2);
    const maxLeft = window.innerWidth - tooltipWidth - CONFIG.MARGIN;
    const left = Math.max(CONFIG.MARGIN, Math.min(centerX - (tooltipWidth / 2), maxLeft));

    let top = rect.top + scrollY - tooltipHeight - CONFIG.OFFSET;
    let isFlipped = false;

    if (top < CONFIG.MARGIN + scrollY) {
      top = rect.bottom + scrollY + CONFIG.OFFSET;
      isFlipped = true;
    }

    return { left, top, isFlipped };
  };

  const applyTooltipStyles = (tooltip, transform, opacity) => {
    tooltip.style.transform = transform;
    tooltip.style.opacity = opacity.toString();
  };

  const createTooltip = (triggerElement, content) => {
    if (!triggerElement || !content) return;

    const existing = activeTooltips.get(triggerElement);
    if (existing?.cleanup) {
      existing.cleanup();
      activeTooltips.delete(triggerElement);
    }

    const tooltip = document.createElement("div");
    tooltip.className = "tooltip-wrap";
    tooltip.innerHTML = content;
    
    const transitionProps = `opacity ${CONFIG.TRANSITION_DURATION}ms ${CONFIG.TRANSITION_TIMING}, transform ${CONFIG.TRANSITION_DURATION}ms ${CONFIG.TRANSITION_TIMING}`;
    tooltip.style.transition = transitionProps;
    tooltip.style.willChange = 'opacity, transform';
    
    document.body.appendChild(tooltip);

    let isVisible = false;
    let hideTimer = null;
    let rafId = null;
    let cachedSize = null;
    const namespace = `tooltip-active-${Date.now()}-${Math.random()}`;

    const cleanup = () => {
      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      EventManager.removeNS(namespace);

      if (tooltip.parentNode) {
        tooltip.parentNode.removeChild(tooltip);
      }

      activeTooltips.delete(triggerElement);
    };

    const updatePosition = () => {
      if (!document.contains(triggerElement) || !document.contains(tooltip)) {
        cleanup();
        return;
      }

      const rect = triggerElement.getBoundingClientRect();
      const scrollX = window.pageXOffset;
      const scrollY = window.pageYOffset;

      if (!cachedSize) {
        cachedSize = calculateTooltipSize(tooltip);
      }

      const { left, top, isFlipped } = calculatePosition(rect, scrollX, scrollY, cachedSize.width, cachedSize.height);

      tooltip.classList.toggle('flipped', isFlipped);
      tooltip.style.transform = `translate(${left}px, ${top}px)`;
    };

    const show = () => {
      if (isVisible) return;

      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }

      updatePosition();
      
      applyTooltipStyles(tooltip, `${tooltip.style.transform} scale(0.95)`, 0);
      forceReflow(tooltip);
      
      isVisible = true;
      tooltip.classList.add('show');
      
      requestAnimationFrame(() => {
        applyTooltipStyles(tooltip, tooltip.style.transform.replace(' scale(0.95)', ' scale(1)'), 1);
      });
    };

    const hide = () => {
      if (!isVisible) return;

      isVisible = false;
      applyTooltipStyles(tooltip, tooltip.style.transform.replace(' scale(1)', ' scale(0.95)'), 0);
      
      setTimeout(() => {
        tooltip.classList.remove('show');
        cleanup();
      }, CONFIG.TRANSITION_DURATION);
    };

    const handleOutsideInteraction = (e) => {
      if (!isVisible) return;
      if (triggerElement.contains(e.target) || tooltip.contains(e.target)) return;
      hide();
    };

    const handleKeydown = (e) => {
      if (e.key === "Escape" && isVisible) hide();
    };

    const smoothReposition = () => {
      if (!isVisible || rafId) return;
      
      rafId = requestAnimationFrame(() => {
        updatePosition();
        rafId = null;
      });
    };

    const passiveOpt = { passive: true };

    EventManager.addNS(namespace, document, "click", handleOutsideInteraction);
    EventManager.addNS(namespace, document, "touchend", handleOutsideInteraction, passiveOpt);
    EventManager.addNS(namespace, document, "keydown", handleKeydown);
    EventManager.addNS(namespace, window, 'resize', smoothReposition, passiveOpt);
    EventManager.addNS(namespace, window, 'scroll', smoothReposition, passiveOpt);

    activeTooltips.set(triggerElement, { tooltip, cleanup, namespace });

    show();
  };

  const registerLazyTooltip = (triggerElement, content) => {
    if (!triggerElement || !content) return;

    const existing = lazyTooltips.get(triggerElement);
    if (existing && existing.content === content) return;

    if (existing?.listenerIds) {
      existing.listenerIds.forEach(id => EventManager.remove(id));
    }

    const namespace = `tooltip-lazy-${Date.now()}-${Math.random()}`;

    const initTooltip = (e) => {
      if (e?.cancelable) e.preventDefault();
      createTooltip(triggerElement, content);
    };

    const handleClick = (e) => {
      const target = e.target;
      if (target === triggerElement || triggerElement.contains(target)) {
        initTooltip(e);
      }
    };

    const listenerIds = [
      EventManager.addNS(namespace, triggerElement, "click", handleClick),
      EventManager.addNS(namespace, triggerElement, "touchend", handleClick, { passive: false })
    ];

    lazyTooltips.set(triggerElement, { content, namespace, listenerIds });

    if (lazyTooltips.size === 1 && !orphanObserver) {
      startOrphanDetection();
    }
  };

  const destroyAll = () => {
    stopAutoInit();
    stopOrphanDetection();

    activeTooltips.forEach(({ cleanup }) => {
      if (cleanup) cleanup();
    });
    activeTooltips.clear();

    lazyTooltips.forEach(({ listenerIds }) => {
      if (listenerIds) {
        listenerIds.forEach(id => EventManager.remove(id));
      }
    });
    lazyTooltips.clear();

    tooltipConfig = {};
  };

  return {
    registerLazyTooltip,
    startAutoInit,
    stopAutoInit,
    setConfig: (config) => {
      tooltipConfig = config;
      startAutoInit();
    },
    destroyAll,
    initializeElement
  };
})();
const setupTooltips = (config) => {
  TooltipManager.setConfig(config);

  Object.entries(config).forEach(([selector, content]) => {
    const elements = typeof selector === 'string' 
      ? document.querySelectorAll(selector)
      : selector instanceof Element ? [selector] : [];

    elements.forEach(el => {
      if (el instanceof Element) {
        TooltipManager.initializeElement(el);
      }
    });
  });
};
setupTooltips({
  ".calcTips": "Don't expect too much! This tool calculates some RNG stats and buffs [ Examples: <a href='#' class='job-sim' data-lightbox-gallery='my-gallery' data-lightbox-trigger>Album#1</a>, <a href='#' class='job-sim' data-lightbox-gallery='new-version' data-lightbox-trigger>Album#2</a>].",
  //"#attackTypeTips": "This calculator has been tested with physical jobs (PEN). Calculations for magical or critical builds may vary slightly.",
  "#weaponTips": "Physical Suno or Meister can select weapons without size penalty, such as GS, Shuriken, or Book (Weapon Perfection passive).",
  "#mvpminiTips": "DUMMY has no defense stat. Avg 130, Necro, Ogre, Ktul defs are less accurate than others!",
  "#targetRaceTips": "Selecting a specific MVP/Mini will <strong>automatically sync and lock</strong> this option. Select <strong>Avg Lvl Boss</strong> to target a specific race.",
  "#targetAttrTips": "Same applies to race.",
  // "#blueTips": "Blue*8 in testing^^",
  "#whiteTips": "White set is RNG-based effects. This calculator uses displayed in-game values without normalization. Selecting this set shows maximum output when the Tough Resilience buff is active.",
  "#rawAttackTips": "If you're using the Vesper set, check your attack value when you reach 5 stacks, and make sure only vesper buff is active (<a href='#' data-lightbox-image='img/Calc_Tips_Atk.jpg' data-caption='make sure only vesper buff is active'>like this</a>).",
  "#dmgRaceTips": "Unlocked when a target race is selected.Minimum valid value is 0. ",
  "#dmgAttrTips": "Same condition applies as damage to race.",
  "#dmgStackTips": "<strong>Final DMG Bonus</strong> and <strong>F. P/M DMG BONUS</strong> are <strong>different</strong>! Check your <strong>detailed stats</strong> where it shows as <strong>Final Damage Stack</strong> or <strong>Final Damage Bonus</strong>. Make sure you don't have any buffs active. Can't find it? Just set it to 0.",
  "#breakdownTips": "Values are shown to two decimal places for readability. The final result is computed with precision, so it may differ slightly if you recompute using the displayed numbers.",
  "#elemCtrTips": "Tool assumes target is Neutral if you're not targeting any attribute.",
  "#reaperTips": "Whether the elements match (+84% Final DMG Bonus) or differ (+28% Final DMG Bonus).",
  "#spearTips": "Value shown below represents the highest output during the buff's active period.",
  "#flashTips": "The values below are normalized to 100% uptime because both flashes only last 10 seconds on a 20-second cooldown.",
  "#tableTips": "An upward arrow means higher than your stat, a square means roughly equal (±3%), and a downward arrow means lower."
});

// ======== ABOUT CARD ========
const aboutCard = (() => {
  const card = document.querySelector('.altsim-card');
  const cardBody = document.querySelector('.altsim-card-body');
  const arrowBtn = document.querySelector('.altsim-btn-arrow');
  
  const STORAGE_KEY = 'aboutCardCollapsed';
  const NAMESPACE = 'about-card';
  const savedState = localStorage.getItem(STORAGE_KEY);
  let isCollapsed = savedState === 'true';
  
  const setCardState = (collapsed) => {
    if (collapsed) {
      cardBody.style.maxHeight = '0px';
      card.classList.add('collapsed');
    } else {
      cardBody.style.maxHeight = 'none';
      card.classList.remove('collapsed');
    }
  };
  
  const initCollapse = () => setCardState(isCollapsed);
  
  const toggleCollapse = () => {
    isCollapsed = !isCollapsed;
    
    if (isCollapsed) {
      cardBody.style.maxHeight = cardBody.scrollHeight + 'px';
      cardBody.offsetHeight;
      cardBody.style.maxHeight = '0px';
      card.classList.add('collapsed');
    } else {
      cardBody.style.maxHeight = cardBody.scrollHeight + 'px';
      card.classList.remove('collapsed');
      
      const handleTransitionEnd = () => {
        if (!isCollapsed) {
          cardBody.style.maxHeight = 'none';
        }
        cardBody.removeEventListener('transitionend', handleTransitionEnd);
      };
      cardBody.addEventListener('transitionend', handleTransitionEnd);
    }
    
    localStorage.setItem(STORAGE_KEY, String(isCollapsed));
  };
  
  initCollapse();
  
  if (arrowBtn) {
    EventManager.addNS(NAMESPACE, arrowBtn, 'click', toggleCollapse);
  }
  
  const destroy = () => EventManager.removeNS(NAMESPACE);
  
  EventManager.addNS(NAMESPACE, window, 'beforeunload', destroy);
  
  return { destroy };
})();

// ======== HOW TO ========
const accordionManager = (() => {
  const CONFIG = {
    duration: 320,
    easing: 'cubic-bezier(0.25, 0.8, 0.25, 1)',
    cleanupInterval: 30000
  };
  
  const transition = `max-height ${CONFIG.duration}ms ${CONFIG.easing}, opacity ${CONFIG.duration}ms ${CONFIG.easing}`;
  const instances = new Map();
  const namespace = 'accordion-manager';
  let observer = null;
  let cleanupInterval = null;
  
  const forceReflow = (element) => void element.offsetHeight;
  
  const applyStyles = (content, maxHeight, opacity, enableTransition) => {
    content.style.cssText = `
      overflow: hidden;
      will-change: max-height, opacity;
      transition: ${enableTransition ? transition : 'none'};
      max-height: ${maxHeight};
      opacity: ${opacity};
    `;
  };
  
  const createInstance = (details, summary, content) => {
    let isAnimating = false;
    let currentAnimation = null;
    let transitionListenerId = null;
    const instanceNamespace = `${namespace}-${Date.now()}-${Math.random()}`;
    
    const cleanup = () => {
      if (currentAnimation) {
        cancelAnimationFrame(currentAnimation);
        currentAnimation = null;
      }
      if (transitionListenerId !== null) {
        EventManager.remove(transitionListenerId);
        transitionListenerId = null;
      }
      isAnimating = false;
    };
    
    const setupTransitionListener = (callback) => {
      if (transitionListenerId !== null) {
        EventManager.remove(transitionListenerId);
      }
      
      const onTransitionEnd = (e) => {
        if (e.target !== content || e.propertyName !== 'max-height') return;
        
        EventManager.remove(transitionListenerId);
        transitionListenerId = null;
        isAnimating = false;
        callback();
      };
      
      transitionListenerId = EventManager.add(content, 'transitionend', onTransitionEnd);
    };
    
    const animate = (isOpening) => {
      if (isOpening) {
        details.setAttribute('open', '');
        const targetHeight = content.scrollHeight;
        applyStyles(content, '0px', 0.3, false);
        forceReflow(content);
        
        currentAnimation = requestAnimationFrame(() => {
          applyStyles(content, `${targetHeight}px`, 1, true);
          setupTransitionListener(() => applyStyles(content, 'none', 1, true));
          currentAnimation = null;
        });
      } else {
        const currentHeight = content.scrollHeight;
        applyStyles(content, `${currentHeight}px`, 1, false);
        forceReflow(content);
        
        currentAnimation = requestAnimationFrame(() => {
          applyStyles(content, '0px', 0.3, true);
          setupTransitionListener(() => details.removeAttribute('open'));
          currentAnimation = null;
        });
      }
    };
    
    const handleClick = (e) => {
      e.preventDefault();
      if (isAnimating) return;
      
      cleanup();
      isAnimating = true;
      
      const isOpen = details.hasAttribute('open');
      animate(!isOpen);
    };
    
    EventManager.addNS(instanceNamespace, summary, 'click', handleClick);
    
    return {
      cleanup: () => {
        cleanup();
        EventManager.removeNS(instanceNamespace);
      },
      get isAnimating() {
        return isAnimating;
      },
      namespace: instanceNamespace
    };
  };
  
  const cleanupOrphans = () => {
    const orphanedKeys = [];
    
    instances.forEach((instance, details) => {
      if (!document.contains(details)) {
        instance.cleanup();
        orphanedKeys.push(details);
      }
    });
    
    orphanedKeys.forEach(key => instances.delete(key));
    
    if (instances.size === 0 && cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
  };
  
  const startCleanupInterval = () => {
    if (cleanupInterval || instances.size === 0) return;
    cleanupInterval = setInterval(cleanupOrphans, CONFIG.cleanupInterval);
  };
  
  const initializeDetailsElement = (details) => {
    const summary = details.querySelector('summary');
    const content = details.querySelector('.body');
    
    if (!summary || !content || instances.has(details)) return;
    
    const isOpen = details.hasAttribute('open');
    
    applyStyles(content, isOpen ? 'none' : '0px', isOpen ? 1 : 0.3, false);
    forceReflow(content);
    applyStyles(content, isOpen ? 'none' : '0px', isOpen ? 1 : 0.3, true);
    
    instances.set(details, createInstance(details, summary, content));
  };
  
  const processDetails = () => {
    cleanupOrphans();
    document.querySelectorAll('details').forEach(initializeDetailsElement);
    startCleanupInterval();
  };
  
  const shouldProcessMutation = (mutations) => {
    for (const mutation of mutations) {
      if (mutation.addedNodes.length === 0) continue;
      
      for (const node of mutation.addedNodes) {
        if (node.nodeType !== 1) continue;
        if (node.tagName === 'DETAILS' || node.querySelector?.('details')) return true;
      }
    }
    return false;
  };
  
  const handleRemovedNodes = (mutations) => {
    for (const mutation of mutations) {
      if (mutation.removedNodes.length === 0) continue;
      
      for (const node of mutation.removedNodes) {
        if (node.nodeType !== 1) continue;
        
        if (node.tagName === 'DETAILS' && instances.has(node)) {
          instances.get(node).cleanup();
          instances.delete(node);
          continue;
        }
        
        if (node.querySelectorAll) {
          instances.forEach((instance, details) => {
            if (node.contains(details)) {
              instance.cleanup();
              instances.delete(details);
            }
          });
        }
      }
    }
  };
  
  processDetails();
  
  observer = new MutationObserver((mutations) => {
    handleRemovedNodes(mutations);
    if (shouldProcessMutation(mutations)) {
      requestAnimationFrame(processDetails);
    }
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  const destroy = () => {
    if (cleanupInterval) {
      clearInterval(cleanupInterval);
      cleanupInterval = null;
    }
    if (observer) {
      observer.disconnect();
      observer = null;
    }
    instances.forEach(instance => instance.cleanup());
    instances.clear();
  };
  
  EventManager.addNS(namespace, window, 'beforeunload', destroy);
  
  return {
    destroy,
    reinitialize: processDetails
  };
})();

// ======== CHANGELOG ========
const modalManager = (() => {
  const { log, openLog, closeLog } = DOM_ELEMENTS || {};
  if (!log) {
    return {
      show: () => {},
      hide: () => {},
      destroy: () => {}
    };
  }
  
  const content = log.querySelector('.modal-content, .log-content, .modal-body') || log.firstElementChild;
  const changelog = log.querySelector('#changelog');
  
  const CONFIG = {
    duration: 280,
    easing: 'cubic-bezier(0.25, 0.8, 0.25, 1)',
    namespace: 'modal-manager'
  };
  
  const transition = `${CONFIG.duration}ms ${CONFIG.easing}`;
  
  log.style.cssText = `
    display: none;
    transition: opacity ${transition}, transform ${transition}, backdrop-filter ${transition};
    transform-origin: center;
  `;
  
  if (content) {
    content.style.cssText = `
      transition: transform ${transition}, opacity ${transition};
    `;
  }
  
  let isVisible = false;
  let animationId = null;
  let hideTimeout = null;
  let changelogLoaded = false;
  
  const forceReflow = (element) => void element.offsetHeight;
  
  const clearTimers = () => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    if (hideTimeout) {
      clearTimeout(hideTimeout);
      hideTimeout = null;
    }
  };
  
  const applyModalStyles = (isShowing) => {
    if (isShowing) {
      log.style.cssText += `
        opacity: 1;
        transform: scale(1);
        backdrop-filter: blur(6px);
        background-color: rgba(0, 0, 0, 0.3);
      `;
    } else {
      log.style.cssText += `
        opacity: 0;
        transform: scale(0.96);
        backdrop-filter: blur(0px);
        background-color: transparent;
      `;
    }
  };
  
  const applyContentStyles = (isShowing) => {
    if (!content) return;
    
    if (isShowing) {
      content.style.cssText += `
        transform: translateY(0) scale(1);
        opacity: 1;
      `;
    } else {
      content.style.cssText += `
        transform: translateY(-8px) scale(0.98);
        opacity: 0.5;
      `;
    }
  };
  
  const renderList = (items) => {
    if (!Array.isArray(items)) return '';
    
    return items.map(item => {
      if (typeof item === 'string') {
        return `<li>${item}</li>`;
      }
      if (item.category !== undefined) {
        if (item.category === '') {
          return renderList(item.items);
        }
        return `
          <li>
            <span class="sub-cats">${item.category}</span>
            <ul>${renderList(item.items)}</ul>
          </li>`;
      }
      if (item.text) {
        const nested = item.items ? `<ul>${renderList(item.items)}</ul>` : '';
        return `<li>${item.text}${nested}</li>`;
      }
      return '';
    }).join('');
  };
  
  const loadChangelog = async () => {
    if (changelogLoaded) return;
    
    try {
      const response = await fetch('changelog.json');
      if (!response.ok) throw new Error('Failed to load changelog');
      
      const data = await response.json();
      
      const header = changelog.querySelector('.header-log');
      changelog.innerHTML = '';
      if (header) changelog.appendChild(header);
      
      data.versions.forEach(version => {
        const versionDiv = document.createElement('div');
        versionDiv.className = 'version';
        versionDiv.innerHTML = `
          <h3>[${version.version}] - ${version.date}</h3>
          <ul>${renderList(version.changes)}</ul>
        `;
        changelog.appendChild(versionDiv);
      });
      
      changelogLoaded = true;
    } catch (error) {
      console.error('Error loading changelog:', error);
      
      const errorDiv = document.createElement('div');
      errorDiv.className = 'version';
      errorDiv.innerHTML = '<p style="color: #ff6b6b;">Failed to load changelog. Please try again later.</p>';
      changelog.appendChild(errorDiv);
    }
  };
  
  const setVisibility = (visible) => {
    if (visible === isVisible) return;
    
    isVisible = visible;
    clearTimers();
    
    if (visible) {
      log.style.display = 'flex';
      forceReflow(log);
      
      animationId = requestAnimationFrame(() => {
        applyModalStyles(true);
        applyContentStyles(true);
        animationId = null;
      });
      
      loadChangelog();
    } else {
      applyModalStyles(false);
      applyContentStyles(false);
      
      hideTimeout = setTimeout(() => {
        if (!isVisible) {
          log.style.display = 'none';
        }
      }, CONFIG.duration);
    }
  };
  
  const hide = () => setVisibility(false);
  const show = () => setVisibility(true);
  
  const handleOpen = (e) => {
    e.stopPropagation();
    show();
  };
  
  const handleKeydown = (e) => {
    if (e.key === 'Escape' && isVisible) hide();
  };
  
  const handleOutsideClick = (e) => {
    if (!isVisible || !content) return;
    if (content.contains(e.target) || e.target === openLog) return;
    hide();
  };
  
  EventManager.addNS(CONFIG.namespace, openLog, 'click', handleOpen);
  EventManager.addNS(CONFIG.namespace, closeLog, 'click', hide);
  EventManager.addNS(CONFIG.namespace, document, 'keydown', handleKeydown);
  EventManager.addNS(CONFIG.namespace, document, 'click', handleOutsideClick);
  
  const destroy = () => {
    clearTimers();
    EventManager.removeNS(CONFIG.namespace);
  };
  
  EventManager.addNS(CONFIG.namespace, window, 'beforeunload', destroy);
  
  return { show, hide, destroy };
})();

// ======== LIGHTBOX ========
const lightboxConfig = {
  galleries: [
    {
      name: 'my-gallery',
      images: [
        { src: 'img/Calc_vs_Ingame-0.jpg', caption: 'Final DMG Bonus 24 from 5 Stack Vesper T2' },
        { src: 'img/Calc_vs_Ingame-1.jpg', caption: 'no buff active (P ATTK 325002)' },
        { src: 'img/Calc_vs_Ingame-2.jpg', caption: '5 Stack Vesper (P ATTK 352793)' },
        { src: 'img/Calc_vs_Ingame-3.jpg', caption: 'Spear Flash Triggered (P ATTK 325002)' },
        { src: 'img/Calc_vs_Ingame-4.jpg', caption: 'Spear + 5 Stack Vesper (P ATTK 352793)' }
      ]
    },
    {
      name: 'new-version',
      images: [
        { src: 'img/Test_New-V_ArcAngel.jpg', caption: '' },
        { src: 'img/Calc_x_Ingame_1.1.6_0.jpg', caption: '' },
        { src: 'img/Calc_x_Ingame_1.1.6_1.jpg', caption: '' },
        { src: 'img/Calc_x_Ingame_1.1.6_2.jpg', caption: 'Spear Flash Triggered' }
      ]
    }
  ]
};
const imgLightbox = ((config = {}) => {
  const NS = 'img-lightbox';
  const NS_GALLERY = 'img-lightbox-gallery';
  const els = {
    overlay: document.getElementById('img-lightbox-overlay'),
    image: document.querySelector('.img-lightbox-image'),
    loader: document.querySelector('.img-lightbox-loader'),
    closeBtn: document.querySelector('.img-lightbox-close'),
    inner: document.querySelector('.img-lightbox-inner'),
    caption: document.querySelector('.img-lightbox-caption'),
    counter: document.querySelector('.img-lightbox-counter'),
    prevBtn: document.querySelector('.img-lightbox-prev'),
    nextBtn: document.querySelector('.img-lightbox-next')
  };

  const state = {
    scale: 1,
    translateX: 0,
    translateY: 0,
    isDragging: false,
    dragStartX: 0,
    dragStartY: 0,
    pinchStart: 0,
    scaleStart: 1,
    imageLoadId: null,
    galleries: {},
    currentGallery: null,
    currentIndex: 0
  };

  const cfg = {
    MIN: 1,
    MAX: 5,
    STEP: 0.3
  };

  const lazyInitGallery = (galleryName) => {
    if (state.galleries[galleryName]) return;

    const galleryConfig = config.galleries?.find(g => g.name === galleryName);
    if (!galleryConfig) return;

    const container = document.getElementById('lightbox-galleries') || (() => {
      const div = document.createElement('div');
      div.id = 'lightbox-galleries';
      div.style.display = 'none';
      document.body.appendChild(div);
      return div;
    })();

    galleryConfig.images.forEach(img => {
      const div = document.createElement('div');
      div.setAttribute('data-lightbox-item', galleryName);
      div.setAttribute('data-lightbox-image', img.src);
      if (img.caption) {
        div.setAttribute('data-caption', img.caption);
      }
      container.appendChild(div);
    });

    initGalleries(container);
  };

  const resolveURL = (path) => {
    if (/^https?:\/\//i.test(path)) {
      return path;
    }
    
    const base = window.location.origin;
    
    if (path.startsWith('/')) {
      return base + path;
    }
    
    const currentPath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
    return base + currentPath + '/' + path;
  };

  const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
  const dist = (t1, t2) => Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
  const center = (t1, t2) => ({
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  });

  const apply = () => {
    els.image.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
  };

  const reset = () => {
    Object.assign(state, {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isDragging: false
    });
    apply();
    els.image.style.cursor = 'default';
  };

  const cleanupLoaders = () => {
    if (els.image) {
      els.image.onload = null;
      els.image.onerror = null;
    }
    state.imageLoadId = null;
  };

  const getCurrentItems = () => {
    return state.currentGallery ? state.galleries[state.currentGallery] : [];
  };

  const updateUI = () => {
    const items = getCurrentItems();
    const item = items[state.currentIndex];
    
    els.prevBtn.classList.toggle('disabled', state.currentIndex === 0);
    els.nextBtn.classList.toggle('disabled', state.currentIndex === items.length - 1);
    els.counter.textContent = `${state.currentIndex + 1} / ${items.length}`;
    
    if (item?.caption) {
      els.caption.textContent = item.caption;
      els.caption.classList.add('active');
    } else {
      els.caption.textContent = '';
      els.caption.classList.remove('active');
    }
  };

  const setActive = (active) => {
    els.overlay.classList.toggle('img-lightbox-active', active);
    document.body.style.overflow = active ? 'hidden' : '';
    if (!active) {
      cleanupLoaders();
      reset();
      state.currentGallery = null;
    }
  };

  const loadImage = (index) => {
    const items = getCurrentItems();
    if (index < 0 || index >= items.length) return;

    state.currentIndex = index;
    cleanupLoaders();

    els.loader.style.display = 'block';
    els.image.style.display = 'none';
    reset();

    const item = items[index];
    const id = Symbol();
    state.imageLoadId = id;

    const handleLoad = (success) => {
      if (state.imageLoadId !== id) return;
      
      els.loader.style.display = 'none';
      if (success) {
        els.image.style.display = 'block';
      } else {
        console.error('Failed to load image');
      }
      cleanupLoaders();
    };

    els.image.onload = () => handleLoad(true);
    els.image.onerror = () => handleLoad(false);
    els.image.src = resolveURL(item.src);
    
    updateUI();
  };

  const openGallery = (galleryName, startIndex = 0) => {
    lazyInitGallery(galleryName);
    
    if (!state.galleries[galleryName]) return;
    state.currentGallery = galleryName;
    setActive(true);
    loadImage(startIndex);
  };

  const close = () => setActive(false);

  const navigate = (direction) => {
    const items = getCurrentItems();
    const newIndex = state.currentIndex + direction;
    if (newIndex >= 0 && newIndex < items.length) {
      loadImage(newIndex);
    }
  };

  const updateTransform = (newScale, clientX, clientY) => {
    const old = state.scale;
    state.scale = clamp(newScale, cfg.MIN, cfg.MAX);

    if (state.scale !== old) {
      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
      } else {
        const ratio = state.scale / old;
        state.translateX = clientX - (clientX - state.translateX) * ratio;
        state.translateY = clientY - (clientY - state.translateY) * ratio;
      }
      apply();
      els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
    }
  };

  const onWheel = (e) => {
    if (!els.overlay.classList.contains('img-lightbox-active')) return;
    e.preventDefault();

    const delta = e.deltaY < 0 ? cfg.STEP : -cfg.STEP;
    updateTransform(state.scale + delta, e.clientX, e.clientY);
  };

  const onMouseDown = (e) => {
    if (state.scale <= cfg.MIN) return;
    state.isDragging = true;
    state.dragStartX = e.clientX - state.translateX;
    state.dragStartY = e.clientY - state.translateY;
    els.image.style.cursor = 'grabbing';
    e.preventDefault();
  };

  const onMouseMove = (e) => {
    if (!state.isDragging) return;
    state.translateX = e.clientX - state.dragStartX;
    state.translateY = e.clientY - state.dragStartY;
    apply();
  };

  const onMouseUp = () => {
    if (!state.isDragging) return;
    state.isDragging = false;
    els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
  };

  const onDblClick = (e) => {
    e.preventDefault();
    if (state.scale > cfg.MIN) {
      reset();
    } else {
      const rect = els.image.getBoundingClientRect();
      state.scale = 2;
      state.translateX = e.clientX - (e.clientX - rect.left) * 2;
      state.translateY = e.clientY - (e.clientY - rect.top) * 2;
      apply();
      els.image.style.cursor = 'move';
    }
  };

  const startDrag = (clientX, clientY) => {
    state.isDragging = true;
    state.dragStartX = clientX - state.translateX;
    state.dragStartY = clientY - state.translateY;
  };

  const onTouchStart = (e) => {
    const t = e.touches;

    if (t.length === 1 && state.scale > cfg.MIN) {
      startDrag(t[0].clientX, t[0].clientY);
    } else if (t.length === 2) {
      e.preventDefault();
      state.isDragging = false;
      state.pinchStart = dist(t[0], t[1]);
      state.scaleStart = state.scale;
    }
  };

  const onTouchMove = (e) => {
    const t = e.touches;

    if (t.length === 1 && state.isDragging) {
      e.preventDefault();
      state.translateX = t[0].clientX - state.dragStartX;
      state.translateY = t[0].clientY - state.dragStartY;
      apply();
    } else if (t.length === 2 && state.pinchStart) {
      e.preventDefault();
      const c = center(t[0], t[1]);
      const ratio = dist(t[0], t[1]) / state.pinchStart;
      const newScale = clamp(state.scaleStart * ratio, cfg.MIN, cfg.MAX);
      const scaleRatio = newScale / state.scale;

      state.scale = newScale;
      state.translateX = c.x - (c.x - state.translateX) * scaleRatio;
      state.translateY = c.y - (c.y - state.translateY) * scaleRatio;

      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
      }

      apply();
    }
  };

  const onTouchEnd = (e) => {
    if (e.touches.length === 0) {
      state.isDragging = false;
      state.pinchStart = 0;
      if (state.scale === cfg.MIN) {
        state.translateX = state.translateY = 0;
        apply();
      }
    } else if (e.touches.length === 1 && state.scale > cfg.MIN) {
      startDrag(e.touches[0].clientX, e.touches[0].clientY);
      state.pinchStart = 0;
    }
  };

  const onKey = (e) => {
    if (!els.overlay.classList.contains('img-lightbox-active')) return;
    const actions = {
      'Escape': close,
      '0': reset,
      'ArrowLeft': () => navigate(-1),
      'ArrowRight': () => navigate(1)
    };
    actions[e.key]?.();
  };

  const onVisibility = () => {
    if (document.hidden && state.isDragging) {
      state.isDragging = false;
      els.image.style.cursor = state.scale > cfg.MIN ? 'move' : 'default';
    }
  };

  const initGalleries = (container = document) => {
    container.querySelectorAll('[data-lightbox-item]:not([data-lb-init])').forEach(item => {
      item.setAttribute('data-lb-init', '');
      const galleryName = item.getAttribute('data-lightbox-item');
      const src = item.getAttribute('data-lightbox-image');
      const caption = item.getAttribute('data-caption') || '';

      if (!state.galleries[galleryName]) {
        state.galleries[galleryName] = [];
      }

      state.galleries[galleryName].push({ src, caption });
    });

    container.querySelectorAll('[data-lightbox-trigger]:not([data-lb-trigger-init])').forEach(trigger => {
      trigger.setAttribute('data-lb-trigger-init', '');
      const galleryName = trigger.getAttribute('data-lightbox-gallery');

      EventManager.addNS(NS_GALLERY, trigger, 'click', (e) => {
        e.preventDefault();
        if (galleryName) {
          openGallery(galleryName, 0);
        }
      });
    });

    container.querySelectorAll('[data-lightbox-image]:not([data-lightbox-trigger]):not([data-lb-single-init])').forEach(link => {
      link.setAttribute('data-lb-single-init', '');
      const src = link.getAttribute('data-lightbox-image');
      const caption = link.getAttribute('data-caption') || '';

      const singleGalleryName = `single-${Math.random().toString(36).substr(2, 9)}`;
      state.galleries[singleGalleryName] = [{ src, caption }];

      EventManager.addNS(NS_GALLERY, link, 'click', (e) => {
        e.preventDefault();
        openGallery(singleGalleryName, 0);
      });
    });
  };

  initGalleries();

  const observer = new MutationObserver((mutations) => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        if (node.nodeType === 1) {
          if (node.hasAttribute?.('data-lightbox-item') || node.hasAttribute?.('data-lightbox-trigger')) {
            initGalleries(node.parentElement);
          }
          if (node.querySelectorAll) {
            initGalleries(node);
          }
        }
      }
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });

  const passiveOpt = { passive: false };
  const events = [
    [els.closeBtn, 'click', close],
    [els.prevBtn, 'click', () => navigate(-1)],
    [els.nextBtn, 'click', () => navigate(1)],
    [els.overlay, 'click', (e) => e.target === els.overlay && close()],
    [els.inner, 'click', (e) => e.stopPropagation()],
    [document, 'keydown', onKey],
    [document, 'visibilitychange', onVisibility],
    [els.image, 'wheel', onWheel, passiveOpt],
    [els.image, 'mousedown', onMouseDown],
    [document, 'mousemove', onMouseMove],
    [document, 'mouseup', onMouseUp],
    [els.image, 'dblclick', onDblClick],
    [els.image, 'touchstart', onTouchStart, passiveOpt],
    [els.image, 'touchmove', onTouchMove, passiveOpt],
    [els.image, 'touchend', onTouchEnd],
    [els.image, 'touchcancel', onTouchEnd]
  ];

  events.forEach(([el, type, handler, opts]) => {
    EventManager.addNS(NS, el, type, handler, opts);
  });

  const destroy = () => {
    cleanupLoaders();
    observer.disconnect();
    EventManager.removeNS(NS);
    EventManager.removeNS(NS_GALLERY);
  };

  EventManager.addNS(NS, window, 'beforeunload', destroy);

  return { destroy, openGallery };
})(lightboxConfig);

// ======== MAIN BUTTON ========
const mainButtonEvent = (() => {
  if (window._eventsAlreadyBound) return;
  window._eventsAlreadyBound = true;
  
  const editStats = () => {
    if (!confirm('Editing will clear the results. Sure?')) return;
    AppState.reset();
    localStorage.removeItem('pwa_snap');
    ResetHelpers.resetButtons();
    ResetHelpers.resetDisplayContainers();
    unbindInputLockGuard();
    unlockAllInputs();
    dropdownManager.syncThreeSets();
    dropdownManager.handleTargetChange();
    scrollAndFocusElement(DOM_ELEMENTS.atkType);
  };
  
  const buttonBindings = new Map([
    [DOM_ELEMENTS.testSpear, simulateFlash],
    [DOM_ELEMENTS.testReaper, simulateFlash],
    [DOM_ELEMENTS.submit, processMainCalculation],
    [DOM_ELEMENTS.edit, editStats],
    [DOM_ELEMENTS.resetRek, () => {
      regenerateRecommendations();
      showSnackbar?.("Table Refreshed!");
    }],
    [DOM_ELEMENTS.cacheBtn, clearCache],
    [DOM_ELEMENTS.resetAll, resetAllData]
  ]);

  window._buttonListenerIds = [];

  buttonBindings.forEach((handler, element) => {
    if (element?.addEventListener) {
      const listenerId = EventManager.add(element, 'click', handler);
      window._buttonListenerIds.push(listenerId);

      if (element === DOM_ELEMENTS.testSpear || element === DOM_ELEMENTS.testReaper) {
        element.classList.remove('activated');
      }
    }
  });
})();

// ======== PWA ========
const IS_PWA = matchMedia('(display-mode: standalone)').matches || navigator.standalone === true;
const CONSTANTS = Object.freeze({
  PWA_STORAGE_KEY: 'pwa_snap',
  PWA_EXPIRY_MS: 691200000,
  PWA_RESTORE_DELAY_MS: 200,
  PWA_NAMESPACE: 'pwa_persistence',
  PWA_UPDATE_MARKER: 'pwa_updating',
  FORM_SELECTORS: 'select, input[type="number"]',
  SW_UPDATE_CHECK_DELAY: 234,
  SW_SCOPE: '/sim/',
  SW_PATH: '/sim/sw.js',
  SW_UPDATE_INTERVAL: 3600000,
  A2HS_STORAGE: 'a2hsDismissed',
  A2HS_ANIM_DUR: 300,
  A2HS_MODAL_DELAY: 3000,
  A2HS_PROMPT_TIMEOUT: 5000,
  A2HS_DISMISS_EXPIRY: 259200000,
  A2HS_MOBILE_BP: 480,
  OVERLAY_TRANSITION_MS: 200
});
const PWAUtils = {
  scheduleTask: (fn, delay = 0) => {
    delay === 0 && 'requestIdleCallback' in window
      ? requestIdleCallback(fn, { timeout: 100 })
      : setTimeout(fn, delay);
  },
  
  safeJSONParse: (str, fallback = null) => {
    try { return JSON.parse(str); } catch { return fallback; }
  },
  
  safeJSONStringify: (obj) => {
    try { return JSON.stringify(obj); } catch { return null; }
  },
  
  debounce: (fn, ms) => {
    let t;
    return (...args) => (clearTimeout(t), t = setTimeout(() => fn(...args), ms));
  },
  
  storageGet: (k) => {
    try { return localStorage.getItem(k); } catch { return null; }
  },
  
  storageSet: (k, v) => {
    try { localStorage.setItem(k, v); return true; } catch { return false; }
  },
  
  storageRemove: (k) => {
    try { localStorage.removeItem(k); } catch {}
  },
  
  createTimeout: (fn, ms, cleanup) => {
    const id = setTimeout(fn, ms);
    cleanup && cleanup.push(() => clearTimeout(id));
    return id;
  },
  
  addListener: (target, event, handler, options) => {
    target.addEventListener(event, handler, options);
    return () => target.removeEventListener(event, handler, options);
  }
};
const OverlayManager = (() => {
  let element = null;
  let pendingTimeout = null;
  
  const create = () => {
    if (element) return element;
    
    element = document.createElement('div');
    element.className = 'pwa-overlay';
    element.innerHTML = '<div class="pwa-spinner"></div>';
    document.body.appendChild(element);
    
    return element;
  };
  
  const removeElement = () => {
    if (!element) return;
    element.remove();
    element = null;
  };
  
  const clearPendingTimeout = () => {
    if (pendingTimeout) {
      clearTimeout(pendingTimeout);
      pendingTimeout = null;
    }
  };
  
  return {
    show: () => {
      const overlay = create();
      SnackbarQueue.setOverlayState(true);
      requestAnimationFrame(() => overlay.classList.add('active'));
    },
    
    hide: () => {
      if (!element) return;
      element.classList.remove('active');
      clearPendingTimeout();
      pendingTimeout = PWAUtils.createTimeout(() => {
        SnackbarQueue.setOverlayState(false);
        removeElement();
        pendingTimeout = null;
      }, CONSTANTS.OVERLAY_TRANSITION_MS);
    },
    
    forceRemove: () => {
      clearPendingTimeout();
      SnackbarQueue.setOverlayState(false);
      SnackbarQueue.clear();
      removeElement();
    }
  };
})();
const SnackbarQueue = (() => {
  let pending = [];
  let overlayActive = false;
  
  return {
    setOverlayState: (active) => {
      overlayActive = active;
      if (!active && pending.length > 0) {
        SnackbarManager.show(pending.pop());
        pending = [];
      }
    },
    
    add: (message) => {
      overlayActive ? pending.push(message) : SnackbarManager.show(message);
    },
    
    clear: () => { pending = []; }
  };
})();
const PWAServiceWorker = (() => {
  if (!('serviceWorker' in navigator)) return null;
  
  let currentRegistration = null;
  let updateCheckTimer = null;
  
  const scheduleUpdateCheck = (reg) => {
    if (updateCheckTimer) clearTimeout(updateCheckTimer);
    updateCheckTimer = PWAUtils.createTimeout(
      () => reg.update().catch(() => {}), 
      CONSTANTS.SW_UPDATE_CHECK_DELAY
    );
  };
  
  const setupUpdateListener = (reg) => {
    reg.addEventListener('updatefound', () => {
      const newWorker = reg.installing;
      if (newWorker) {
        window.dispatchEvent(new CustomEvent('sw-update-found', {
          detail: { worker: newWorker, registration: reg }
        }));
      }
    });
  };
  
  const registerSW = () => {
    navigator.serviceWorker.register(CONSTANTS.SW_PATH, {
        scope: CONSTANTS.SW_SCOPE,
        updateViaCache: 'none'
      })
      .then(reg => {
        currentRegistration = reg;
        scheduleUpdateCheck(reg);
        setupUpdateListener(reg);
        setInterval(() => reg.update().catch(() => {}), CONSTANTS.SW_UPDATE_INTERVAL);
      })
      .catch(() => {});
  };
  
  const cleanup = () => {
    if (updateCheckTimer) {
      clearTimeout(updateCheckTimer);
      updateCheckTimer = null;
    }
  };
  
  PWAUtils.addListener(window, 'DOMContentLoaded', registerSW, { passive: true });
  PWAUtils.addListener(window, 'beforeunload', cleanup, { passive: true });
  
  return { 
    init: () => {},
    getRegistration: () => currentRegistration,
    cleanup
  };
})();
if (PWAServiceWorker) PWAServiceWorker.init();
const PWAUpdateUIHandler = (() => {
  if (!IS_PWA) {
    DOM_ELEMENTS.checkUpdateBtn?.remove();
    return;
  }
  
  const PWAManualUpdate = (() => {
    const state = {
      isChecking: false,
      updateAvailable: false,
      newWorker: null,
      registration: null,
      updateFoundListener: null,
      controllerChangeListener: null,
      currentPhase: 'idle'
    };
    
    const UI_TEXT = {
      idle: 'Check for Updates',
      checking: 'Checking for updates...',
      downloading: 'Downloading update...',
      installing: 'Installing update...',
      ready: 'Update Available - Click to Install',
      applying: 'Applying update...',
      reloading: 'Reloading app...'
    };
    
    const TIMEOUTS = {
      UPDATE_CHECK: 10000,
      WORKER_STATE: 8000,
      CONTROLLER_CHANGE: 3000,
      CONTROLLER_VERIFY: 100
    };
    
    const PROCESSING_PHASES = ['checking', 'downloading', 'installing', 'applying', 'reloading'];
    
    const setButtonState = (phase) => {
      const btn = DOM_ELEMENTS.checkUpdateBtn;
      if (!btn) return;
      
      state.currentPhase = phase;
      const processing = PROCESSING_PHASES.includes(phase);
      
      btn.disabled = processing;
      btn.textContent = UI_TEXT[phase] || UI_TEXT.idle;
      btn.classList.toggle('checking', processing);
      btn.classList.toggle('update-available', phase === 'ready');
    };
    
    const resetState = () => {
      Object.assign(state, {
        updateAvailable: false,
        newWorker: null,
        registration: null,
        isChecking: false
      });
      setButtonState('idle');
    };
    
    const markUpdateReady = () => {
      state.updateAvailable = true;
      state.isChecking = false;
      setButtonState('ready');
      if (state.isChecking) {
        SnackbarQueue.add('Update ready! Click to install');
      }
    };
    
    const waitForWorkerState = (worker, targetState, timeout = TIMEOUTS.WORKER_STATE) => {
      return new Promise((resolve, reject) => {
        if (worker.state === targetState) return resolve();
        
        const timer = PWAUtils.createTimeout(
          () => {
            worker.removeEventListener('statechange', handler);
            reject(new Error('Timeout waiting for worker state'));
          }, 
          timeout
        );
        
        const handler = () => {
          if (worker.state === targetState) {
            clearTimeout(timer);
            worker.removeEventListener('statechange', handler);
            resolve();
          }
        };
        
        worker.addEventListener('statechange', handler);
      });
    };
    
    const handleWorker = async (reg, workerType) => {
      const worker = workerType === 'waiting' ? reg.waiting : reg.installing;
      state.newWorker = worker;
      state.registration = reg;
      
      if (workerType === 'waiting') {
        markUpdateReady();
        return;
      }
      
      setButtonState('downloading');
      SnackbarQueue.add('Downloading update...');
      
      try {
        await waitForWorkerState(worker, 'installed', TIMEOUTS.WORKER_STATE);
        markUpdateReady();
      } catch {
        throw new Error('Download timeout');
      }
    };
    
    const getRegistration = async () => {
      return PWAServiceWorker?.getRegistration() || 
             await navigator.serviceWorker.getRegistration(CONSTANTS.SW_SCOPE);
    };
    
    const createStateChangeHandler = (worker, onInstalled, onInstalling) => () => {
      if (worker.state === 'installed' && onInstalled) onInstalled();
      if (worker.state === 'installing' && onInstalling) onInstalling();
    };
    
    const setupUpdateListener = (reg, resolve) => {
      const updateHandler = () => {
        const newWorker = reg.installing;
        if (!newWorker) return resolve(false);
        
        state.newWorker = newWorker;
        state.registration = reg;
        setButtonState('downloading');
        SnackbarQueue.add('Downloading update...');
        
        newWorker.addEventListener('statechange', createStateChangeHandler(
          newWorker,
          () => {
            markUpdateReady();
            resolve(true);
          },
          () => {
            setButtonState('installing');
            SnackbarQueue.add('Installing update...');
          }
        ));
      };
      
      return updateHandler;
    };
    
    const waitForUpdate = async (reg) => {
      return new Promise((resolve) => {
        const timeout = PWAUtils.createTimeout(() => resolve(false), TIMEOUTS.UPDATE_CHECK);
        const updateHandler = setupUpdateListener(reg, (hasUpdate) => {
          clearTimeout(timeout);
          resolve(hasUpdate);
        });
        
        reg.addEventListener('updatefound', updateHandler, { once: true });
        reg.update().catch(() => {
          clearTimeout(timeout);
          resolve(false);
        });
      });
    };
    
    const checkForUpdates = async () => {
      if (state.isChecking || !('serviceWorker' in navigator)) return;
      
      state.isChecking = true;
      setButtonState('checking');
      SnackbarQueue.add('Checking for updates...');
      
      try {
        const reg = await getRegistration();
        if (!reg) throw new Error('Service worker not registered');
        
        if (reg.waiting) return handleWorker(reg, 'waiting');
        if (reg.installing) return await handleWorker(reg, 'installing');
        
        const hasUpdate = await waitForUpdate(reg);
        if (!hasUpdate) {
          SnackbarQueue.add('Already up to date');
          resetState();
        }
        
      } catch (err) {
        SnackbarQueue.add('Check failed: ' + (err.message || 'Unknown error'));
        resetState();
      }
    };
    
    const performReload = () => {
      setButtonState('reloading');
      cleanup();
      window.location.reload();
    };
    
    const setupReloadWithFallback = (timeoutMs, cleanupFn) => {
      const fallbackTimer = PWAUtils.createTimeout(performReload, timeoutMs);
      
      const triggerReload = () => {
        clearTimeout(fallbackTimer);
        if (cleanupFn) cleanupFn();
        performReload();
      };
      
      return { fallbackTimer, triggerReload };
    };
    
    const setupControllerChangeListener = (fallbackTimer) => {
      const handler = () => {
        clearTimeout(fallbackTimer);
        performReload();
      };
      
      state.controllerChangeListener = handler;
      navigator.serviceWorker.addEventListener('controllerchange', handler, { once: true });
    };
    
    const setupStateChangeListener = (fallbackTimer) => {
      const handler = () => {
        if (state.newWorker.state !== 'activated') return;
        
        clearTimeout(fallbackTimer);
        state.newWorker.removeEventListener('statechange', handler);
        
        PWAUtils.createTimeout(() => {
          if (navigator.serviceWorker.controller === state.newWorker) performReload();
        }, TIMEOUTS.CONTROLLER_VERIFY);
      };
      
      state.newWorker.addEventListener('statechange', handler);
    };
    
    const skipWaiting = (fallbackTimer) => {
      try {
        state.newWorker.postMessage({ action: 'skipWaiting' });
      } catch {
        clearTimeout(fallbackTimer);
        OverlayManager.hide();
        SnackbarQueue.add('Failed to apply update');
        resetState();
      }
    };
    
    const installUpdate = () => {
      if (!state.newWorker || !state.updateAvailable) {
        return SnackbarQueue.add('No update available');
      }
      
      if (AppState.get('isResultShown')) {
        const confirmed = confirm("You've already done some calculations, but don't worry - your stats are safe and will be preserved!");
        if (!confirmed) {
          SnackbarQueue.clear();
          return;
        }
      }
      
      PWAUtils.storageSet(CONSTANTS.PWA_UPDATE_MARKER, 'true');
      OverlayManager.show();
      setButtonState('applying');
      
      const fallbackTimer = PWAUtils.createTimeout(performReload, TIMEOUTS.CONTROLLER_CHANGE);
      
      setupControllerChangeListener(fallbackTimer);
      
      if (state.newWorker.state === 'activated') {
        clearTimeout(fallbackTimer);
        return performReload();
      }
      
      setupStateChangeListener(fallbackTimer);
      skipWaiting(fallbackTimer);
    };
    
    const handleAutoUpdateFound = (worker) => {
      worker.addEventListener('statechange', createStateChangeHandler(
        worker,
        () => {
          if (navigator.serviceWorker.controller) markUpdateReady();
        },
        () => setButtonState('installing')
      ));
    };
    
    const onUpdateFound = (event) => {
      const { worker, registration } = event.detail;
      if (!worker || state.isChecking) return;
      
      state.newWorker = worker;
      state.registration = registration;
      setButtonState('downloading');
      handleAutoUpdateFound(worker);
    };
    
    const cleanup = () => {
      if (state.updateFoundListener) {
        window.removeEventListener('sw-update-found', state.updateFoundListener);
        state.updateFoundListener = null;
      }
      
      if (state.controllerChangeListener) {
        navigator.serviceWorker.removeEventListener('controllerchange', state.controllerChangeListener);
        state.controllerChangeListener = null;
      }
    };
    
    const init = () => {
      const btn = DOM_ELEMENTS.checkUpdateBtn;
      if (!btn) return;
      
      EventManager.add(btn, 'click', () => {
        if (state.isChecking) return;
        state.updateAvailable ? installUpdate() : checkForUpdates();
      });
      
      setButtonState('idle');
      
      state.updateFoundListener = onUpdateFound;
      window.addEventListener('sw-update-found', state.updateFoundListener);
      window.addEventListener('beforeunload', cleanup, { passive: true });
    };
    
    document.readyState === 'loading' ?
      document.addEventListener('DOMContentLoaded', init, { once: true, passive: true }) :
      init();
    
    return { 
      checkForUpdates, 
      installUpdate,
      isUpdatePending: () => state.updateAvailable,
      onUpdateFound,
      cleanup
    };
  })();
  
  window.PWAManualUpdate = PWAManualUpdate;
})();
const initA2HS = (() => {
  const CFG = {
    app: {
      name: 'RöX Calculator APP',
      desc: 'Access instantly, Auto-save calculated stats, and Full functionality without internet!',
      icon: 'https://masihterjaga.github.io/sim/icons/a2hs.png'
    },
    devices: {
      ios: {
        title: 'Install this app on your iPhone:',
        steps: [
          'Tap the <strong>"Share" button <svg style="display:inline;width:14px;height:14px;vertical-align:middle" viewBox="0 0 50 50"><path fill="currentColor" d="M30.3 13.7L25 8.4l-5.3 5.3-1.4-1.4L25 5.6l6.7 6.7z"/><path fill="currentColor" d="M24 7h2v21h-2z"/><path fill="currentColor" d="M35 40H15c-1.7 0-3-1.3-3-3V19c0-1.7 1.3-3 3-3h7v2h-7c-.6 0-1 .4-1 1v18c0 .6.4 1 1 1h20c.6 0 1-.4 1-1V19c0-.6-.4-1-1-1h-7v-2h7c1.7 0 3 1.3 3 3v18c0 1.7-1.3 3-3 3z"/></svg></strong>',
          'Scroll and tap <strong>"Add to Home Screen"</strong>',
          'Tap <strong>"Add"</strong> to confirm'
        ],
        button: null
      },
      android: {
        title: 'Install this app on your device:',
        steps: [
          'Tap the <strong>menu button "⋮"</strong>',
          'Select <strong>"Add to Home Screen"</strong>',
          'Tap <strong>"Add"</strong> or <strong>"Install"</strong>',
          '<strong>Or tap the button below for quick install</strong>'
        ],
        button: {
          icon: '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>',
          text: 'Install App'
        }
      }
    }
  };
  
  const state = {
    deferredPrompt: null,
    installButton: null,
    promptReceived: false
  };
  
  const isInstalled = () => 
    ['standalone', 'fullscreen', 'minimal-ui'].some(m => matchMedia(`(display-mode: ${m})`).matches) ||
    navigator.standalone === true ||
    document.referrer.includes('android-app://') ||
    PWAUtils.storageGet('app_installed') === 'true';
  
  const isDismissed = () => {
    const data = PWAUtils.storageGet(CONSTANTS.A2HS_STORAGE);
    if (!data) return false;
    const parsed = PWAUtils.safeJSONParse(data);
    return parsed?.timestamp && (Date.now() - parsed.timestamp < CONSTANTS.A2HS_DISMISS_EXPIRY);
  };
  
  const detectDevice = () => {
    const ua = navigator.userAgent.toLowerCase();
    if (/iphone|ipod/.test(ua)) return 'ios';
    if (/android/.test(ua) && window.innerWidth < CONSTANTS.A2HS_MOBILE_BP) return 'android';
    return null;
  };
  
  const create = (tag, className = '', attrs = {}) => 
    Object.assign(document.createElement(tag), { className, ...attrs });
  
  const buildModal = (deviceType) => {
    const deviceData = CFG.devices[deviceType];
    
    const closeBtn = create('button', 'a2hs-close', { 
      type: 'button', 
      'aria-label': 'Close', 
      innerHTML: '×' 
    });
    
    const icon = create('div', 'a2hs-icon');
    icon.innerHTML = `<img src="${CFG.app.icon}" alt="${CFG.app.name}" loading="lazy">`;
    
    const info = create('div', 'a2hs-info');
    info.innerHTML = `<h2>${CFG.app.name}</h2><p>${CFG.app.desc}</p>`;
    
    const top = create('div', 'a2hs-top');
    top.append(icon, info);
    
    const header = create('div', 'a2hs-hdr');
    header.append(closeBtn, top);
    
    const body = create('div', 'a2hs-body');
    body.innerHTML = `<p class="a2hs-title">${deviceData.title}</p>`;
    
    const stepsList = create('ol', 'a2hs-steps');
    deviceData.steps.forEach((step, i) => {
      const li = create('li');
      li.innerHTML = `<span>${i + 1}.</span><span>${step}</span>`;
      stepsList.appendChild(li);
    });
    body.appendChild(stepsList);
    
    if (state.promptReceived && deviceData.button) {
      const installBtn = create('button', 'a2hs-btn', { type: 'button' });
      installBtn.innerHTML = `${deviceData.button.icon}${deviceData.button.text}`;
      state.installButton = installBtn;
      body.appendChild(installBtn);
    }
    
    const card = create('div', 'a2hs-card');
    card.append(header, body);
    
    const container = create('div', 'a2hs');
    container.appendChild(card);
    
    return { container, closeBtn, card };
  };
  
  const closeModalVisual = (container) => {
    container?.firstElementChild?.classList.add('a2hs-closing');
    PWAUtils.scheduleTask(() => container?.remove(), CONSTANTS.A2HS_ANIM_DUR);
  };
  
  const saveDismissTimestamp = () => {
    const ts = PWAUtils.safeJSONStringify({ timestamp: Date.now() });
    if (ts) PWAUtils.storageSet(CONSTANTS.A2HS_STORAGE, ts);
  };
  
  const closeModalDismiss = (container) => {
    closeModalVisual(container);
    saveDismissTimestamp();
  };
  
  const triggerInstall = async () => {
    if (!state.deferredPrompt) return false;
    
    await state.deferredPrompt.prompt();
    const { outcome } = await state.deferredPrompt.userChoice;
    
    if (outcome === 'accepted') {
      saveDismissTimestamp();
      PWAUtils.storageSet('app_installed', 'true');
      state.deferredPrompt = null;
      return true;
    }
    
    return false;
  };
  
  const setupModalEvents = (container, closeBtn, card, ns) => {
    EventManager.addNS(ns, closeBtn, 'click', (e) => {
      e.stopPropagation();
      EventManager.removeNS(ns);
      closeModalDismiss(container);
    });
    
    if (state.installButton) {
      EventManager.addNS(ns, state.installButton, 'click', async (e) => {
        e.stopPropagation();
        if (await triggerInstall()) {
          EventManager.removeNS(ns);
          closeModalVisual(container);
        }
      });
    }
    
    EventManager.addNS(ns, card, 'click', (e) => e.stopPropagation());
    EventManager.addNS(ns, DOM_ELEMENTS.altSim, 'click', () => {
      EventManager.removeNS(ns);
      closeModalVisual(container);
    }, { once: true });
  };
  
  const showModal = () => {
    const deviceType = detectDevice();
    if (!deviceType || (deviceType === 'android' && !state.promptReceived)) return;
    
    const { container, closeBtn, card } = buildModal(deviceType);
    const ns = 'a2hs-modal';
    
    document.body.appendChild(container);
    requestAnimationFrame(() => setupModalEvents(container, closeBtn, card, ns));
  };
  
  EventManager.add(window, 'beforeinstallprompt', (e) => {
    e.preventDefault();
    state.deferredPrompt = e;
    state.promptReceived = true;
    
    const existingModal = document.querySelector('.a2hs');
    if (existingModal && !state.installButton) {
      closeModalVisual(existingModal);
      PWAUtils.scheduleTask(showModal, CONSTANTS.A2HS_ANIM_DUR + 100);
    }
  });
  
  EventManager.add(window, 'appinstalled', () => {
    saveDismissTimestamp();
    PWAUtils.storageSet('app_installed', 'true');
    const modal = document.querySelector('.a2hs');
    if (modal) closeModalVisual(modal);
  });
  
  const init = async () => {
    if (isInstalled() || !detectDevice() || isDismissed()) return;
    
    await new Promise(resolve => PWAUtils.scheduleTask(resolve, CONSTANTS.A2HS_MODAL_DELAY));
    await new Promise(r => setTimeout(r, CONSTANTS.A2HS_PROMPT_TIMEOUT));
    
    if (state.promptReceived || detectDevice() === 'ios') showModal();
  };
  
  document.readyState === 'loading' 
    ? document.addEventListener('DOMContentLoaded', init, { once: true, passive: true })
    : init();
})();
const preventPullToRefresh = (() => {
  if (IS_PWA) return;
  
  const state = { lastY: 0, shouldPrevent: false };
  
  const touchStartHandler = (e) => {
    if (e.touches.length !== 1) return;
    state.lastY = e.touches[0].clientY;
    state.shouldPrevent = window.scrollY === 0;
  };
  
  const touchMoveHandler = (e) => {
    if (!state.shouldPrevent) return;
    
    const deltaY = e.touches[0].clientY - state.lastY;
    state.lastY = e.touches[0].clientY;
    
    if (deltaY > 0 && e.cancelable) e.preventDefault();
  };
  
  const touchEndHandler = () => state.shouldPrevent = false;
  
  const opts = { passive: false };
  const optsEnd = { passive: true };
  
  const attachEvents = [
    ['touchstart', touchStartHandler, opts],
    ['touchmove', touchMoveHandler, opts],
    ['touchend', touchEndHandler, optsEnd],
    ['touchcancel', touchEndHandler, optsEnd]
  ];
  
  attachEvents.forEach(([event, handler, options]) => {
    document.addEventListener(event, handler, options);
  });
  
  return () => {
    attachEvents.forEach(([event, handler, options]) => {
      document.removeEventListener(event, handler, options);
    });
  };
})();
const PWAPersistenceInit = (() => {
  if (IS_PWA) return;
  
  let cachedElements = null;
  let restoreInProgress = false;
  let restoreTimeoutId = null;
  
  const RESTORE_TIMEOUT_MS = 3000;
  
  const getFormElements = () => {
    if (!cachedElements) {
      cachedElements = Array.from(document.querySelectorAll(CONSTANTS.FORM_SELECTORS));
    }
    return cachedElements;
  };
  
  const getSelectValue = (el) => {
    const selectedOption = el.options[el.selectedIndex];
    return selectedOption ? {
      text: selectedOption.textContent,
      value: selectedOption.value
    } : null;
  };
  
  const collectFormValues = () => {
    const values = {};
    getFormElements().forEach(el => {
      if (!el.id) return;
      
      if (el.tagName === 'SELECT') {
        const selectValue = getSelectValue(el);
        if (selectValue) values[el.id] = selectValue;
      } else if (el.value) {
        values[el.id] = el.value;
      }
    });
    return values;
  };
  
  const snap = () => {
    const data = PWAUtils.safeJSONStringify({
      form: collectFormValues(),
      isResultShown: true,
      ts: Date.now()
    });
    
    return data ? PWAUtils.storageSet(CONSTANTS.PWA_STORAGE_KEY, data) : false;
  };
  
  const shouldRestore = () => {
    const saved = PWAUtils.storageGet(CONSTANTS.PWA_STORAGE_KEY);
    if (!saved) return null;
    
    const state = PWAUtils.safeJSONParse(saved);
    if (!state) {
      PWAUtils.storageRemove(CONSTANTS.PWA_STORAGE_KEY);
      return null;
    }
    
    if (Date.now() - state.ts > CONSTANTS.PWA_EXPIRY_MS) {
      PWAUtils.storageRemove(CONSTANTS.PWA_STORAGE_KEY);
      return null;
    }
    
    return state;
  };
  
  const finalizeWithMessage = (message, delay = 150) => {
    setTimeout(() => {
      OverlayManager.hide();
      SnackbarQueue.add(message);
      restoreInProgress = false;
    }, delay);
  };
  
  const handleRestoreError = (error) => {
    console.error('Restore failed:', error);
    
    if (restoreTimeoutId) {
      clearTimeout(restoreTimeoutId);
      restoreTimeoutId = null;
    }
    
    PWAUtils.storageRemove(CONSTANTS.PWA_STORAGE_KEY);
    OverlayManager.forceRemove();
    restoreInProgress = false;
    
    setTimeout(() => {
      SnackbarQueue.add('Failed to restore previous data. Starting fresh.');
    }, 100);
  };
  
  const checkCalculationDone = () => {
    if (!restoreInProgress) return;
    
    requestAnimationFrame(() => {
      if (AppState.get('isResultShown')) {
        if (restoreTimeoutId) {
          clearTimeout(restoreTimeoutId);
          restoreTimeoutId = null;
        }
        finalizeWithMessage('Data restored successfully');
      } else {
        checkCalculationDone();
      }
    });
  };
  
  const restoreSelectValue = (el, val) => {
    if (typeof val !== 'object' || !val.text || !val.value) return;
    
    const options = Array.from(el.options);
    const matchedOption = options.find(opt => opt.textContent === val.text);
    
    if (matchedOption) {
      el.selectedIndex = options.indexOf(matchedOption);
    } else {
      el.value = val.value;
    }
  };
  
  const performRestore = (state) => {
    try {
      let restoredCount = 0;
      
      Object.entries(state.form).forEach(([id, val]) => {
        try {
          const el = document.getElementById(id);
          if (!el) return;
          
          if (el.tagName === 'SELECT') {
            restoreSelectValue(el, val);
          } else {
            el.value = typeof val === 'object' ? val.value : val;
          }
          restoredCount++;
        } catch (fieldError) {
          console.warn(`Failed to restore field ${id}:`, fieldError);
        }
      });
      
      if (restoredCount === 0) {
        throw new Error('No fields were restored');
      }
      
      if (!state.isResultShown) {
        OverlayManager.hide();
        restoreInProgress = false;
        return;
      }
      
      restoreTimeoutId = PWAUtils.createTimeout(() => {
        handleRestoreError(new Error('Restore timeout: calculation took too long'));
      }, RESTORE_TIMEOUT_MS);
      
      PWAUtils.scheduleTask(() => {
        try {
          processMainCalculation();
          checkCalculationDone();
        } catch (calcError) {
          handleRestoreError(calcError);
        }
      }, CONSTANTS.PWA_RESTORE_DELAY_MS);
      
    } catch (error) {
      handleRestoreError(error);
    }
  };
  
  const handlePWAExit = () => {
    if (AppState.get('isResultShown')) snap();
  };
  
  const init = () => {
    const opts = { capture: true };
    const events = [
      ['visibilitychange', () => { if (document.hidden) handlePWAExit(); }, opts, document],
      ['pagehide', handlePWAExit, opts, window]
    ];
    
    events.forEach(([event, handler, options, target]) => {
      EventManager.addNS(CONSTANTS.PWA_NAMESPACE, target, event, handler, options);
    });
  };
  
  const state = shouldRestore();
  const isUpdating = PWAUtils.storageGet(CONSTANTS.PWA_UPDATE_MARKER) === 'true';
  
  if (state || isUpdating) {
    OverlayManager.show();
    restoreInProgress = true;
    
    if (isUpdating) PWAUtils.storageRemove(CONSTANTS.PWA_UPDATE_MARKER);
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    init();
    
    if (state) {
      try {
        performRestore(state);
      } catch (error) {
        handleRestoreError(error);
      }
    } else if (isUpdating) {
      finalizeWithMessage('Update completed successfully', 300);
    }
    
    dropdownManager?.scheduleUpdate();
  }, { passive: true });
  
  window.PWAPersistence = {
    snap,
    isRestoring: () => restoreInProgress
  };
  
  window.clearPWAStorage = () => {
    PWAUtils.storageRemove(CONSTANTS.PWA_STORAGE_KEY);
    EventManager.removeNS(CONSTANTS.PWA_NAMESPACE);
    restoreInProgress = false;
    
    if (restoreTimeoutId) {
      clearTimeout(restoreTimeoutId);
      restoreTimeoutId = null;
    }
    
    return true;
  };
})();

// ========== RESET SYSTEM ==========
const ResetHelpers = {
  clearDebounceTimers() {
    if (window.debounceCleanupInterval) {
      clearInterval(window.debounceCleanupInterval);
      window.debounceCleanupInterval = null;
    }
    
    if (window.debounceMap) {
      window.debounceMap.forEach(data => {
        if (data?.timerId) clearTimeout(data.timerId);
      });
      window.debounceMap.clear();
    }
  },

  resetDropdownManager() {
    if (typeof dropdownManager === 'undefined') return;
    
    dropdownManager.state.selectionOrder = [];
    dropdownManager.state.lockStates.clear();
    dropdownManager.state.isSwapping = false;
    
    if (dropdownManager.state.updateTimer) {
      clearTimeout(dropdownManager.state.updateTimer);
      dropdownManager.state.updateTimer = null;
    }
  },

  resetStickyHandler() {
    if (typeof stickyHandler === 'undefined') return;

    if (stickyHandler.scrollRAF) {
      cancelAnimationFrame(stickyHandler.scrollRAF);
      stickyHandler.scrollRAF = null;
    }

    stickyHandler.clearAllTimeouts?.();

    if (stickyHandler.state) {
      stickyHandler.state.isActive = false;
      stickyHandler.state.isCollapsed = false;
      stickyHandler.state.animating = false;
    }

    const buttons = stickyHandler.getOrderedButtons?.() || [];
    buttons.forEach(button => {
      button.classList.remove('sticky', 'collapsed');
      button.style.cssText = '';
      if (button.dataset.originalText) {
        button.textContent = button.dataset.originalText;
      }
    });

    const toggleBtn = stickyHandler.elements?.get('toggleBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  },

  resetValidation() {
    if (typeof ValidationSSoTInstance === 'undefined') return;
    
    ValidationSSoTInstance.touchedFields.clear();
    ValidationSSoTInstance.snackbarCooldowns.clear();
  },

  resetFormInputs() {
    document.querySelectorAll('input[type="number"], input[type="text"], select, textarea').forEach(el => {
      el.value = '';
      el.disabled = false;
      el.classList.remove('invalid-value');

      const wrapper = el.closest('.input-wrap');
      if (wrapper) {
        wrapper.classList.remove('locked');
        delete wrapper.dataset.tempUnlocked;
      }
    });
  },

  resetDisplayContainers() {
    if (DOM_ELEMENTS.hasil) {
      DOM_ELEMENTS.hasil.innerHTML = '';
      DOM_ELEMENTS.hasil.textContent = 'Enter your stats to see the results...';
      delete DOM_ELEMENTS.hasil.dataset.showFullPrecision;
      delete DOM_ELEMENTS.hasil.dataset.specificMode;
    }

    if (DOM_ELEMENTS.rec) {
      DOM_ELEMENTS.rec.innerHTML = '';
      DOM_ELEMENTS.rec.textContent = 'Recommended stat allocations will appear here. This tool uses your current stats as a base, then randomizes the numbers to find better combinations for higher damage output.';
    }
  },

  resetButtons() {
    if (DOM_ELEMENTS.submit) {
      DOM_ELEMENTS.submit.disabled = false;
      DOM_ELEMENTS.submit.textContent = "Calculate";
    }

    [DOM_ELEMENTS.resetRek, DOM_ELEMENTS.testSpear, DOM_ELEMENTS.testReaper]
      .forEach(btn => {
        if (btn) {
          btn.disabled = true;
          btn.classList.remove('activated');
        }
      });
  },

  cleanupStickyStates() {
    document.querySelectorAll('.sticky').forEach(el => {
      el.classList.remove('sticky', 'collapsed');
      el.style.cssText = '';
      if (el.dataset.originalText) {
        el.textContent = el.dataset.originalText;
      }
    });

    const toggleBtn = document.getElementById('toggleStickyBtn');
    if (toggleBtn) toggleBtn.dataset.collapse = 'false';
  },

  resetSnackbar() {
    if (DOM_ELEMENTS.snackbar) {
      DOM_ELEMENTS.snackbar.classList.remove('show');
      DOM_ELEMENTS.snackbar.style.cssText = '';
    }
    delete window._lastSnackbarTime;
  },

  reinitializeComponents() {
    if (typeof dropdownManager !== 'undefined' && dropdownManager.init) {
      dropdownManager.populateAllDropdowns();
      dropdownManager.updateAll();
      dropdownManager.syncThreeSets();
    }

    ValidationSSoTInstance?.init?.();
    stickyHandler?.updateSticky?.();
  },

  scrollToTop(smooth = true) {
    if (DOM_ELEMENTS.topOfPage) {
      const offsetTop = DOM_ELEMENTS.topOfPage.getBoundingClientRect().top + 
        window.pageYOffset - CONSTANTS.SCROLL_OFFSET;
      window.scrollTo({ top: offsetTop, behavior: smooth ? 'smooth' : 'auto' });
    } else {
      window.scrollTo({ top: 0, behavior: smooth ? 'smooth' : 'auto' });
    }
  }
};
const CleanupManager = (() => {
  let isCleaningUp = false;
  
  const cleanupListeners = () => {
    if (typeof EventManager !== 'undefined') {
      EventManager.forceCleanup?.();
      EventManager.removeAll?.();
    }
    
    AppState?.clearListeners?.();
    
    if (window._buttonListenerIds && typeof EventManager !== 'undefined') {
      window._buttonListenerIds.forEach(id => EventManager.remove?.(id));
      window._buttonListenerIds = [];
    }
  };
  
  const cleanupTimers = () => {
    ResetHelpers.clearDebounceTimers();
  };
  
  const cleanupManagers = () => {
    ValidationSSoTInstance?.destroy?.();
    TooltipManager?.destroyAll?.();
    SnackbarManager?.cleanup?.();
    dropdownManager?.destroy?.();
    stickyHandler?.destroy?.();
    accordionManager?.destroy?.();
    modalManager?.destroy?.();
  };
  
  const cleanupCache = () => {
    cache?.clear?.();
    RandomGenerator?.reset?.();
    
    delete window._eventsAlreadyBound;
    delete window._lastSnackbarTime;
  };
  
  const cleanupAll = () => {
    if (isCleaningUp) return;
    isCleaningUp = true;
    
    try {
      cleanupListeners();
      cleanupTimers();
      cleanupManagers();
      cleanupCache();
    } finally {
      isCleaningUp = false;
    }
  };
  
  return { 
    cleanupListeners, 
    cleanupTimers, 
    cleanupManagers, 
    cleanupCache, 
    cleanupAll 
  };
})();
function clearCache() {
  if (!confirm('Clear all cache?')) return;
  

  RandomGenerator.reset();
  
  caches.keys().then(keys => {
  keys.forEach(key => caches.delete(key))
  })
  
  showSnackbar('Cache Cleared!');
};
function resetAllData() {
  if (!confirm('Reset all data and inputs (including cache)?')) return;

  clearCache();
  
  localStorage.clear();
  AppState.reset();
  ResetHelpers.clearDebounceTimers();
  ResetHelpers.resetDropdownManager();
  ResetHelpers.resetStickyHandler();
  ResetHelpers.resetValidation();
  
  SnackbarManager?.cleanup?.();
  
  ResetHelpers.resetFormInputs();
  ResetHelpers.resetDisplayContainers();
  ResetHelpers.resetButtons();
  ResetHelpers.cleanupStickyStates();
  ResetHelpers.resetSnackbar();
  ResetHelpers.reinitializeComponents();
  ResetHelpers.scrollToTop();

  const message = 'All data reset!';
  setTimeout(() => showSnackbar?.(message), CONSTANTS.SNACKBAR_DELAY);
};

// ========
EventManager.add(window, 'beforeunload', () => {
  CleanupManager.cleanupListeners();
  CleanupManager.cleanupTimers();
});